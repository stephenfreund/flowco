{
  "file_name": "jumps.json",
  "dfg": {
    "description": "",
    "nodes": [
      {
        "id": "Step-1",
        "pill": "Clean-Jumps",
        "label": "Clean Jumps data",
        "geometry": {
          "x": 90.0,
          "y": 70.0,
          "width": 160.0,
          "height": 80.0
        },
        "output_geometry": {
          "x": 350.0,
          "y": 70.0,
          "width": 400.0,
          "height": 300.0
        },
        "function_name": "compute_clean_jumps",
        "function_result_var": "clean_jumps_result",
        "predecessors": [],
        "phase": 5,
        "cache": {
          "caches": {
            "3": {
              "in_values": {
                "requirements": [
                  "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                  "clean_jumps_result contains no missing (NA) values in any column.",
                  "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
                ],
                "algorithm": [
                  "Obtain the raw data by calling the global function `triple_vertical_table()`, which returns a DataFrame containing columns 'triple' and 'vertical'.",
                  "Assign the DataFrame obtained from `triple_vertical_table()` to a variable, say `jumps_data`.",
                  "Identify any missing (NA) values in `jumps_data`.",
                  "Remove any rows that contain missing (NA) values in `jumps_data`. This can be done by using available pandas functions to drop missing values.",
                  "Assign the cleaned DataFrame to `clean_jumps_result`.",
                  "Return `clean_jumps_result` as the final output, ensuring it contains no missing values."
                ]
              },
              "out_values": {
                "code": [
                  "import pandas as pd",
                  "def compute_clean_jumps() -> pd.DataFrame:",
                  "    # Obtain the raw data from the global function",
                  "    jumps_data = triple_vertical_table()",
                  "    ",
                  "    # Remove any rows with missing values",
                  "    cleaned_data = jumps_data.dropna()",
                  "    ",
                  "    return cleaned_data"
                ]
              },
              "valid": true
            }
          }
        },
        "function_parameters": [],
        "preconditions": {
          "triple_vertical": [
            "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
          ]
        },
        "requirements": [
          "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
          "clean_jumps_result contains no missing (NA) values in any column.",
          "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
        ],
        "description": "The 'Clean Jumps' step involves processing the data obtained from `triple_vertical_table()` to ensure it is suitable for further analysis. This function removes any missing values and ensures the data integrity and completeness are maintained, resulting in a cleaned DataFrame. The cleaning process ensures that subsequent computations are working with the most relevant and accurate data possible.",
        "function_return_type": {
          "type": "pd.DataFrame['triple': float, 'vertical': float]"
        },
        "function_computed_value": "A cleaned DataFrame of jump data with no missing values, containing 'triple' and 'vertical' columns.",
        "algorithm": [
          "Obtain the raw data by calling the global function `triple_vertical_table()`, which returns a DataFrame containing columns 'triple' and 'vertical'.",
          "Assign the DataFrame obtained from `triple_vertical_table()` to a variable, say `jumps_data`.",
          "Identify any missing (NA) values in `jumps_data`.",
          "Remove any rows that contain missing (NA) values in `jumps_data`. This can be done by using available pandas functions to drop missing values.",
          "Assign the cleaned DataFrame to `clean_jumps_result`.",
          "Return `clean_jumps_result` as the final output, ensuring it contains no missing values."
        ],
        "code": [
          "import pandas as pd",
          "def compute_clean_jumps() -> pd.DataFrame:",
          "    # Obtain the raw data from the global function",
          "    jumps_data = triple_vertical_table()",
          "    ",
          "    # Remove any rows with missing values",
          "    cleaned_data = jumps_data.dropna()",
          "    ",
          "    return cleaned_data"
        ],
        "result": {
          "result": {
            "pickle": "gASVFwUAAAAAAACMEXBhbmRhcy5jb3JlLmZyYW1llIwJRGF0YUZyYW1llJOUKYGUfZQojARfbWdylIwecGFuZGFzLmNvcmUuaW50ZXJuYWxzLm1hbmFnZXJzlIwMQmxvY2tNYW5hZ2VylJOUjBZwYW5kYXMuX2xpYnMuaW50ZXJuYWxzlIwPX3VucGlja2xlX2Jsb2NrlJOUjBZudW1weS5fY29yZS5tdWx0aWFycmF5lIwMX3JlY29uc3RydWN0lJOUjAVudW1weZSMB25kYXJyYXmUk5RLAIWUQwFilIeUUpQoSwFLAksohpRoD4wFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGKJQoACAAAAAAAAAPB3QAAAAAAAaIhAKVyPwvWMgUBcj8L1KISDQKRwPQrX43tAZmZmZmYagEDsUbgehRN8QOF6FK5Hh4FAKVyPwvU4gEDXo3A9CpuCQI/C9Shcc4VAj8L1KFzNgkCkcD0K10mBQPYoXI/CiYBA4XoUrkeJgUCuR+F6FB59QM3MzMzMFH9ASOF6FK6FgkCamZmZmT+FQI/C9Shcn4BAcT0K16OWgUAUrkfhevh7QBSuR+F6XIVAzczMzMy0g0DsUbgehSWEQD0K16Nw9X1AmpmZmZlPh0ApXI/C9diEQK5H4XoUunlAhetRuB41fkCPwvUoXPWDQFK4HoXr2X1AmpmZmZk5fUApXI/C9QR5QClcj8L1VIJArkfhehQKgECPwvUoXAt9QOxRuB6FM3lArkfhehS6fUC4HoXrUcCBQAAAAAAAgEBAZmZmZmbGUUAAAAAAACBPQArXo3A9qk5AuB6F61EYREB7FK5H4XpDQLgehetR2ENA4XoUrkdBR0DXo3A9CtdCQD0K16NwvUpAZmZmZmZ2UEDNzMzMzMxMQBSuR+F61EJAmpmZmZnZREA9CtejcH1IQFK4HoXrEUFAj8L1KFwPTEAUrkfhevRKQGZmZmZm5lBAhetRuB6lSUApXI/C9ehKQGZmZmZmBkVAZmZmZmZGSEBxPQrXo7BQQHE9CtejsE1A16NwPQrXRUApXI/C9YhQQAAAAAAAwE5AMzMzMzPTQkDsUbgehctCQM3MzMzMDE5AKVyPwvVIRUBcj8L1KPxIQPYoXI/CNUhAFK5H4Xo0SkDD9ShcjyJFQOF6FK5H4UFAexSuR+F6QUDsUbgehetEQKRwPQrXw0dAlHSUYowIYnVpbHRpbnOUjAVzbGljZZSTlEsASwJLAYeUUpRLAoeUUpSFlF2UKIwYcGFuZGFzLmNvcmUuaW5kZXhlcy5iYXNllIwKX25ld19JbmRleJSTlGgpjAVJbmRleJSTlH2UKIwEZGF0YZRoDmgRSwCFlGgTh5RSlChLAUsChZRoGIwCTziUiYiHlFKUKEsDjAF8lE5OTkr/////Sv////9LP3SUYoldlCiMBnRyaXBsZZSMCHZlcnRpY2FslGV0lGKMBG5hbWWUTnWGlFKUaCuMGXBhbmRhcy5jb3JlLmluZGV4ZXMucmFuZ2WUjApSYW5nZUluZGV4lJOUfZQoaD1OjAVzdGFydJRLAIwEc3RvcJRLKIwEc3RlcJRLAXWGlFKUZYaUUpSMBF90eXCUjAlkYXRhZnJhbWWUjAlfbWV0YWRhdGGUXZSMBWF0dHJzlH2UjAZfZmxhZ3OUfZSMF2FsbG93c19kdXBsaWNhdGVfbGFiZWxzlIhzdWIu\n",
            "text": "    triple  vertical\n0   383.00     33.00\n1   781.00     71.10\n2   561.62     62.25\n3   624.52     61.33\n4   446.24     40.19\n5   515.30     38.96\n6   449.22     39.69\n7   560.91     46.51\n8   519.12     37.68\n9   595.38     53.48\n10  686.42     65.85\n11  601.67     57.60\n12  553.23     37.66\n13  529.22     41.70\n14  561.16     48.98\n15  465.88     34.14\n16  497.30     56.12\n17  592.71     53.91\n18  679.95     67.60\n19  531.92     51.29\n20  562.83     53.82\n21  447.53     42.05\n22  683.56     48.55\n23  630.60     66.76\n24  644.69     59.38\n25  479.34     43.68\n26  745.95     66.14\n27  667.12     61.50\n28  411.63     37.65\n29  483.32     37.59\n30  638.67     60.10\n31  477.62     42.57\n32  467.60     49.97\n33  400.31     48.42\n34  586.62     52.41\n35  513.26     42.27\n36  464.71     35.76\n37  403.22     34.96\n38  475.63     41.84\n39  568.04     47.53\n"
          },
          "output": null
        },
        "sanity_checks": null,
        "unit_tests": null,
        "sanity_check_results": {},
        "unit_test_results": {},
        "messages": [],
        "questions": null,
        "build_status": null
      },
      {
        "id": "Step-2",
        "pill": "Computer-Pearson",
        "label": "Computer Pearson Correlation",
        "geometry": {
          "x": 350.0,
          "y": 70.0,
          "width": 160.0,
          "height": 80.0
        },
        "output_geometry": {
          "x": 540.0,
          "y": 60.0,
          "width": 140.0,
          "height": 80.0
        },
        "function_name": "compute_computer_pearson",
        "function_result_var": "computer_pearson_result",
        "predecessors": [
          "Step-1"
        ],
        "phase": 5,
        "cache": {
          "caches": {
            "3": {
              "in_values": {
                "requirements": [
                  "pearson_correlation is a float.",
                  "pearson_correlation represents the Pearson correlation coefficient between 'triple' and 'vertical' columns of clean_jumps_result."
                ],
                "algorithm": [
                  "Define a function `compute_pearson_correlation(clean_jumps_result)`.",
                  "Within the function, start by verifying that the input `clean_jumps_result` is a pandas DataFrame with the columns `triple` and `vertical`.",
                  "Ensure that there are no missing (NA) values within `clean_jumps_result`. If there are any, raise an error or warning, as the input precondition is not met.",
                  "Use the pandas DataFrame method `corr()` on `clean_jumps_result` to compute the Pearson correlation matrix.",
                  "Extract the correlation value between the `triple` and `vertical` columns from the matrix. This can often be accessed via `corr().loc['triple', 'vertical']`.",
                  "Assign this correlation value to the variable `pearson_correlation`.",
                  "Return the `pearson_correlation`."
                ]
              },
              "out_values": {
                "code": [
                  "import pandas as pd",
                  "def compute_computer_pearson(clean_jumps_result: pd.DataFrame) -> float:",
                  "    # Verify the input is a valid DataFrame with correct columns",
                  "    if not isinstance(clean_jumps_result, pd.DataFrame) or 'triple' not in clean_jumps_result.columns or 'vertical' not in clean_jumps_result.columns:",
                  "        raise ValueError(\"Input must be a DataFrame with 'triple' and 'vertical' columns.\")",
                  "    ",
                  "    # Calculate the Pearson correlation",
                  "    correlation_matrix = clean_jumps_result.corr(method='pearson')",
                  "    pearson_correlation = correlation_matrix.loc['triple', 'vertical']",
                  "    ",
                  "    return pearson_correlation"
                ]
              },
              "valid": true
            }
          }
        },
        "function_parameters": [
          {
            "name": "clean_jumps_result",
            "type": {
              "type": "pd.DataFrame['triple': float, 'vertical': float]"
            }
          }
        ],
        "preconditions": {
          "clean_jumps_result": [
            "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
            "clean_jumps_result contains no missing (NA) values in any column.",
            "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
          ],
          "triple_vertical": [
            "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
          ]
        },
        "requirements": [
          "pearson_correlation is a float.",
          "pearson_correlation represents the Pearson correlation coefficient between 'triple' and 'vertical' columns of clean_jumps_result."
        ],
        "description": "This computation calculates the Pearson correlation coefficient between the 'triple' and 'vertical' columns of the 'clean_jumps_result' DataFrame. Pearson correlation measures the linear correlation between two sets of data, providing a value between -1 and 1. This step helps in understanding the strength and direction of the linear relationship between the two types of jumps.",
        "function_return_type": {
          "type": "float"
        },
        "function_computed_value": "The computed value is the Pearson correlation coefficient as a float.",
        "algorithm": [
          "Define a function `compute_pearson_correlation(clean_jumps_result)`.",
          "Within the function, start by verifying that the input `clean_jumps_result` is a pandas DataFrame with the columns `triple` and `vertical`.",
          "Ensure that there are no missing (NA) values within `clean_jumps_result`. If there are any, raise an error or warning, as the input precondition is not met.",
          "Use the pandas DataFrame method `corr()` on `clean_jumps_result` to compute the Pearson correlation matrix.",
          "Extract the correlation value between the `triple` and `vertical` columns from the matrix. This can often be accessed via `corr().loc['triple', 'vertical']`.",
          "Assign this correlation value to the variable `pearson_correlation`.",
          "Return the `pearson_correlation`."
        ],
        "code": [
          "import pandas as pd",
          "def compute_computer_pearson(clean_jumps_result: pd.DataFrame) -> float:",
          "    # Verify the input is a valid DataFrame with correct columns",
          "    if not isinstance(clean_jumps_result, pd.DataFrame) or 'triple' not in clean_jumps_result.columns or 'vertical' not in clean_jumps_result.columns:",
          "        raise ValueError(\"Input must be a DataFrame with 'triple' and 'vertical' columns.\")",
          "    ",
          "    # Calculate the Pearson correlation",
          "    correlation_matrix = clean_jumps_result.corr(method='pearson')",
          "    pearson_correlation = correlation_matrix.loc['triple', 'vertical']",
          "    ",
          "    return pearson_correlation"
        ],
        "result": {
          "result": {
            "pickle": "gASVagAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCGVQVA6msuo/lIaUUpQu\n",
            "text": "0.8343076972837592\n"
          },
          "output": {
            "output_type": "text",
            "data": "0.8343076972837592\n"
          }
        },
        "sanity_checks": null,
        "unit_tests": null,
        "sanity_check_results": {},
        "unit_test_results": {},
        "messages": [],
        "questions": null,
        "build_status": null
      },
      {
        "id": "Step-3",
        "pill": "Compute-Slope",
        "label": "Compute slope and intercept of regression line",
        "geometry": {
          "x": 340.0,
          "y": 200.0,
          "width": 160.0,
          "height": 80.0
        },
        "output_geometry": {
          "x": 600.0,
          "y": 200.0,
          "width": 400.0,
          "height": 300.0
        },
        "function_name": "compute_compute_slope",
        "function_result_var": "compute_slope_result",
        "predecessors": [
          "Step-1"
        ],
        "phase": 5,
        "cache": {
          "caches": {
            "3": {
              "in_values": {
                "requirements": [
                  "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                  "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                  "The slope and intercept are both floats."
                ],
                "algorithm": [
                  "Initialize a function to compute the slope and intercept of a regression line using a DataFrame input, clean_jumps_result, with 'triple' as the independent variable and 'vertical' as the dependent variable.",
                  "Access the 'triple' column from clean_jumps_result and set it as the independent variable X.",
                  "Access the 'vertical' column from clean_jumps_result and set it as the dependent variable Y.",
                  "Import the LinearRegression class from the sklearn.linear_model module.",
                  "Create an instance of the LinearRegression class.",
                  "Reshape X into a 2D array compatible with sklearn's requirements.",
                  "Fit the linear regression model to the data by passing X and Y into the fit method of the LinearRegression instance.",
                  "Retrieve the coefficient property of the fitted linear regression model, which represents the slope of the regression line.",
                  "Retrieve the intercept property of the fitted linear regression model, which represents the intercept of the regression line.",
                  "Return a tuple containing the computed slope and intercept as floats."
                ]
              },
              "out_values": {
                "code": [
                  "from typing import Tuple",
                  "import pandas as pd",
                  "from sklearn.linear_model import LinearRegression",
                  "def compute_compute_slope(clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
                  "    X = clean_jumps_result[['triple']].values  # Reshape to 2D array",
                  "    Y = clean_jumps_result['vertical'].values",
                  "    model = LinearRegression()",
                  "    model.fit(X, Y)",
                  "    slope = float(model.coef_[0])  # Get the slope (coefficient) and convert to float",
                  "    intercept = float(model.intercept_)  # Get the intercept and convert to float",
                  "    return (slope, intercept)"
                ]
              },
              "valid": true
            }
          }
        },
        "function_parameters": [
          {
            "name": "clean_jumps_result",
            "type": {
              "type": "pd.DataFrame['triple': float, 'vertical': float]"
            }
          }
        ],
        "preconditions": {
          "clean_jumps_result": [
            "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
            "clean_jumps_result contains no missing (NA) values in any column.",
            "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
          ],
          "triple_vertical": [
            "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
          ]
        },
        "requirements": [
          "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
          "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
          "The slope and intercept are both floats."
        ],
        "description": "This computation step calculates the slope and intercept of a linear regression line that models the relationship between the 'triple' and 'vertical' columns in the clean_jumps_result DataFrame. It uses simple linear regression methods to determine how changes in 'triple' values predict changes in 'vertical' values. The slope represents the rate of change in 'vertical' for a unit change in 'triple', and the intercept represents the expected value of 'vertical' when 'triple' is zero.",
        "function_return_type": {
          "type": "Tuple[float, float]"
        },
        "function_computed_value": "A tuple containing the float values for the slope and intercept of the regression line.",
        "algorithm": [
          "Initialize a function to compute the slope and intercept of a regression line using a DataFrame input, clean_jumps_result, with 'triple' as the independent variable and 'vertical' as the dependent variable.",
          "Access the 'triple' column from clean_jumps_result and set it as the independent variable X.",
          "Access the 'vertical' column from clean_jumps_result and set it as the dependent variable Y.",
          "Import the LinearRegression class from the sklearn.linear_model module.",
          "Create an instance of the LinearRegression class.",
          "Reshape X into a 2D array compatible with sklearn's requirements.",
          "Fit the linear regression model to the data by passing X and Y into the fit method of the LinearRegression instance.",
          "Retrieve the coefficient property of the fitted linear regression model, which represents the slope of the regression line.",
          "Retrieve the intercept property of the fitted linear regression model, which represents the intercept of the regression line.",
          "Return a tuple containing the computed slope and intercept as floats."
        ],
        "code": [
          "from typing import Tuple",
          "import pandas as pd",
          "from sklearn.linear_model import LinearRegression",
          "def compute_compute_slope(clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
          "    X = clean_jumps_result[['triple']].values  # Reshape to 2D array",
          "    Y = clean_jumps_result['vertical'].values",
          "    model = LinearRegression()",
          "    model.fit(X, Y)",
          "    slope = float(model.coef_[0])  # Get the slope (coefficient) and convert to float",
          "    intercept = float(model.intercept_)  # Get the intercept and convert to float",
          "    return (slope, intercept)"
        ],
        "result": {
          "result": {
            "pickle": "gASVFQAAAAAAAABHP7fMDGRrR45Hv/kQeEu2BMCGlC4=\n",
            "text": "(0.09295728160512182, -1.5665209729634597)\n"
          },
          "output": null
        },
        "sanity_checks": null,
        "unit_tests": null,
        "sanity_check_results": {},
        "unit_test_results": {},
        "messages": [],
        "questions": null,
        "build_status": null
      },
      {
        "id": "Step-4",
        "pill": "Plot-That",
        "label": "Plot that line and the data on a scatter plot",
        "geometry": {
          "x": 640.0,
          "y": 150.0,
          "width": 160.0,
          "height": 80.0
        },
        "output_geometry": {
          "x": 980.0,
          "y": 110.0,
          "width": 400.0,
          "height": 300.0
        },
        "function_name": "compute_plot_that",
        "function_result_var": "plot_that_result",
        "predecessors": [
          "Step-1",
          "Step-3"
        ],
        "phase": 5,
        "cache": {
          "caches": {
            "3": {
              "in_values": {
                "requirements": [
                  "Generate a scatter plot of the 'triple' column on the x-axis and 'vertical' column on the y-axis from clean_jumps_result.",
                  "Overlay the regression line using the computed slope and intercept from compute_slope_result.",
                  "Ensure that the plot includes appropriate labels and a legend for clarity."
                ],
                "algorithm": [
                  "Load the 'triple' and 'vertical' columns from the 'clean_jumps_result' DataFrame for plotting.",
                  "Create a scatter plot with the 'triple' column on the x-axis and the 'vertical' column on the y-axis using matplotlib.",
                  "Retrieve the slope and intercept from the 'compute_slope_result' tuple.",
                  "Compute the y-values for the regression line using the formula: \\[ \\text{y} = (\\text{slope} \\times \\text{triple}) + \\text{intercept} \\]",
                  "Overlay the regression line on the scatter plot.",
                  "Add labels for the x-axis as 'Triple' and y-axis as 'Vertical'.",
                  "Include a title for the plot, such as 'Scatter Plot with Regression Line'.",
                  "Add a legend to distinguish between data points and the regression line.",
                  "Display the plot."
                ]
              },
              "out_values": {
                "code": [
                  "import matplotlib.pyplot as plt",
                  "import seaborn as sns",
                  "import pandas as pd",
                  "from typing import Tuple",
                  "def compute_plot_that(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
                  "    # Extract the slope and intercept from the compute_slope_result",
                  "    slope, intercept = compute_slope_result",
                  "    # Create the scatter plot",
                  "    plt.figure(figsize=(10, 6))",
                  "    sns.scatterplot(x='triple', y='vertical', data=clean_jumps_result, label='Data Points')",
                  "    # Compute the regression line values",
                  "    x_values = clean_jumps_result['triple']",
                  "    y_values = slope * x_values + intercept",
                  "    # Plot the regression line",
                  "    plt.plot(x_values, y_values, color='red', label='Regression Line')",
                  "    # Add labels and title",
                  "    plt.xlabel('Triple')",
                  "    plt.ylabel('Vertical')",
                  "    plt.title('Scatter Plot with Regression Line')",
                  "    plt.legend()",
                  "    # Draw the plot",
                  "    plt.draw()"
                ]
              },
              "valid": true
            }
          }
        },
        "function_parameters": [
          {
            "name": "clean_jumps_result",
            "type": {
              "type": "pd.DataFrame['triple': float, 'vertical': float]"
            }
          },
          {
            "name": "compute_slope_result",
            "type": {
              "type": "Tuple[float, float]"
            }
          }
        ],
        "preconditions": {
          "clean_jumps_result": [
            "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
            "clean_jumps_result contains no missing (NA) values in any column.",
            "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
          ],
          "compute_slope_result": [
            "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
            "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
            "The slope and intercept are both floats."
          ],
          "triple_vertical": [
            "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
          ]
        },
        "requirements": [
          "Generate a scatter plot of the 'triple' column on the x-axis and 'vertical' column on the y-axis from clean_jumps_result.",
          "Overlay the regression line using the computed slope and intercept from compute_slope_result.",
          "Ensure that the plot includes appropriate labels and a legend for clarity."
        ],
        "description": "This step generates a visual representation of the linear relationship between the 'triple' and 'vertical' columns in the clean_jumps_result dataset. A scatter plot is created to display the data points, and the computed regression line is overlaid to illustrate the fit. This plot helps to visually assess the correlation and the accuracy of the linear model.",
        "function_return_type": {
          "type": "None"
        },
        "function_computed_value": "None",
        "algorithm": [
          "Load the 'triple' and 'vertical' columns from the 'clean_jumps_result' DataFrame for plotting.",
          "Create a scatter plot with the 'triple' column on the x-axis and the 'vertical' column on the y-axis using matplotlib.",
          "Retrieve the slope and intercept from the 'compute_slope_result' tuple.",
          "Compute the y-values for the regression line using the formula: \\[ \\text{y} = (\\text{slope} \\times \\text{triple}) + \\text{intercept} \\]",
          "Overlay the regression line on the scatter plot.",
          "Add labels for the x-axis as 'Triple' and y-axis as 'Vertical'.",
          "Include a title for the plot, such as 'Scatter Plot with Regression Line'.",
          "Add a legend to distinguish between data points and the regression line.",
          "Display the plot."
        ],
        "code": [
          "import matplotlib.pyplot as plt",
          "import seaborn as sns",
          "import pandas as pd",
          "from typing import Tuple",
          "def compute_plot_that(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
          "    # Extract the slope and intercept from the compute_slope_result",
          "    slope, intercept = compute_slope_result",
          "    # Create the scatter plot",
          "    plt.figure(figsize=(10, 6))",
          "    sns.scatterplot(x='triple', y='vertical', data=clean_jumps_result, label='Data Points')",
          "    # Compute the regression line values",
          "    x_values = clean_jumps_result['triple']",
          "    y_values = slope * x_values + intercept",
          "    # Plot the regression line",
          "    plt.plot(x_values, y_values, color='red', label='Regression Line')",
          "    # Add labels and title",
          "    plt.xlabel('Triple')",
          "    plt.ylabel('Vertical')",
          "    plt.title('Scatter Plot with Regression Line')",
          "    plt.legend()",
          "    # Draw the plot",
          "    plt.draw()"
        ],
        "result": {
          "result": {
            "pickle": "gAROLg==\n",
            "text": "None\n"
          },
          "output": {
            "output_type": "image",
            "data": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA1UAAAIjCAIAAABkkab5AABtIElEQVR4nO3de1xT9f8H8PfhMm5jAxkIKCAiijfU1LyCJl5T0yQttLybF7xrIt28VWBe019mmqmVZnlJLTPzDioqXtGvikgoJipMZTAHDOH8/jg5xzaQy86ur+ejP9hnZ9t7hzVffD6f8/kwLMsSAAAAAFgNG2MXAAAAAAAGhfwHAAAAYF2Q/wAAAACsC/IfAAAAgHVB/gMAAACwLsh/AAAAANYF+Q8AAADAuiD/AQAAAFgX5D8AAAAA64L8BwBGc/v2bYZhNm3aZPiXZhhm/vz5FR8wefJkQ5VjEo4dO8YwzLFjxwz8uvPnz2cYxsAvCmDlkP8ATNqVK1feeuutgIAAR0fHOnXq9OjRY/Xq1TV/2q1bt65cuVK9JSsra/78+ZcuXar5k6vjIgXH3t6+fv36w4cP/+eff6rxVKdOnZo/f35ubq5+K9TLM3NBlmNjY1OrVq0+ffokJSXpr0az17Vr12bNmhm7CgD4D/IfgOk6depUmzZtLl++PG7cuP/7v/8bO3asjY3NV199VfNn1pn/FixYoPf8x5k6deqPP/64bt26vn37/vLLL23bts3Kyqrqk5w6dWrBggX6yn8FBQUff/yxfp85Kirqxx9/3Lhx48SJE0+fPv3aa69duXKlpoUaUHh4eEFBQXh4uIFf9+OPPy4oKDDwiwJYOTtjFwAA5fr888/FYnFycrKbm5uqMTs723gVVeTp06cuLi467woLC3vrrbeIaNSoUQ0bNpw6dermzZtjY2MNW2AZjo6Oen/OV1555d133+V+DgsL69OnzzfffLNmzRq9v1AFp7ombGxs+DgtL2VnZ2dnh3+MAAwK/X8Apis9Pb1p06bq4Y+IvLy81G/+9NNPr776qrOzs7u7e3h4+N9//82179mzp2/fvr6+vg4ODkFBQYsWLSopKeHu6tq16759++7cucONV9arV+/YsWNt27YlolGjRnGNqjl5Z86c6d27t1gsdnZ27tKly8mTJ1UvzU3bunbt2tChQ93d3Tt37lyZN9WtWzciysjI0HnvkSNHwsLCXFxc3NzcBgwYcP36ddVrffDBB0QUGBjIVXj79m2Nx65atcrW1lbVjbds2TKGYWbOnMndLCkpcXV1jYmJ4W6q5v9V/My7d+9u1qyZg4ND06ZN//rrr8q8QU5YWBgRpaenq1pyc3OnT5/u5+fn4ODQoEGDxYsXl5aWqu599OjRe++9JxKJ3NzcRowYcfnyZfXfwsiRI4VCYXp6+uuvv+7q6jps2DAiKi0tXblyZdOmTR0dHWvXrj1+/PgnT56onvDcuXO9evWSSCROTk6BgYGjR49W3bVt27bWrVu7urqKRKLmzZurepS15/9t3769devWTk5OEonk3XffvXfvnuourqR79+4NHDhQKBR6enrOnj1b9RmrEo35f9zMywrO/L1790aPHl27dm3u3u+//74aLwpg5fAnF4DpCggISEpKunr1ankTpxYsWDB//vyOHTsuXLhQIBCcOXPmyJEjPXv2JKJNmzYJhcKZM2cKhcIjR458+umneXl5S5YsIaKPPvpIJpP9+++/K1asICKhUNi4ceOFCxd++umn77//PhdcOnbsSERHjhzp06dP69at582bZ2Njs3Hjxm7duiUmJr766quqGgYPHhwcHPzFF1+wLFuZN8VFIg8PD+27Dh061KdPn/r168+fP7+goGD16tWdOnW6cOFCvXr1Bg0adPPmzZ9//nnFihUSiYSIPD09NR4eFhZWWlp64sSJfv36EVFiYqKNjU1iYiJ378WLF+VyufbgZgXPfOLEiV27dk2aNMnV1XXVqlWRkZGZmZk6K9fGhUh3d3fupkKh6NKly71798aPH+/v73/q1KnY2Nj79+9zo/ClpaX9+/c/e/bsxIkTQ0JC9uzZM2LECI0nfPbsWa9evTp37rx06VJnZ2ciGj9+/KZNm0aNGjV16tSMjIz/+7//u3jx4smTJ+3t7bOzs3v27Onp6Tl37lw3N7fbt2/v2rWLe56DBw9GRUVFREQsXryYiK5fv37y5Mlp06ZpvwXuydu2bRsXF/fw4cOvvvrq5MmTFy9eVP1BUlJS0qtXr3bt2i1duvTQoUPLli0LCgqaOHFiZc5PxSo48w8fPmzfvj2XET09Pffv3z9mzJi8vLzp06fX/HUBrAgLAKbq77//trW1tbW17dChw5w5cw4cOKBUKlX3pqWl2djYvPnmmyUlJarG0tJS7geFQqH+VOPHj3d2di4sLORu9u3bNyAgQP2A5ORkItq4caP6UwUHB/fq1Uv9OQMDA3v06MHdnDdvHhFFRUVV8BaOHj1KRN9//31OTk5WVta+ffvq1avHMExycjLL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"
          }
        },
        "sanity_checks": null,
        "unit_tests": null,
        "sanity_check_results": {},
        "unit_test_results": {},
        "messages": [],
        "questions": null,
        "build_status": null
      },
      {
        "id": "Step-5",
        "pill": "Compute-R2",
        "label": "Compute R^2 score",
        "geometry": {
          "x": 510.0,
          "y": 360.0,
          "width": 160.0,
          "height": 80.0
        },
        "output_geometry": {
          "x": 720.0,
          "y": 500.0,
          "width": 130.0,
          "height": 60.0
        },
        "function_name": "compute_compute_r2",
        "function_result_var": "compute_r2_result",
        "predecessors": [
          "Step-1",
          "Step-3"
        ],
        "phase": 5,
        "cache": {
          "caches": {
            "3": {
              "in_values": {
                "requirements": [
                  "r_squared is a float.",
                  "r_squared represents the coefficient of determination for the linear regression model calculated using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                  "The regression model is defined by the slope and intercept in compute_slope_result."
                ],
                "algorithm": [
                  "Extract the slope and intercept from compute_slope_result.",
                  "Define a function to compute the predicted vertical values given a triple value using the equation: predicted_vertical = (slope * triple) + intercept.",
                  "Apply the function across the 'triple' column of clean_jumps_result to calculate predicted values for each row, resulting in a new column called 'predicted_vertical'.",
                  "Compute the total sum of squares (SST) as the sum of squared differences between each actual 'vertical' value in clean_jumps_result and the mean of the 'vertical' column.",
                  "Compute the sum of squares of residuals (SSR) as the sum of squared differences between each predicted 'predicted_vertical' value and the actual 'vertical' values in clean_jumps_result.",
                  "Calculate the R^2 score using the formula: r_squared = 1 - (SSR/SST).",
                  "Return r_squared."
                ]
              },
              "out_values": {
                "code": [
                  "import pandas as pd",
                  "from typing import Tuple",
                  "def compute_compute_r2(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> float:",
                  "    # Extract slope and intercept",
                  "    slope, intercept = compute_slope_result",
                  "",
                  "    # Calculate predicted vertical values",
                  "    clean_jumps_result['predicted_vertical'] = clean_jumps_result['triple'].apply(lambda x: slope * x + intercept)",
                  "",
                  "    # Compute total sum of squares (SST)",
                  "    vertical_mean = clean_jumps_result['vertical'].mean()",
                  "    sst = ((clean_jumps_result['vertical'] - vertical_mean) ** 2).sum()",
                  "",
                  "    # Compute sum of squares of residuals (SSR)",
                  "    ssr = ((clean_jumps_result['vertical'] - clean_jumps_result['predicted_vertical']) ** 2).sum()",
                  "",
                  "    # Calculate R^2 score",
                  "    r_squared = 1 - (ssr / sst)",
                  "",
                  "    return r_squared"
                ]
              },
              "valid": true
            }
          }
        },
        "function_parameters": [
          {
            "name": "clean_jumps_result",
            "type": {
              "type": "pd.DataFrame['triple': float, 'vertical': float]"
            }
          },
          {
            "name": "compute_slope_result",
            "type": {
              "type": "Tuple[float, float]"
            }
          }
        ],
        "preconditions": {
          "clean_jumps_result": [
            "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
            "clean_jumps_result contains no missing (NA) values in any column.",
            "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
          ],
          "compute_slope_result": [
            "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
            "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
            "The slope and intercept are both floats."
          ],
          "triple_vertical": [
            "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
          ]
        },
        "requirements": [
          "r_squared is a float.",
          "r_squared represents the coefficient of determination for the linear regression model calculated using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
          "The regression model is defined by the slope and intercept in compute_slope_result."
        ],
        "description": "This computation step calculates the R^2 score (coefficient of determination) for the linear regression model determined by the given slope and intercept. The score provides a measure of how well the independent variable 'triple' predicts the dependent variable 'vertical'. The R^2 score is a value between 0 and 1, where a higher value indicates a better fit of the regression model to the data.",
        "function_return_type": {
          "type": "float"
        },
        "function_computed_value": "The R^2 score of the regression model.",
        "algorithm": [
          "Extract the slope and intercept from compute_slope_result.",
          "Define a function to compute the predicted vertical values given a triple value using the equation: predicted_vertical = (slope * triple) + intercept.",
          "Apply the function across the 'triple' column of clean_jumps_result to calculate predicted values for each row, resulting in a new column called 'predicted_vertical'.",
          "Compute the total sum of squares (SST) as the sum of squared differences between each actual 'vertical' value in clean_jumps_result and the mean of the 'vertical' column.",
          "Compute the sum of squares of residuals (SSR) as the sum of squared differences between each predicted 'predicted_vertical' value and the actual 'vertical' values in clean_jumps_result.",
          "Calculate the R^2 score using the formula: r_squared = 1 - (SSR/SST).",
          "Return r_squared."
        ],
        "code": [
          "import pandas as pd",
          "from typing import Tuple",
          "def compute_compute_r2(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> float:",
          "    # Extract slope and intercept",
          "    slope, intercept = compute_slope_result",
          "",
          "    # Calculate predicted vertical values",
          "    clean_jumps_result['predicted_vertical'] = clean_jumps_result['triple'].apply(lambda x: slope * x + intercept)",
          "",
          "    # Compute total sum of squares (SST)",
          "    vertical_mean = clean_jumps_result['vertical'].mean()",
          "    sst = ((clean_jumps_result['vertical'] - vertical_mean) ** 2).sum()",
          "",
          "    # Compute sum of squares of residuals (SSR)",
          "    ssr = ((clean_jumps_result['vertical'] - clean_jumps_result['predicted_vertical']) ** 2).sum()",
          "",
          "    # Calculate R^2 score",
          "    r_squared = 1 - (ssr / sst)",
          "",
          "    return r_squared"
        ],
        "result": {
          "result": {
            "pickle": "gASVagAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCFohBjIzRuY/lIaUUpQu\n",
            "text": "0.6960693337469295\n"
          },
          "output": {
            "output_type": "text",
            "data": "0.6960693337469295\n"
          }
        },
        "sanity_checks": null,
        "unit_tests": null,
        "sanity_check_results": {},
        "unit_test_results": {},
        "messages": [],
        "questions": null,
        "build_status": null
      },
      {
        "id": "Step-6",
        "pill": "Plot-Residuals",
        "label": "Plot Residuals",
        "geometry": {
          "x": 440.0,
          "y": 500.0,
          "width": 160.0,
          "height": 80.0
        },
        "output_geometry": {
          "x": 550.0,
          "y": 670.0,
          "width": 400.0,
          "height": 300.0
        },
        "function_name": "compute_plot_residuals",
        "function_result_var": "plot_residuals_result",
        "predecessors": [
          "Step-1",
          "Step-3"
        ],
        "phase": 5,
        "cache": {
          "caches": {
            "3": {
              "in_values": {
                "requirements": [
                  "Residuals are computed as the difference between the actual values in the 'vertical' column and the predicted values based on the regression line from compute_slope_result.",
                  "A scatter plot of the residuals versus the 'triple' values from clean_jumps_result is generated.",
                  "The plot includes labels for the axes with 'Triple' on the x-axis and 'Residuals' on the y-axis."
                ],
                "algorithm": [
                  "Extract the slope and intercept from compute_slope_result.",
                  "Compute predicted vertical values using the formula: predicted_vertical = slope * triple + intercept for each row in clean_jumps_result.",
                  "Compute residuals as the difference between actual vertical values and predicted vertical values for each row.",
                  "Initialize a scatter plot.",
                  "Plot triple values on the x-axis and calculated residuals on the y-axis.",
                  "Label the x-axis as 'Triple' and the y-axis as 'Residuals'.",
                  "Display the plot."
                ]
              },
              "out_values": {
                "code": [
                  "import matplotlib.pyplot as plt",
                  "import pandas as pd",
                  "from typing import Tuple",
                  "def compute_plot_residuals(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
                  "    slope, intercept = compute_slope_result",
                  "    # Calculate predicted vertical values",
                  "    predicted_vertical = slope * clean_jumps_result['triple'] + intercept",
                  "    # Calculate residuals",
                  "    residuals = clean_jumps_result['vertical'] - predicted_vertical",
                  "    # Create the scatter plot",
                  "    plt.figure()",
                  "    plt.scatter(clean_jumps_result['triple'], residuals)",
                  "    plt.xlabel('Triple')",
                  "    plt.ylabel('Residuals')",
                  "    plt.draw()",
                  "    return None"
                ]
              },
              "valid": true
            }
          }
        },
        "function_parameters": [
          {
            "name": "clean_jumps_result",
            "type": {
              "type": "pd.DataFrame['triple': float, 'vertical': float]"
            }
          },
          {
            "name": "compute_slope_result",
            "type": {
              "type": "Tuple[float, float]"
            }
          }
        ],
        "preconditions": {
          "clean_jumps_result": [
            "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
            "clean_jumps_result contains no missing (NA) values in any column.",
            "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
          ],
          "compute_slope_result": [
            "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
            "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
            "The slope and intercept are both floats."
          ],
          "triple_vertical": [
            "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
          ]
        },
        "requirements": [
          "Residuals are computed as the difference between the actual values in the 'vertical' column and the predicted values based on the regression line from compute_slope_result.",
          "A scatter plot of the residuals versus the 'triple' values from clean_jumps_result is generated.",
          "The plot includes labels for the axes with 'Triple' on the x-axis and 'Residuals' on the y-axis."
        ],
        "description": "This step involves calculating the residuals based on the linear regression model obtained from the previous computation. The residuals are the differences between the actual 'vertical' values and the predicted values obtained using the slope and intercept from compute_slope_result. These residuals are then plotted in a scatter plot with 'triple' values on the x-axis, helping visualize any patterns or randomness in the residuals.",
        "function_return_type": {
          "type": "None"
        },
        "function_computed_value": "None",
        "algorithm": [
          "Extract the slope and intercept from compute_slope_result.",
          "Compute predicted vertical values using the formula: predicted_vertical = slope * triple + intercept for each row in clean_jumps_result.",
          "Compute residuals as the difference between actual vertical values and predicted vertical values for each row.",
          "Initialize a scatter plot.",
          "Plot triple values on the x-axis and calculated residuals on the y-axis.",
          "Label the x-axis as 'Triple' and the y-axis as 'Residuals'.",
          "Display the plot."
        ],
        "code": [
          "import matplotlib.pyplot as plt",
          "import pandas as pd",
          "from typing import Tuple",
          "def compute_plot_residuals(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
          "    slope, intercept = compute_slope_result",
          "    # Calculate predicted vertical values",
          "    predicted_vertical = slope * clean_jumps_result['triple'] + intercept",
          "    # Calculate residuals",
          "    residuals = clean_jumps_result['vertical'] - predicted_vertical",
          "    # Create the scatter plot",
          "    plt.figure()",
          "    plt.scatter(clean_jumps_result['triple'], residuals)",
          "    plt.xlabel('Triple')",
          "    plt.ylabel('Residuals')",
          "    plt.draw()",
          "    return None"
        ],
        "result": {
          "result": {
            "pickle": "gAROLg==\n",
            "text": "None\n"
          },
          "output": {
            "output_type": "image",
            "data": "data:image/png;base64,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"
          }
        },
        "sanity_checks": null,
        "unit_tests": null,
        "sanity_check_results": {},
        "unit_test_results": {},
        "messages": [],
        "questions": null,
        "build_status": null
      },
      {
        "id": "Step-7",
        "pill": "Bootstrap-Regression",
        "label": "Bootstrap regression line for resamples of data",
        "geometry": {
          "x": 90.0,
          "y": 290.0,
          "width": 160.0,
          "height": 80.0
        },
        "output_geometry": {
          "x": 350.0,
          "y": 290.0,
          "width": 400.0,
          "height": 300.0
        },
        "function_name": "compute_bootstrap_regression",
        "function_result_var": "bootstrap_regression_result",
        "predecessors": [
          "Step-1"
        ],
        "phase": 5,
        "cache": {
          "caches": {
            "3": {
              "in_values": {
                "requirements": [
                  "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
                  "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
                  "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
                  "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
                ],
                "algorithm": [
                  "Define a function `bootstrap_regression` that takes `clean_jumps_result` as input.",
                  "Initialize an empty list `bootstrap_results` to store slope and intercept of each bootstrap sample.",
                  "Set the number of bootstrap samples, `n_bootstrap_samples`, to at least 1000 to ensure reliable estimates.",
                  "For each in the range from 0 to `n_bootstrap_samples`:",
                  ".1. Create a bootstrap sample by drawing with replacement from `clean_jumps_result`. This creates two arrays—`x_sample` from 'triple' and `y_sample` from 'vertical'.",
                  ".2. Perform linear regression on the bootstrap sample `x_sample`, `y_sample`. Use a suitable linear regression method (e.g., using numpy's `polyfit`) to compute the slope and intercept of the regression.",
                  ".3. Store the computed slope and intercept as a tuple in the `bootstrap_results` list.",
                  "After completing all bootstrap samples, convert the `bootstrap_results` list into a pandas DataFrame with column names 'slope' and 'intercept'.",
                  "Return the DataFrame containing the slopes and intercepts for all bootstrap samples."
                ]
              },
              "out_values": {
                "code": [
                  "import numpy as np",
                  "import pandas as pd",
                  "",
                  "def compute_bootstrap_regression(clean_jumps_result: pd.DataFrame) -> pd.DataFrame:",
                  "    bootstrap_results = []",
                  "    n_bootstrap_samples = 1000 # Number of resamples for bootstrap analysis",
                  "    ",
                  "    for _ in range(n_bootstrap_samples):",
                  "        # Create a bootstrap sample by sampling with replacement",
                  "        bootstrap_sample = clean_jumps_result.sample(n=len(clean_jumps_result), replace=True)",
                  "        x_sample = bootstrap_sample['triple']",
                  "        y_sample = bootstrap_sample['vertical']",
                  "        ",
                  "        # Calculate the slope and intercept using numpy polyfit for linear regression",
                  "        slope, intercept = np.polyfit(x_sample, y_sample, 1)",
                  "        ",
                  "        # Store results",
                  "        bootstrap_results.append((slope, intercept))",
                  "    ",
                  "    # Convert the bootstrap results to a DataFrame",
                  "    bootstrap_regression_result = pd.DataFrame(bootstrap_results, columns=['slope', 'intercept'])",
                  "    ",
                  "    return bootstrap_regression_result"
                ]
              },
              "valid": true
            }
          }
        },
        "function_parameters": [
          {
            "name": "clean_jumps_result",
            "type": {
              "type": "pd.DataFrame['triple': float, 'vertical': float]"
            }
          }
        ],
        "preconditions": {
          "clean_jumps_result": [
            "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
            "clean_jumps_result contains no missing (NA) values in any column.",
            "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
          ],
          "triple_vertical": [
            "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
          ]
        },
        "requirements": [
          "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
          "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
          "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
          "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
        ],
        "description": "This computation step performs a bootstrap analysis of the regression line based on the 'clean_jumps_result' DataFrame. By taking many resamples (with replacement), the slope and intercept of a linear regression are calculated for each resample. This approach allows for estimation of the variability in the regression line's parameters.",
        "function_return_type": {
          "type": "pd.DataFrame['slope': float, 'intercept': float]"
        },
        "function_computed_value": "A DataFrame containing calculated slope and intercept values for each bootstrap resample of the data.",
        "algorithm": [
          "Define a function `bootstrap_regression` that takes `clean_jumps_result` as input.",
          "Initialize an empty list `bootstrap_results` to store slope and intercept of each bootstrap sample.",
          "Set the number of bootstrap samples, `n_bootstrap_samples`, to at least 1000 to ensure reliable estimates.",
          "For each in the range from 0 to `n_bootstrap_samples`:",
          ".1. Create a bootstrap sample by drawing with replacement from `clean_jumps_result`. This creates two arrays—`x_sample` from 'triple' and `y_sample` from 'vertical'.",
          ".2. Perform linear regression on the bootstrap sample `x_sample`, `y_sample`. Use a suitable linear regression method (e.g., using numpy's `polyfit`) to compute the slope and intercept of the regression.",
          ".3. Store the computed slope and intercept as a tuple in the `bootstrap_results` list.",
          "After completing all bootstrap samples, convert the `bootstrap_results` list into a pandas DataFrame with column names 'slope' and 'intercept'.",
          "Return the DataFrame containing the slopes and intercepts for all bootstrap samples."
        ],
        "code": [
          "import numpy as np",
          "import pandas as pd",
          "",
          "def compute_bootstrap_regression(clean_jumps_result: pd.DataFrame) -> pd.DataFrame:",
          "    bootstrap_results = []",
          "    n_bootstrap_samples = 1000 # Number of resamples for bootstrap analysis",
          "    ",
          "    for _ in range(n_bootstrap_samples):",
          "        # Create a bootstrap sample by sampling with replacement",
          "        bootstrap_sample = clean_jumps_result.sample(n=len(clean_jumps_result), replace=True)",
          "        x_sample = bootstrap_sample['triple']",
          "        y_sample = bootstrap_sample['vertical']",
          "        ",
          "        # Calculate the slope and intercept using numpy polyfit for linear regression",
          "        slope, intercept = np.polyfit(x_sample, y_sample, 1)",
          "        ",
          "        # Store results",
          "        bootstrap_results.append((slope, intercept))",
          "    ",
          "    # Convert the bootstrap results to a DataFrame",
          "    bootstrap_regression_result = pd.DataFrame(bootstrap_results, columns=['slope', 'intercept'])",
          "    ",
          "    return bootstrap_regression_result"
        ],
        "result": {
          "result": {
            "pickle": "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\n",
            "text": "        slope  intercept\n0    0.079948   4.990699\n1    0.089357   0.376534\n2    0.099633  -3.897056\n3    0.095368  -1.784043\n4    0.101629  -6.612154\n..        ...        ...\n995  0.096266  -3.894805\n996  0.101951  -7.306179\n997  0.086624   2.236808\n998  0.106705  -8.635379\n999  0.090075  -0.627934\n\n[1000 rows x 2 columns]\n"
          },
          "output": null
        },
        "sanity_checks": null,
        "unit_tests": null,
        "sanity_check_results": {},
        "unit_test_results": {},
        "messages": [],
        "questions": null,
        "build_status": null
      },
      {
        "id": "Step-8",
        "pill": "Show-Confidence",
        "label": "Show confidence interval for prediction based on the mean jump in the data set",
        "geometry": {
          "x": 90.0,
          "y": 480.0,
          "width": 160.0,
          "height": 80.0
        },
        "output_geometry": {
          "x": 90.0,
          "y": 630.0,
          "width": 400.0,
          "height": 50.0
        },
        "function_name": "compute_show_confidence",
        "function_result_var": "show_confidence_result",
        "predecessors": [
          "Step-7",
          "Step-1"
        ],
        "phase": 5,
        "cache": {
          "caches": {
            "3": {
              "in_values": {
                "requirements": [
                  "confidence_interval is a Tuple[float, float].",
                  "confidence_interval represents the 95% confidence interval for the predicted 'vertical' value of the mean 'triple' jump in the clean_jumps_result dataset."
                ],
                "algorithm": [
                  "Calculate the mean value of 'triple' from the clean_jumps_result dataset. This will be the mean_triple.",
                  "Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
                  "Iterate over each row in the bootstrap_regression_result DataFrame:",
                  "  a) For each row, extract the 'slope' and 'intercept' values.",
                  "  b) Use these to calculate the predicted 'vertical' value using the formula:\n     predicted_vertical = (slope * mean_triple) + intercept.",
                  "  c) Append this predicted_vertical to the list of predicted verticals.",
                  "After completing the loop, convert the list of predicted verticals to a NumPy array for easier manipulation.",
                  "Calculate the 95% confidence interval from these predicted verticals using NumPy:\n  a) Use numpy.percentile() to find the 2.5th percentile and 97.5th percentile.\n  b) The result is the lower and upper bounds of the 95% confidence interval.",
                  "Create a tuple called confidence_interval containing the lower and upper bounds.",
                  "Return confidence_interval."
                ]
              },
              "out_values": {
                "code": [
                  "import numpy as np",
                  "import pandas as pd",
                  "from typing import Tuple",
                  "",
                  "def compute_show_confidence(bootstrap_regression_result: pd.DataFrame, clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
                  "    # Step 1: Calculate the mean value of 'triple' from the clean_jumps_result dataset.",
                  "    mean_triple = clean_jumps_result['triple'].mean()",
                  "",
                  "    # Step 2: Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
                  "    predicted_verticals = []",
                  "",
                  "    # Step 3: Iterate over each row in the bootstrap_regression_result DataFrame.",
                  "    for _, row in bootstrap_regression_result.iterrows():",
                  "        slope, intercept = row['slope'], row['intercept']",
                  "        # Step 3b: Calculate the predicted 'vertical' using the formula.",
                  "        predicted_vertical = (slope * mean_triple) + intercept",
                  "        # Step 3c: Append this to the list.",
                  "        predicted_verticals.append(predicted_vertical)",
                  "",
                  "    # Step 4: Convert the list to a NumPy array for further manipulation.",
                  "    predicted_verticals = np.array(predicted_verticals)",
                  "",
                  "    # Step 5: Calculate the 95% confidence interval from the predicted verticals.",
                  "    lower_bound = np.percentile(predicted_verticals, 2.5)",
                  "    upper_bound = np.percentile(predicted_verticals, 97.5)",
                  "    # Step 6: Create a tuple of the confidence interval.",
                  "    confidence_interval = (lower_bound, upper_bound)",
                  "",
                  "    # Step 7: Return confidence_interval.",
                  "    return confidence_interval"
                ]
              },
              "valid": true
            }
          }
        },
        "function_parameters": [
          {
            "name": "bootstrap_regression_result",
            "type": {
              "type": "pd.DataFrame['slope': float, 'intercept': float]"
            }
          },
          {
            "name": "clean_jumps_result",
            "type": {
              "type": "pd.DataFrame['triple': float, 'vertical': float]"
            }
          }
        ],
        "preconditions": {
          "bootstrap_regression_result": [
            "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
            "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
            "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
            "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
          ],
          "clean_jumps_result": [
            "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
            "clean_jumps_result contains no missing (NA) values in any column.",
            "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
          ],
          "triple_vertical": [
            "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
          ]
        },
        "requirements": [
          "confidence_interval is a Tuple[float, float].",
          "confidence_interval represents the 95% confidence interval for the predicted 'vertical' value of the mean 'triple' jump in the clean_jumps_result dataset."
        ],
        "description": "This computation calculates the 95% confidence interval for the predicted 'vertical' value based on the mean of the 'triple' jumps in the clean_jumps_result data. It uses the bootstrap regression results to estimate variability in slope and intercept values. The mean 'triple' value is used to predict 'vertical', and the confidence interval reflects the uncertainty in this prediction.",
        "function_return_type": {
          "type": "Tuple[float, float]"
        },
        "function_computed_value": "The confidence interval for the predicted 'vertical' at the mean 'triple' value.",
        "algorithm": [
          "Calculate the mean value of 'triple' from the clean_jumps_result dataset. This will be the mean_triple.",
          "Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
          "Iterate over each row in the bootstrap_regression_result DataFrame:",
          "  a) For each row, extract the 'slope' and 'intercept' values.",
          "  b) Use these to calculate the predicted 'vertical' value using the formula:\n     predicted_vertical = (slope * mean_triple) + intercept.",
          "  c) Append this predicted_vertical to the list of predicted verticals.",
          "After completing the loop, convert the list of predicted verticals to a NumPy array for easier manipulation.",
          "Calculate the 95% confidence interval from these predicted verticals using NumPy:\n  a) Use numpy.percentile() to find the 2.5th percentile and 97.5th percentile.\n  b) The result is the lower and upper bounds of the 95% confidence interval.",
          "Create a tuple called confidence_interval containing the lower and upper bounds.",
          "Return confidence_interval."
        ],
        "code": [
          "import numpy as np",
          "import pandas as pd",
          "from typing import Tuple",
          "",
          "def compute_show_confidence(bootstrap_regression_result: pd.DataFrame, clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
          "    # Step 1: Calculate the mean value of 'triple' from the clean_jumps_result dataset.",
          "    mean_triple = clean_jumps_result['triple'].mean()",
          "",
          "    # Step 2: Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
          "    predicted_verticals = []",
          "",
          "    # Step 3: Iterate over each row in the bootstrap_regression_result DataFrame.",
          "    for _, row in bootstrap_regression_result.iterrows():",
          "        slope, intercept = row['slope'], row['intercept']",
          "        # Step 3b: Calculate the predicted 'vertical' using the formula.",
          "        predicted_vertical = (slope * mean_triple) + intercept",
          "        # Step 3c: Append this to the list.",
          "        predicted_verticals.append(predicted_vertical)",
          "",
          "    # Step 4: Convert the list to a NumPy array for further manipulation.",
          "    predicted_verticals = np.array(predicted_verticals)",
          "",
          "    # Step 5: Calculate the 95% confidence interval from the predicted verticals.",
          "    lower_bound = np.percentile(predicted_verticals, 2.5)",
          "    upper_bound = np.percentile(predicted_verticals, 97.5)",
          "    # Step 6: Create a tuple of the confidence interval.",
          "    confidence_interval = (lower_bound, upper_bound)",
          "",
          "    # Step 7: Return confidence_interval.",
          "    return confidence_interval"
        ],
        "result": {
          "result": {
            "pickle": "gASVfwAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCGva6QI6uEdAlIaUUpRoAmgIQwi83o9oOZtJQJSGlFKUhpQu\n",
            "text": "(np.float64(47.43927036684621), np.float64(51.212689466713954))\n"
          },
          "output": {
            "output_type": "text",
            "data": "(np.float64(47.43927036684621), np.float64(51.212689466713954))\n"
          }
        },
        "sanity_checks": null,
        "unit_tests": null,
        "sanity_check_results": {},
        "unit_test_results": {},
        "messages": [],
        "questions": null,
        "build_status": null
      }
    ],
    "edges": [
      {
        "id": "2",
        "src": "Step-1",
        "dst": "Step-2"
      },
      {
        "id": "3",
        "src": "Step-1",
        "dst": "Step-3"
      },
      {
        "id": "4",
        "src": "Step-3",
        "dst": "Step-4"
      },
      {
        "id": "5",
        "src": "Step-3",
        "dst": "Step-5"
      },
      {
        "id": "6",
        "src": "Step-3",
        "dst": "Step-6"
      },
      {
        "id": "7",
        "src": "Step-1",
        "dst": "Step-7"
      },
      {
        "id": "8",
        "src": "Step-7",
        "dst": "Step-8"
      }
    ],
    "image": null
  },
  "tables": {
    "tables": {
      "triple_vertical": {
        "table_name": "triple_vertical",
        "contents": "triple,vertical\n383.00,33.00\n781.00,71.10\n561.62,62.25\n624.52,61.33\n446.24,40.19\n515.30,38.96\n449.22,39.69\n560.91,46.51\n519.12,37.68\n595.38,53.48\n686.42,65.85\n601.67,57.60\n553.23,37.66\n529.22,41.70\n561.16,48.98\n465.88,34.14\n497.30,56.12\n592.71,53.91\n679.95,67.60\n531.92,51.29\n562.83,53.82\n447.53,42.05\n683.56,48.55\n630.60,66.76\n644.69,59.38\n479.34,43.68\n745.95,66.14\n667.12,61.50\n411.63,37.65\n483.32,37.59\n638.67,60.10\n477.62,42.57\n467.60,49.97\n400.31,48.42\n586.62,52.41\n513.26,42.27\n464.71,35.76\n403.22,34.96\n475.63,41.84\n568.04,47.53\n",
        "md5": "c7cc20224b239b2bb69a9501f2c31440"
      }
    }
  },
  "versions": [
    {
      "file_name": "jumps.json",
      "dfg": {
        "description": "",
        "nodes": [
          {
            "id": "Step-1",
            "pill": "Clean-Jumps",
            "label": "Clean Jumps data",
            "geometry": {
              "x": 90.0,
              "y": 70.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 350.0,
              "y": 70.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_clean_jumps",
            "function_result_var": "clean_jumps_result",
            "predecessors": [],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                      "clean_jumps_result contains no missing (NA) values in any column.",
                      "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
                    ],
                    "algorithm": [
                      "Obtain the raw data by calling the global function `triple_vertical_table()`, which returns a DataFrame containing columns 'triple' and 'vertical'.",
                      "Assign the DataFrame obtained from `triple_vertical_table()` to a variable, say `jumps_data`.",
                      "Identify any missing (NA) values in `jumps_data`.",
                      "Remove any rows that contain missing (NA) values in `jumps_data`. This can be done by using available pandas functions to drop missing values.",
                      "Assign the cleaned DataFrame to `clean_jumps_result`.",
                      "Return `clean_jumps_result` as the final output, ensuring it contains no missing values."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "def compute_clean_jumps() -> pd.DataFrame:",
                      "    # Obtain the raw data from the global function",
                      "    jumps_data = triple_vertical_table()",
                      "    ",
                      "    # Remove any rows with missing values",
                      "    cleaned_data = jumps_data.dropna()",
                      "    ",
                      "    return cleaned_data"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [],
            "preconditions": {
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
              "clean_jumps_result contains no missing (NA) values in any column.",
              "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
            ],
            "description": "The 'Clean Jumps' step involves processing the data obtained from `triple_vertical_table()` to ensure it is suitable for further analysis. This function removes any missing values and ensures the data integrity and completeness are maintained, resulting in a cleaned DataFrame. The cleaning process ensures that subsequent computations are working with the most relevant and accurate data possible.",
            "function_return_type": {
              "type": "pd.DataFrame['triple': float, 'vertical': float]"
            },
            "function_computed_value": "A cleaned DataFrame of jump data with no missing values, containing 'triple' and 'vertical' columns.",
            "algorithm": [
              "Obtain the raw data by calling the global function `triple_vertical_table()`, which returns a DataFrame containing columns 'triple' and 'vertical'.",
              "Assign the DataFrame obtained from `triple_vertical_table()` to a variable, say `jumps_data`.",
              "Identify any missing (NA) values in `jumps_data`.",
              "Remove any rows that contain missing (NA) values in `jumps_data`. This can be done by using available pandas functions to drop missing values.",
              "Assign the cleaned DataFrame to `clean_jumps_result`.",
              "Return `clean_jumps_result` as the final output, ensuring it contains no missing values."
            ],
            "code": [
              "import pandas as pd",
              "def compute_clean_jumps() -> pd.DataFrame:",
              "    # Obtain the raw data from the global function",
              "    jumps_data = triple_vertical_table()",
              "    ",
              "    # Remove any rows with missing values",
              "    cleaned_data = jumps_data.dropna()",
              "    ",
              "    return cleaned_data"
            ],
            "result": {
              "result": {
                "pickle": "gASVFwUAAAAAAACMEXBhbmRhcy5jb3JlLmZyYW1llIwJRGF0YUZyYW1llJOUKYGUfZQojARfbWdylIwecGFuZGFzLmNvcmUuaW50ZXJuYWxzLm1hbmFnZXJzlIwMQmxvY2tNYW5hZ2VylJOUjBZwYW5kYXMuX2xpYnMuaW50ZXJuYWxzlIwPX3VucGlja2xlX2Jsb2NrlJOUjBZudW1weS5fY29yZS5tdWx0aWFycmF5lIwMX3JlY29uc3RydWN0lJOUjAVudW1weZSMB25kYXJyYXmUk5RLAIWUQwFilIeUUpQoSwFLAksohpRoD4wFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGKJQoACAAAAAAAAAPB3QAAAAAAAaIhAKVyPwvWMgUBcj8L1KISDQKRwPQrX43tAZmZmZmYagEDsUbgehRN8QOF6FK5Hh4FAKVyPwvU4gEDXo3A9CpuCQI/C9Shcc4VAj8L1KFzNgkCkcD0K10mBQPYoXI/CiYBA4XoUrkeJgUCuR+F6FB59QM3MzMzMFH9ASOF6FK6FgkCamZmZmT+FQI/C9Shcn4BAcT0K16OWgUAUrkfhevh7QBSuR+F6XIVAzczMzMy0g0DsUbgehSWEQD0K16Nw9X1AmpmZmZlPh0ApXI/C9diEQK5H4XoUunlAhetRuB41fkCPwvUoXPWDQFK4HoXr2X1AmpmZmZk5fUApXI/C9QR5QClcj8L1VIJArkfhehQKgECPwvUoXAt9QOxRuB6FM3lArkfhehS6fUC4HoXrUcCBQAAAAAAAgEBAZmZmZmbGUUAAAAAAACBPQArXo3A9qk5AuB6F61EYREB7FK5H4XpDQLgehetR2ENA4XoUrkdBR0DXo3A9CtdCQD0K16NwvUpAZmZmZmZ2UEDNzMzMzMxMQBSuR+F61EJAmpmZmZnZREA9CtejcH1IQFK4HoXrEUFAj8L1KFwPTEAUrkfhevRKQGZmZmZm5lBAhetRuB6lSUApXI/C9ehKQGZmZmZmBkVAZmZmZmZGSEBxPQrXo7BQQHE9CtejsE1A16NwPQrXRUApXI/C9YhQQAAAAAAAwE5AMzMzMzPTQkDsUbgehctCQM3MzMzMDE5AKVyPwvVIRUBcj8L1KPxIQPYoXI/CNUhAFK5H4Xo0SkDD9ShcjyJFQOF6FK5H4UFAexSuR+F6QUDsUbgehetEQKRwPQrXw0dAlHSUYowIYnVpbHRpbnOUjAVzbGljZZSTlEsASwJLAYeUUpRLAoeUUpSFlF2UKIwYcGFuZGFzLmNvcmUuaW5kZXhlcy5iYXNllIwKX25ld19JbmRleJSTlGgpjAVJbmRleJSTlH2UKIwEZGF0YZRoDmgRSwCFlGgTh5RSlChLAUsChZRoGIwCTziUiYiHlFKUKEsDjAF8lE5OTkr/////Sv////9LP3SUYoldlCiMBnRyaXBsZZSMCHZlcnRpY2FslGV0lGKMBG5hbWWUTnWGlFKUaCuMGXBhbmRhcy5jb3JlLmluZGV4ZXMucmFuZ2WUjApSYW5nZUluZGV4lJOUfZQoaD1OjAVzdGFydJRLAIwEc3RvcJRLKIwEc3RlcJRLAXWGlFKUZYaUUpSMBF90eXCUjAlkYXRhZnJhbWWUjAlfbWV0YWRhdGGUXZSMBWF0dHJzlH2UjAZfZmxhZ3OUfZSMF2FsbG93c19kdXBsaWNhdGVfbGFiZWxzlIhzdWIu\n",
                "text": "    triple  vertical\n0   383.00     33.00\n1   781.00     71.10\n2   561.62     62.25\n3   624.52     61.33\n4   446.24     40.19\n5   515.30     38.96\n6   449.22     39.69\n7   560.91     46.51\n8   519.12     37.68\n9   595.38     53.48\n10  686.42     65.85\n11  601.67     57.60\n12  553.23     37.66\n13  529.22     41.70\n14  561.16     48.98\n15  465.88     34.14\n16  497.30     56.12\n17  592.71     53.91\n18  679.95     67.60\n19  531.92     51.29\n20  562.83     53.82\n21  447.53     42.05\n22  683.56     48.55\n23  630.60     66.76\n24  644.69     59.38\n25  479.34     43.68\n26  745.95     66.14\n27  667.12     61.50\n28  411.63     37.65\n29  483.32     37.59\n30  638.67     60.10\n31  477.62     42.57\n32  467.60     49.97\n33  400.31     48.42\n34  586.62     52.41\n35  513.26     42.27\n36  464.71     35.76\n37  403.22     34.96\n38  475.63     41.84\n39  568.04     47.53\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-2",
            "pill": "Computer-Pearson",
            "label": "Computer Pearson Correlation",
            "geometry": {
              "x": 350.0,
              "y": 70.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 610.0,
              "y": 70.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_computer_pearson",
            "function_result_var": "computer_pearson_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "pearson_correlation is a float.",
                      "pearson_correlation represents the Pearson correlation coefficient between 'triple' and 'vertical' columns of clean_jumps_result."
                    ],
                    "algorithm": [
                      "Define a function `compute_pearson_correlation(clean_jumps_result)`.",
                      "Within the function, start by verifying that the input `clean_jumps_result` is a pandas DataFrame with the columns `triple` and `vertical`.",
                      "Ensure that there are no missing (NA) values within `clean_jumps_result`. If there are any, raise an error or warning, as the input precondition is not met.",
                      "Use the pandas DataFrame method `corr()` on `clean_jumps_result` to compute the Pearson correlation matrix.",
                      "Extract the correlation value between the `triple` and `vertical` columns from the matrix. This can often be accessed via `corr().loc['triple', 'vertical']`.",
                      "Assign this correlation value to the variable `pearson_correlation`.",
                      "Return the `pearson_correlation`."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "def compute_computer_pearson(clean_jumps_result: pd.DataFrame) -> float:",
                      "    # Verify the input is a valid DataFrame with correct columns",
                      "    if not isinstance(clean_jumps_result, pd.DataFrame) or 'triple' not in clean_jumps_result.columns or 'vertical' not in clean_jumps_result.columns:",
                      "        raise ValueError(\"Input must be a DataFrame with 'triple' and 'vertical' columns.\")",
                      "    ",
                      "    # Calculate the Pearson correlation",
                      "    correlation_matrix = clean_jumps_result.corr(method='pearson')",
                      "    pearson_correlation = correlation_matrix.loc['triple', 'vertical']",
                      "    ",
                      "    return pearson_correlation"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "pearson_correlation is a float.",
              "pearson_correlation represents the Pearson correlation coefficient between 'triple' and 'vertical' columns of clean_jumps_result."
            ],
            "description": "This computation calculates the Pearson correlation coefficient between the 'triple' and 'vertical' columns of the 'clean_jumps_result' DataFrame. Pearson correlation measures the linear correlation between two sets of data, providing a value between -1 and 1. This step helps in understanding the strength and direction of the linear relationship between the two types of jumps.",
            "function_return_type": {
              "type": "float"
            },
            "function_computed_value": "The computed value is the Pearson correlation coefficient as a float.",
            "algorithm": [
              "Define a function `compute_pearson_correlation(clean_jumps_result)`.",
              "Within the function, start by verifying that the input `clean_jumps_result` is a pandas DataFrame with the columns `triple` and `vertical`.",
              "Ensure that there are no missing (NA) values within `clean_jumps_result`. If there are any, raise an error or warning, as the input precondition is not met.",
              "Use the pandas DataFrame method `corr()` on `clean_jumps_result` to compute the Pearson correlation matrix.",
              "Extract the correlation value between the `triple` and `vertical` columns from the matrix. This can often be accessed via `corr().loc['triple', 'vertical']`.",
              "Assign this correlation value to the variable `pearson_correlation`.",
              "Return the `pearson_correlation`."
            ],
            "code": [
              "import pandas as pd",
              "def compute_computer_pearson(clean_jumps_result: pd.DataFrame) -> float:",
              "    # Verify the input is a valid DataFrame with correct columns",
              "    if not isinstance(clean_jumps_result, pd.DataFrame) or 'triple' not in clean_jumps_result.columns or 'vertical' not in clean_jumps_result.columns:",
              "        raise ValueError(\"Input must be a DataFrame with 'triple' and 'vertical' columns.\")",
              "    ",
              "    # Calculate the Pearson correlation",
              "    correlation_matrix = clean_jumps_result.corr(method='pearson')",
              "    pearson_correlation = correlation_matrix.loc['triple', 'vertical']",
              "    ",
              "    return pearson_correlation"
            ],
            "result": {
              "result": {
                "pickle": "gASVagAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCGVQVA6msuo/lIaUUpQu\n",
                "text": "0.8343076972837592\n"
              },
              "output": {
                "output_type": "text",
                "data": "0.8343076972837592\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-3",
            "pill": "Compute-Slope",
            "label": "Compute slope and intercept of regression line",
            "geometry": {
              "x": 340.0,
              "y": 200.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 600.0,
              "y": 200.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_compute_slope",
            "function_result_var": "compute_slope_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                      "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                      "The slope and intercept are both floats."
                    ],
                    "algorithm": [
                      "Initialize a function to compute the slope and intercept of a regression line using a DataFrame input, clean_jumps_result, with 'triple' as the independent variable and 'vertical' as the dependent variable.",
                      "Access the 'triple' column from clean_jumps_result and set it as the independent variable X.",
                      "Access the 'vertical' column from clean_jumps_result and set it as the dependent variable Y.",
                      "Import the LinearRegression class from the sklearn.linear_model module.",
                      "Create an instance of the LinearRegression class.",
                      "Reshape X into a 2D array compatible with sklearn's requirements.",
                      "Fit the linear regression model to the data by passing X and Y into the fit method of the LinearRegression instance.",
                      "Retrieve the coefficient property of the fitted linear regression model, which represents the slope of the regression line.",
                      "Retrieve the intercept property of the fitted linear regression model, which represents the intercept of the regression line.",
                      "Return a tuple containing the computed slope and intercept as floats."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "from typing import Tuple",
                      "import pandas as pd",
                      "from sklearn.linear_model import LinearRegression",
                      "def compute_compute_slope(clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
                      "    X = clean_jumps_result[['triple']].values  # Reshape to 2D array",
                      "    Y = clean_jumps_result['vertical'].values",
                      "    model = LinearRegression()",
                      "    model.fit(X, Y)",
                      "    slope = float(model.coef_[0])  # Get the slope (coefficient) and convert to float",
                      "    intercept = float(model.intercept_)  # Get the intercept and convert to float",
                      "    return (slope, intercept)"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
              "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
              "The slope and intercept are both floats."
            ],
            "description": "This computation step calculates the slope and intercept of a linear regression line that models the relationship between the 'triple' and 'vertical' columns in the clean_jumps_result DataFrame. It uses simple linear regression methods to determine how changes in 'triple' values predict changes in 'vertical' values. The slope represents the rate of change in 'vertical' for a unit change in 'triple', and the intercept represents the expected value of 'vertical' when 'triple' is zero.",
            "function_return_type": {
              "type": "Tuple[float, float]"
            },
            "function_computed_value": "A tuple containing the float values for the slope and intercept of the regression line.",
            "algorithm": [
              "Initialize a function to compute the slope and intercept of a regression line using a DataFrame input, clean_jumps_result, with 'triple' as the independent variable and 'vertical' as the dependent variable.",
              "Access the 'triple' column from clean_jumps_result and set it as the independent variable X.",
              "Access the 'vertical' column from clean_jumps_result and set it as the dependent variable Y.",
              "Import the LinearRegression class from the sklearn.linear_model module.",
              "Create an instance of the LinearRegression class.",
              "Reshape X into a 2D array compatible with sklearn's requirements.",
              "Fit the linear regression model to the data by passing X and Y into the fit method of the LinearRegression instance.",
              "Retrieve the coefficient property of the fitted linear regression model, which represents the slope of the regression line.",
              "Retrieve the intercept property of the fitted linear regression model, which represents the intercept of the regression line.",
              "Return a tuple containing the computed slope and intercept as floats."
            ],
            "code": [
              "from typing import Tuple",
              "import pandas as pd",
              "from sklearn.linear_model import LinearRegression",
              "def compute_compute_slope(clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
              "    X = clean_jumps_result[['triple']].values  # Reshape to 2D array",
              "    Y = clean_jumps_result['vertical'].values",
              "    model = LinearRegression()",
              "    model.fit(X, Y)",
              "    slope = float(model.coef_[0])  # Get the slope (coefficient) and convert to float",
              "    intercept = float(model.intercept_)  # Get the intercept and convert to float",
              "    return (slope, intercept)"
            ],
            "result": {
              "result": {
                "pickle": "gASVFQAAAAAAAABHP7fMDGRrR45Hv/kQeEu2BMCGlC4=\n",
                "text": "(0.09295728160512182, -1.5665209729634597)\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-4",
            "pill": "Plot-That",
            "label": "Plot that line and the data on a scatter plot",
            "geometry": {
              "x": 640.0,
              "y": 150.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 810.0,
              "y": 200.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_plot_that",
            "function_result_var": "plot_that_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "Generate a scatter plot of the 'triple' column on the x-axis and 'vertical' column on the y-axis from clean_jumps_result.",
                      "Overlay the regression line using the computed slope and intercept from compute_slope_result.",
                      "Ensure that the plot includes appropriate labels and a legend for clarity."
                    ],
                    "algorithm": [
                      "Load the 'triple' and 'vertical' columns from the 'clean_jumps_result' DataFrame for plotting.",
                      "Create a scatter plot with the 'triple' column on the x-axis and the 'vertical' column on the y-axis using matplotlib.",
                      "Retrieve the slope and intercept from the 'compute_slope_result' tuple.",
                      "Compute the y-values for the regression line using the formula: \\[ \\text{y} = (\\text{slope} \\times \\text{triple}) + \\text{intercept} \\]",
                      "Overlay the regression line on the scatter plot.",
                      "Add labels for the x-axis as 'Triple' and y-axis as 'Vertical'.",
                      "Include a title for the plot, such as 'Scatter Plot with Regression Line'.",
                      "Add a legend to distinguish between data points and the regression line.",
                      "Display the plot."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import matplotlib.pyplot as plt",
                      "import seaborn as sns",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_plot_that(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
                      "    # Extract the slope and intercept from the compute_slope_result",
                      "    slope, intercept = compute_slope_result",
                      "    # Create the scatter plot",
                      "    plt.figure(figsize=(10, 6))",
                      "    sns.scatterplot(x='triple', y='vertical', data=clean_jumps_result, label='Data Points')",
                      "    # Compute the regression line values",
                      "    x_values = clean_jumps_result['triple']",
                      "    y_values = slope * x_values + intercept",
                      "    # Plot the regression line",
                      "    plt.plot(x_values, y_values, color='red', label='Regression Line')",
                      "    # Add labels and title",
                      "    plt.xlabel('Triple')",
                      "    plt.ylabel('Vertical')",
                      "    plt.title('Scatter Plot with Regression Line')",
                      "    plt.legend()",
                      "    # Draw the plot",
                      "    plt.draw()"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "Generate a scatter plot of the 'triple' column on the x-axis and 'vertical' column on the y-axis from clean_jumps_result.",
              "Overlay the regression line using the computed slope and intercept from compute_slope_result.",
              "Ensure that the plot includes appropriate labels and a legend for clarity."
            ],
            "description": "This step generates a visual representation of the linear relationship between the 'triple' and 'vertical' columns in the clean_jumps_result dataset. A scatter plot is created to display the data points, and the computed regression line is overlaid to illustrate the fit. This plot helps to visually assess the correlation and the accuracy of the linear model.",
            "function_return_type": {
              "type": "None"
            },
            "function_computed_value": "None",
            "algorithm": [
              "Load the 'triple' and 'vertical' columns from the 'clean_jumps_result' DataFrame for plotting.",
              "Create a scatter plot with the 'triple' column on the x-axis and the 'vertical' column on the y-axis using matplotlib.",
              "Retrieve the slope and intercept from the 'compute_slope_result' tuple.",
              "Compute the y-values for the regression line using the formula: \\[ \\text{y} = (\\text{slope} \\times \\text{triple}) + \\text{intercept} \\]",
              "Overlay the regression line on the scatter plot.",
              "Add labels for the x-axis as 'Triple' and y-axis as 'Vertical'.",
              "Include a title for the plot, such as 'Scatter Plot with Regression Line'.",
              "Add a legend to distinguish between data points and the regression line.",
              "Display the plot."
            ],
            "code": [
              "import matplotlib.pyplot as plt",
              "import seaborn as sns",
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_plot_that(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
              "    # Extract the slope and intercept from the compute_slope_result",
              "    slope, intercept = compute_slope_result",
              "    # Create the scatter plot",
              "    plt.figure(figsize=(10, 6))",
              "    sns.scatterplot(x='triple', y='vertical', data=clean_jumps_result, label='Data Points')",
              "    # Compute the regression line values",
              "    x_values = clean_jumps_result['triple']",
              "    y_values = slope * x_values + intercept",
              "    # Plot the regression line",
              "    plt.plot(x_values, y_values, color='red', label='Regression Line')",
              "    # Add labels and title",
              "    plt.xlabel('Triple')",
              "    plt.ylabel('Vertical')",
              "    plt.title('Scatter Plot with Regression Line')",
              "    plt.legend()",
              "    # Draw the plot",
              "    plt.draw()"
            ],
            "result": {
              "result": {
                "pickle": "gAROLg==\n",
                "text": "None\n"
              },
              "output": {
                "output_type": "image",
                "data": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA1UAAAIjCAIAAABkkab5AABtIElEQVR4nO3de1xT9f8H8PfhMm5jAxkIKCAiijfU1LyCJl5T0yQttLybF7xrIt28VWBe019mmqmVZnlJLTPzDioqXtGvikgoJipMZTAHDOH8/jg5xzaQy86ur+ejP9hnZ9t7hzVffD6f8/kwLMsSAAAAAFgNG2MXAAAAAAAGhfwHAAAAYF2Q/wAAAACsC/IfAAAAgHVB/gMAAACwLsh/AAAAANYF+Q8AAADAuiD/AQAAAFgX5D8AAAAA64L8BwBGc/v2bYZhNm3aZPiXZhhm/vz5FR8wefJkQ5VjEo4dO8YwzLFjxwz8uvPnz2cYxsAvCmDlkP8ATNqVK1feeuutgIAAR0fHOnXq9OjRY/Xq1TV/2q1bt65cuVK9JSsra/78+ZcuXar5k6vjIgXH3t6+fv36w4cP/+eff6rxVKdOnZo/f35ubq5+K9TLM3NBlmNjY1OrVq0+ffokJSXpr0az17Vr12bNmhm7CgD4D/IfgOk6depUmzZtLl++PG7cuP/7v/8bO3asjY3NV199VfNn1pn/FixYoPf8x5k6deqPP/64bt26vn37/vLLL23bts3Kyqrqk5w6dWrBggX6yn8FBQUff/yxfp85Kirqxx9/3Lhx48SJE0+fPv3aa69duXKlpoUaUHh4eEFBQXh4uIFf9+OPPy4oKDDwiwJYOTtjFwAA5fr888/FYnFycrKbm5uqMTs723gVVeTp06cuLi467woLC3vrrbeIaNSoUQ0bNpw6dermzZtjY2MNW2AZjo6Oen/OV1555d133+V+DgsL69OnzzfffLNmzRq9v1AFp7ombGxs+DgtL2VnZ2dnh3+MAAwK/X8Apis9Pb1p06bq4Y+IvLy81G/+9NNPr776qrOzs7u7e3h4+N9//82179mzp2/fvr6+vg4ODkFBQYsWLSopKeHu6tq16759++7cucONV9arV+/YsWNt27YlolGjRnGNqjl5Z86c6d27t1gsdnZ27tKly8mTJ1UvzU3bunbt2tChQ93d3Tt37lyZN9WtWzciysjI0HnvkSNHwsLCXFxc3NzcBgwYcP36ddVrffDBB0QUGBjIVXj79m2Nx65atcrW1lbVjbds2TKGYWbOnMndLCkpcXV1jYmJ4W6q5v9V/My7d+9u1qyZg4ND06ZN//rrr8q8QU5YWBgRpaenq1pyc3OnT5/u5+fn4ODQoEGDxYsXl5aWqu599OjRe++9JxKJ3NzcRowYcfnyZfXfwsiRI4VCYXp6+uuvv+7q6jps2DAiKi0tXblyZdOmTR0dHWvXrj1+/PgnT56onvDcuXO9evWSSCROTk6BgYGjR49W3bVt27bWrVu7urqKRKLmzZurepS15/9t3769devWTk5OEonk3XffvXfvnuourqR79+4NHDhQKBR6enrOnj1b9RmrEo35f9zMywrO/L1790aPHl27dm3u3u+//74aLwpg5fAnF4DpCggISEpKunr1ankTpxYsWDB//vyOHTsuXLhQIBCcOXPmyJEjPXv2JKJNmzYJhcKZM2cKhcIjR458+umneXl5S5YsIaKPPvpIJpP9+++/K1asICKhUNi4ceOFCxd++umn77//PhdcOnbsSERHjhzp06dP69at582bZ2Njs3Hjxm7duiUmJr766quqGgYPHhwcHPzFF1+wLFuZN8VFIg8PD+27Dh061KdPn/r168+fP7+goGD16tWdOnW6cOFCvXr1Bg0adPPmzZ9//nnFihUSiYSIPD09NR4eFhZWWlp64sSJfv36EVFiYqKNjU1iYiJ378WLF+VyufbgZgXPfOLEiV27dk2aNMnV1XXVqlWRkZGZmZk6K9fGhUh3d3fupkKh6NKly71798aPH+/v73/q1KnY2Nj79+9zo/ClpaX9+/c/e/bsxIkTQ0JC9uzZM2LECI0nfPbsWa9evTp37rx06VJnZ2ciGj9+/KZNm0aNGjV16tSMjIz/+7//u3jx4smTJ+3t7bOzs3v27Onp6Tl37lw3N7fbt2/v2rWLe56DBw9GRUVFREQsXryYiK5fv37y5Mlp06ZpvwXuydu2bRsXF/fw4cOvvvrq5MmTFy9eVP1BUlJS0qtXr3bt2i1duvTQoUPLli0LCgqaOHFiZc5PxSo48w8fPmzfvj2XET09Pffv3z9mzJi8vLzp06fX/HUBrAgLAKbq77//trW1tbW17dChw5w5cw4cOKBUKlX3pqWl2djYvPnmmyUlJarG0tJS7geFQqH+VOPHj3d2di4sLORu9u3bNyAgQP2A5ORkItq4caP6UwUHB/fq1Uv9OQMDA3v06MHdnDdvHhFFRUVV8BaOHj1KRN9//31OTk5WVta+ffvq1avHMExycjLLslwvoOpFW7Zs6eXl9ejRI+7m5cuXbWxshg8fzt3kwmtGRkZ5r1VSUiISiebMmcMV7+HhMXjwYFtb2/z8fJZlly9fbmNj8+TJE+5gIpo3b14Fz0xEAoHg1q1bqmKIaPXq1TpfmnsjCxYsyMnJefDgQWJiItefun37du6ARYsWubi43Lx5U/WQuXPn2traZmZmsiy7c+dOIlq5cqXqjXC9pKozw8XBuXPnqh7O5dotW7aoWrhOMq7lt99+IyLuJGuYNm2aSCR69uyZ9l3cL+vo0aMsyyqVSi8vr2bNmhUUFHD3/vHHH0T06aefqpe0cOFC1cNbtWrVunVrneeHZdkuXbo0bdpU513cB0l1s+IzP2bMGB8fH6lUqjr+nXfeEYvFGh94AKgYxn8BTFePHj2SkpLeeOONy5cvf/nll7169apTp87evXu5e3fv3l1aWvrpp5/a2Lz4H1k1jubk5MT9kJ+fL5VKw8LCFArFjRs3Kv/qly5dSktLGzp06KNHj6RSqVQqffr0aUREREJCgvrA5YQJE176VKNHj/b09PT19e3bt+/Tp083b97cpk0bjWPu379/6dKlkSNH1qpVi2sJDQ3t0aPHn3/+WcmCbWxsOnbsmJCQQETXr19/9OgRF5i463ATExObNWumMZhese7duwcFBamKEYlEFV+5PG/ePE9PT29v77CwsOvXry9btoyb9UhE27dvDwsLc3d3lz7XvXv3kpISrtq//vrL3t5+3LhxqjcSHR2t/fzqXWvbt28Xi8U9evRQPWHr1q2FQiGX4bi3+ccffxQXF2s8iZub29OnTw8ePFjxez937lx2dvakSZNUMwL79u0bEhKyb98+9cPUf/thYWHVu7JbW3lnnmXZnTt39u/fn2VZ1Rvv1auXTCa7cOGCXl4awEpg/BfApLVt23bXrl1KpfLy5cu//fbbihUr3nrrrUuXLjVp0iQ9Pd3GxqZJkyY6H/i///3v448/PnLkSF5enqpRJpNV/qXT0tKISHsgknse1chmYGDgS5/q008/DQsLs7W1lUgkjRs31jnZ/86dO0TUqFEj9cbGjRsfOHCg8pc7hIWFcWPHiYmJPj4+r7zySosWLRITE3v06HHixIkhQ4ZU5klU/P391W+6u7urT7DT9v777w8ePLiwsPDIkSOrVq1SnwyXlpaWkpKiPWbNXc1z584dHx8fblSX06BBA40j7ezs6tatq/6EMplMYzKo6gm7dOkSGRm5YMGCFStWdO3adeDAgUOHDnVwcCCiSZMm/frrr3369KlTp07Pnj2HDBnSu3dv7fei89cREhJy4sQJ1U1HR0f1d/TS81N55Z35nJyc3NzcdevWrVu3TuMhJntdFIBpQv4DMAMCgaBt27Zt27Zt2LDhqFGjtm/fzg2ZlSc3N7dLly4ikWjhwoVBQUGOjo4XLlyIiYlR77d7Ke7gJUuWtGzZUuMuoVCo+lnV0ViB5s2bd+/evfIvXW2dO3cuLi5OSkpKTEzkJjKGhYUlJibeuHEjJyeHa6k8W1tbjRa2wjmOwcHB3Nvs16+fra3t3LlzX3vtNa6ns7S0tEePHnPmzNF4SMOGDStZjIODg3pHb2lpqZeX15YtWzQO4wIZwzA7duw4ffr077//fuDAgdGjRy9btuz06dNCodDLy+vSpUsHDhzYv3///v37N27cOHz48M2bN1eyDHXa50dfyjvz3Gfy3Xff1f6zJDQ0lKdiACwS8h+AOeHCxP3794koKCiotLT02rVr2vns2LFjjx492rVrl+pyB43rbbW3W9Bu4QbgRCKRYaJbQEAAEaWmpqo33rhxQyKRcJ1/ldki4tVXXxUIBImJiYmJidxVveHh4evXrz98+DD3s85H8bH5xEcffbR+/fqPP/6Ym5YXFBQkl8vLO5MBAQFHjx5VKBSqLsBbt25V/PxBQUGHDh3q1KlTBfm7ffv27du3//zzz7du3Tps2LBt27aNHTuWiAQCQf/+/fv3719aWjpp0qRvv/32k08+0ehxVP06uJmInNTUVK7dWDw9PV1dXUtKSgzzmQSwYJj/B2C6uJn46i3cZDhuVG7gwIE2NjYLFy5U79Xjjue6T1SPVSqVGqvQubi4aIwFcxlLfQ3k1q1bBwUFLV26VC6Xqx+Zk5NT87emzcfHp2XLlps3b1bVcPXq1b///vv1118vr0Jtjo6Obdu2/fnnnzMzM1X9fwUFBatWrQoKCvLx8dH5qMo8c1W5ubmNHz/+wIED3JLaQ4YMSUpKOnDggPoxubm5z549I6JevXoVFxevX7+eay8tLf36668rfv4hQ4aUlJQsWrRIvfHZs2fcu+Auc1G1c38hFBUVEdGjR49U7TY2Nly3GXeXujZt2nh5ea1du1Z11/79+69fv963b9/KnQBe2NraRkZG7ty58+rVq+rtPH0mASwY+v8ATNeUKVMUCsWbb74ZEhKiVCpPnTr1yy+/1KtXb9SoUUTUoEGDjz76aNGiRWFhYYMGDXJwcEhOTvb19Y2Li+vYsaO7u/uIESOmTp3KMMyPP/6okSNbt279yy+/zJw5s23btkKhsH///kFBQW5ubmvXrnV1dXVxcWnXrl1gYOB3333Xp0+fpk2bjho1qk6dOvfu3Tt69KhIJPr999/5eL9Llizp06dPhw4dxowZw63/IhaLVbv0tm7dmog++uijd955x97evn///jonBYaFhcXHx4vF4ubNmxORl5dXo0aNUlNTR44cWd7rVvKZq2ratGkrV66Mj4/ftm3bBx98sHfv3n79+o0cObJ169ZPnz69cuXKjh07bt++LZFIBg4c+Oqrr86aNevWrVshISF79+59/PgxVdgx2aVLl/Hjx8fFxV26dKlnz5729vZpaWnbt2//6quv3nrrrc2bN69Zs+bNN98MCgrKz89fv369SCTikvTYsWMfP37crVu3unXr3rlzZ/Xq1S1btmzcuLHG89vb2y9evHjUqFFdunSJiori1n+pV6/ejBkzqn1CcnJyPvvsM/WWwMBAbi3DyouPjz969Gi7du3GjRvXpEmTx48fX7hw4dChQ9wZA4DKMs5lxwBQCfv37x89enRISIhQKBQIBA0aNJgyZcrDhw/Vj/n+++9btWrl4ODg7u7epUuXgwcPcu0nT55s3769k5OTr68vt3YMPe9QZFlWLpcPHTqUu0pUtRDMnj17mjRpwl2coVp55OLFi4MGDfLw8HBwcAgICBgyZMjhw4e5u7g5iDk5ORW8Be5yVNUyKBo01n9hWVY1pikSifr373/t2jX14xctWlSnTh1uGlx5C8FwF6j26dNH1cINem7YsEH9MFJb/0XnMxNRdHS0+kMCAgJGjBhRwRtZsmSJRvvIkSNtbW25pUzy8/NjY2MbNGggEAgkEknHjh2XLl2qWtAnJydn6NChrq6uYrF45MiR3Drb27Zt4+4dMWKEi4uL9uuuW7eOW5/Z1dW1efPmc+bMycrKYln2woULUVFR/v7+Dg4OXl5e/fr1O3fuHPeQHTt29OzZ08vLSyAQ+Pv7jx8//v79+9xd6uu/cH755Rfu01WrVq1hw4b9+++/qru0S9JYxkVDly5dtP8BioiI0H7gS8/8w4cPo6Oj/fz87O3tvb29IyIi1q1bV97rAoBODFu5JVsBAMBgdu/e/eabb544caJTp07GrgUALBDyHwCA8RUUFKiu5CgpKenZs+e5c+cePHhQmcurAQCqCvP/AACMb8qUKQUFBR06dCgqKtq1a9epU6e++OILhD8A4An6/wAAjG/r1q3Lli27detWYWFhgwYNJk6cOHnyZGMXBQAWC/kPAAAAwLpg/T8AAAAA64L8BwAAAGBdzOb6j9LS0qysLFdXVz52agIAAAAwFyzL5ufn+/r6qm8LXiVmk/+ysrL8/PyMXQUAAACASbh7927dunWr91izyX+urq5EdPfuXZFIZOxaAAAAAIwmLy/Pz8+Pi0bVYzb5jxv2FYlEyH8AAAAANZkRh+s/AAAAAKwL8h8AAACAdUH+AwAAALAuZjP/rwIsyz579qykpMTYhYDe2Nra2tnZYa0fAAAAPph9/lMqlffv31coFMYuBPTM2dnZx8dHIBAYuxAAAABLY975r7S0NCMjw9bW1tfXVyAQoLvIMrAsq1Qqc3JyMjIygoODq724JQAAAOhk3vlPqVSWlpb6+fk5OzsbuxbQJycnJ3t7+zt37iiVSkdHR2OXAwAAYFEsoWcF/UMWCb9WAAAAnuCfWAAAAADrgvwHAAAAYF2Q/6zF/PnzW7ZsaewqAAAAwPiQ//Rj5MiRDMMwDGNvb1+7du0ePXp8//33paWlL33gpk2b3NzcqvGKXbt25V7R0dGxSZMma9asqfj42bNnHz58+KVPW69evZUrV1ajHgAAADAXyH9607t37/v379++fXv//v2vvfbatGnT+vXr9+zZM/5ecdy4cffv37927dqQIUOio6N//vnnCg4WCoUeHh78FQMAAADmwhrzn0yhTM+WX8x8kp4jlymU+npaBwcHb2/vOnXqvPLKKx9++OGePXv279+/adMm7t7ly5c3b97cxcXFz89v0qRJcrmciI4dOzZq1CiZTMb15M2fP5+IfvzxxzZt2ri6unp7ew8dOjQ7O7u8V3R2dvb29q5fv/78+fODg4P37t1LRJmZmQMGDBAKhSKRaMiQIQ8fPuQOVh//HTly5MCBA5cuXerj4+Ph4REdHV1cXExEXbt2vXPnzowZM7h6iOjOnTv9+/d3d3d3cXFp2rTpn3/+qa/TBQAAAMZidfkvK7dg8s8XI5Yff3PNqYhlx6f8fDErt4CPF+rWrVuLFi127drF3bSxsVm1atX//ve/zZs3HzlyZM6cOUTUsWPHlStXikSi+/fv379/f/bs2URUXFy8aNGiy5cv7969+/bt2yNHjqzMyzk5OXGrIQ4YMODx48fHjx8/ePDgP//88/bbb+s8/ujRo+np6UePHt28efOmTZu4nLpr1666desuXLiQq4eIoqOji4qKEhISrly5snjxYqFQqIdTAwAAYHF46l3iiXmv/1xVMoUyZmdKYppU1ZKQJp27M2V1VCuxs/73GQsJCUlJSeF+nj59OvdDvXr1PvvsswkTJqxZs0YgEIjFYoZhvL29VY8aPXo090P9+vVXrVrVtm1buVxeQfAqKSn5+eefU1JS3n///cOHD1+5ciUjI8PPz4+Ifvjhh6ZNmyYnJ7dt21bjUe7u7v/3f/9na2sbEhLSt2/fw4cPjxs3rlatWra2tlzXI3dYZmZmZGRk8+bNuXr0cloAAAAsTFZugXrACA+WxEeG+ro5GbeqClhX/59UrlQPf5yENKlUzktOZ1lWtSXdoUOHIiIi6tSp4+rq+t577z169Ki8PYvPnz/fv39/f39/V1fXLl26EFFmZqbOI9esWSMUCp2cnMaNGzdjxoyJEydev37dz8+PC39E1KRJEzc3t+vXr2s/tmnTpra2ttzPPj4+5Y0yT5069bPPPuvUqdO8efNUWRYAAABUyutdMuVeQOvKf3mFxTrb88tpr6Hr168HBgYS0e3bt/v16xcaGrpz587z589//fXXRKRU6vhYPH36tFevXiKRaMuWLcnJyb/99lt5RxLRsGHDLl26lJGR8fTp0+XLl1dpwwx7e3vVzwzDlHep8tixY//555/33nvvypUrbdq0Wb16deVfAgAAwBpwvUut7t344q/VwTl3uEb+epf0wrrGf0WO9jrbXctpr4kjR45cuXJlxowZRHT+/PnS0tJly5ZxEe3XX39VHSYQCEpKSlQ3b9y48ejRo/j4eK4P79y5cxW8hFgsbtCggXpL48aN7969e/fuXe7h165dy83NbdKkSeXL1qiHiPz8/CZMmDBhwoTY2Nj169dPmTKl8s8GAABg8Z4+yL65ZKCg9BkR2ZeUfNB3OtfOU++SXlhX/59EKAgPlmg0hgdLJEI9TP4rKip68ODBvXv3Lly48MUXXwwYMKBfv37Dhw8nogYNGhQXF69evfqff/758ccf165dq3pUvXr15HL54cOHpVKpQqHw9/cXCATckXv37l20aFGVaujevXvz5s2HDRt24cKFs2fPDh8+vEuXLm3atKn8M9SrVy8hIeHevXtSqZSIpk+ffuDAgYyMjAsXLhw9erRx48ZVqgcAAMCSsSy9/XZoiyAu/BHRhrYDVHfy0bukL9aV/8TOgvjIUPUIGB4sWRwZqpeLP/766y8fH5969er17t376NGjq1at2rNnDzfHrkWLFsuXL1+8eHGzZs22bNkSFxenelTHjh0nTJjw9ttve3p6fvnll56enps2bdq+fXuTJk3i4+OXLl1apRoYhtmzZ4+7u3t4eHj37t3r16//yy+/VOkZFi5cePv27aCgIE9PTyIqKSmJjo5u3Lhx7969GzZs+NJVpgEAAKzFDz+QjQ09H9P7q2GHwDl7b3gFcjf11bvEE4ZlWWPXUCl5eXlisVgmk4lEIlVjYWFhRkZGYGCgo6Nj5Z9KplBK5cr8wmJXR3uJUMDHlb9Qc9X75QIAAPDu+nUqO7fqwa3MOceyEtSu/10cGerD2/W/OkNRlVjX/D+O2BmZDwAAAKpOoaAmTejOnRctiYnUubM30Wqf2mbUu2Rd478AAAAA1TRzJrm4vAh/n39OLEudO3O3xM6CIC9hS3/3IC+hiYc/ss7+PwAAAIAq+PNP6tv3xc127SgxkexN9/KOl0L+AwAAACjH3bvk71+m5fZtCggwUjV6w+/4b7169ZiyoqOjiaiwsDA6OtrDw0MoFEZGRj58+JDXMgAAAACq5tkz6tSpTPjbs4dY1gLCH/Gd/5KTk+8/d/DgQSIaPHgwEc2YMeP333/fvn378ePHs7KyBg0axGsZAAAAAFXw5Zdkb0+nTv13c/JkYll64w2j1qRP/I7/cmvIceLj44OCgrp06SKTyTZs2LB169Zu3boR0caNGxs3bnz69On27dvzWgwAAADAS5w+TR06vLhZty7duEEuLsYriBcGuv5XqVT+9NNPo0ePZhjm/PnzxcXF3bt35+4KCQnx9/dPSkrSflRRUVGeGsOUCgAAANbo8WMSCMqEvytX6O5dywt/ZLD8t3v37tzc3JEjRxLRgwcPBAKBm5ub6t7atWs/ePBA+1FxcXHi57gNbQEAAAD0jGVpyBDy8KDi5zv2fvcdsSw1a2bUsnhkoPy3YcOGPn36+Pr6VulRsbGxsufu3r3LU21W4vbt2wzDXLp0iddXqVev3sqVK3l9CQAAAH3avJlsbGj79v9uvvkmlZTQmDFGrYl3hsh/d+7cOXTo0NixY7mb3t7eSqUyNzdXdcDDhw+9vb21H+jg4CBSY4BSq23kyJHcBc729vaBgYFz5swpLCw0dlFl+Pn53b9/v5me/pSZP39+y5YttduTk5Pff/99vbwEAAAAv65fJ4ahkSP/u8kwlJNDu3aRjeXvjmGId7hx40YvL6++zxdObN26tb29/eHDh7mbqampmZmZHdSH281T796979+//88//6xYseLbb7+dN2+eXp62pKSktLS05s9ja2vr7e1tZ8f7FT/Ozs68vgQAAEBNKRRUr16ZPXxPnKDSUpJIjFeTQfGe/0pLSzdu3DhixAhV8hCLxWPGjJk5c+bRo0fPnz8/atSoDh066OHiX5alp0/5+o9lX/r6Dg4O3t7efn5+AwcO7N69O7feDXcG4uLiAgMDnZycWrRosWPHDtVD9u7dGxwc7Ojo+Nprr23evJlhGK5bdNOmTW5ubnv37m3SpImDg0NmZmZRUdHs2bPr1Knj4uLSrl27Y8eOcc9w586d/v37u7u7u7i4NG3a9M8//ySiJ0+eDBs2zNPT08nJKTg4eOPGjaQ1/nv8+PFXX33VwcHBx8dn7ty5z54949q7du06derUOXPm1KpVy9vbe/78+VX6JaiP/zIM891337355pvOzs7BwcF79+5VHXb16tU+ffoIhcLatWu/9957Uqm0Sq8CAABQfdOn69jGrVMno9ZkaLzv/3Ho0KHMzMzRo0erN65YscLGxiYyMrKoqKhXr15r1qzRwyspFCQU6uF5dJLLK3/5z9WrV0+dOhXwfH3IuLi4n376ae3atcHBwQkJCe+++66np2eXLl0yMjLeeuutadOmjR079uLFi7Nnz1Z/EoVCsXjx4u+++87Dw8PLy2vy5MnXrl3btm2br6/vb7/91rt37ytXrgQHB0dHRyuVyoSEBBcXl2vXrgmFQiL65JNPrl27tn//folEcuvWrYKCAo0K79279/rrr48cOfKHH364cePGuHHjHB0dVVFv8+bNM2fOPHPmTFJS0siRIzt16tSjR4/qnbYFCxZ8+eWXS5YsWb169bBhw+7cuVOrVq3c3Nxu3bqNHTt2xYoVBQUFMTExQ4YMOXLkSPVeAgAAoLL27aN+/V7cNP9t3KqPNRMymYyIZDKZemNBQcG1a9cKCgpYlmXlcpaIr//k8orLGzFihK2trYuLi4ODAxHZ2Njs2LGDZdnCwkJnZ+dTp06pjhwzZkxUVBTLsjExMc2aNVO1f/TRR0T05MkTlmW5HrtLly5xd925c8fW1vbevXuqgyMiImJjY1mWbd68+fz58zWK6d+//6hRozQaMzIyiOjixYssy3744YeNGjUqLS3l7vr666+FQmFJSQnLsl26dOncubPqUW3bto2JidF+v/PmzWvRooV2e0BAwIoVK7ifiejjjz/mfpbL5US0f/9+lmUXLVrUs2dP1UO4K3tSU1M1nqrMLxcAAKAmMjM1/2W/c8fYNVWfzlBUJRa0/6+zM8nlPD75y7z22mvffPPN06dPV6xYYWdnFxkZSUS3bt1SKBTq/WdKpbJVq1ZElJqa2rZtW1X7q6++qv5sAoEgNDSU+/nKlSslJSUNGzZU3VtUVOTh4UFEU6dOnThx4t9//929e/fIyEjuIRMnToyMjLxw4ULPnj0HDhzYsWNHjVKvX7/eoUMHhmG4m506dZLL5f/++6+/vz8RqV6XiHx8fLKzsytxgnRTPZWLi4tIJOKe6vLly0ePHhWW7axNT09Xf4MAAAD68ewZdenyYicPItqzx5J28qgeC8p/DGPcFRpdXFwaNGhARN9//32LFi02bNgwZswYrt9r3759derUUR3J9RFWzMnJSZXP5HK5ra3t+fPnbW1tVQdw+Wns2LG9evXat2/f33//HRcXt2zZsilTpvTp0+fOnTt//vnnwYMHIyIioqOjly5dWvk3Yq/WE84wTE2uPtH5VHK5vH///osXL1Y/0sfHp9qvAgAAoNuXX1JMzIubkyfT6tXGq8aEWFD+Mxk2NjYffvjhzJkzhw4dqrqAo0uXLhqHNWrUiLtcg5OcnFzeE7Zq1aqkpCQ7OzssLEz7Xj8/vwkTJkyYMCE2Nnb9+vVTpkwhIk9PzxEjRowYMSIsLOyDDz7QyH+NGzfeuXMny7JcxDx58qSrq2vdunVr8q4r75VXXtm5c2e9evX4vhgZAACsV1ISqQ9/+fnR9esWuZNH9Vj+CjdGMXjwYFtb26+//trV1XX27NkzZszYvHlzenr6hQsXVq9evXnzZiIaP378jRs3YmJibt68+euvv27atImIVH1+6ho2bDhs2LDhw4fv2rUrIyPj7NmzcXFx+/btI6Lp06cfOHAgIyPjwoULR48ebdy4MRF9+umne/bsuXXr1v/+978//viDa1Q3adKku3fvTpky5caNG3v27Jk3b97MmTNtqrjcUUFBwSU16enplXxgdHT048ePo6KikpOT09PTDxw4MGrUqJKSkiq9OgAAgG6PH5O9fZnwd/UqZWYi/KlD/uOFnZ3d5MmTv/zyy6dPny5atOiTTz6Ji4tr3Lhx79699+3bFxgYSESBgYE7duzYtWtXaGjoN998w13/Ud7Q8MaNG4cPHz5r1qxGjRoNHDgwOTmZm6tXUlISHR3NPXPDhg25K6kFAkFsbGxoaGh4eLitre22bds0nq1OnTp//vnn2bNnW7RoMWHChDFjxnz88cdVfY83b95spWb8+PGVfKCvr+/JkydLSkp69uzZvHnz6dOnu7m5VTV9AgAAaFJt4/Z8UTPasIFYlpo2NWpZpohhK7GynSnIy8sTi8UymUx9I5DCwsKMjIzAwEBHR0cj1qYXn3/++dq1a7HNnYol/XIBAIB3mzbRqFEvbg4aRNu3W+pOHjpDUZVgApYxrVmzpm3bth4eHidPnlyyZMnkyZONXREAAIC5uXatTA8fw1B2tvXs5FE9yH/GlJaW9tlnnz1+/Njf33/WrFmxsbHGrggAAMB8KBTUpMmLnTyI6MQJa9vJo3qQ/4xpxYoVK1asMHYVAAAAZmj6dPrqqxc3v/iC0I1Sach/AAAAYFb++IP6939x05q3casuS8h/5nIJC1QJfq0AAKDp7l3y9y/TcueOZgtUgnlfF8NtL6FQKIxdCOgf92u1x99zAABARMXF1LFjmai3dy+xLMJf9Zh3/5+tra2bmxu3q6yzs7POxZPB7LAsq1AosrOz3dzc1Le8AwAAK7V4Mc2d++LmlCm0apXxqrEE5p3/iMjb25uIuAgIlsTNzY375QIAgPU6darM9bzYxk1PzD7/MQzj4+Pj5eVVXFxs7FpAb+zt7dHzBwBg1R49otq1SX130KtXsZOHvph9/uPY2toiLgAAgAHIFEqpXJlXWCxyspe4CMTOAmNXZHFYlgYPpp07X7R8/32ZvT2gxiwk/wEAABhAVm5BzM6UxDQpdzM8WBIfGerr5mTcqixKt2509OiLm5GRtH07YX6/vpn39b8AAAAGI1Mo1cMfESWkSefuTJEplEasynLs3EkM8yL82dqSVEo7diD88QH5DwAAoFKkcqV6+OMkpEmlcuS/mpFKiWHorbdetPzyCz17Rh4exqvJwmH8FwAAoFLyCnVfaJhfTjtUikb3nlhMubnGqcSaoP8PAACgUkSOulekdy2nHV5i0iTN8KdQIPwZBvIfAABApUiEgvBgiUZjeLBEIsQlwFWUlEQMQ99886LlxAliWXLClTQGgvwHAABQKWJnQXxkqHoEDA+WLI4MxRIwVVBQQAxDHTu+aHn/fWLZMos8A/8w/w8AAKCyfN2cVke1ksqV+YXFro72EiHW/6sKDw96/LhMC8saqRRrh/4/AACAKhA7C4K8hC393YO8hAh/lbVsGTFMmfCXnY3wZ0To/wMAgErBvhdQHbduUXBwmZZff6XBg41UDfwH+Q8AAF4O+15AlZWWksbWrOHhdPy4kaqBMjD+CwAAL4F9L6DKunbVDH8lJQh/pgP5DwAAXgL7XkAVcDu2qUe9mzeJZckGkcOE4JcBAAAvgX0voFK4bdzU5/YtWUIsqzn/D0wA5v8BAMBLYN8LeDmNnTzc3OjJEyOVAi+H/j8AAHgJ7HsBFZkwQcc2btUNfzKFMj1bfjHzSXqOHBNM+YP+PwAAeAlu34u5O1MS1K7/xb4XQKdOae7bceJETXbywGXmBsOwZrL6Yl5enlgslslkIpHI2LUAAFgjbv0/7HsBREQFBeTsXKZl/Hhau7YmTylTKCf/fFHjSqPwYMnqqFb4sGmoeShC/x8AAFSK2BmZD4iIyN2dcnPLtOijL6mCy8zxwdM7zP8DAADQJ0uewbZ0KTFMmfCXk6Ovbdxwmbkhof8PAABAbyx2BltaGjVsWKZl+3Z66y09vgIuMzck9P8BAADoh2VulFJaSgxTJvx16UIsq9/wR7jM3LCQ/wAAAPTDAjdK6dJFxzZux47x8VLcZebqERCXmfMH478AAAD6YVEz2LZvpyFDyrTcvMn3Th6+bk6ro1rhMnMDQP4DAADQDwuZwZaTQ15eZVqWLqVZswzz4rjM3DCQ/wAAAPSDm8GWoLWCnTnNYNPYycPdnR4/NlIpwCPM/wMAANAP857BpnMbN4Q/C4X+PwAAAL0xyxlsJ09S586aLR07GqkaMATe+//u3bv37rvvenh4ODk5NW/e/Ny5c1z7yJEjGTW9e/fmuxIAAAADEDsLgryELf3dg7yEph7+CgqIYcqEv4kTiWUR/iwev/1/T5486dSp02uvvbZ//35PT8+0tDR3d3fVvb179964cSP3s4ODA6+VAAAAQBlubiSTlWnR004eYPr4zX+LFy/28/NThbzAwED1ex0cHLy9vXktAAAAADQtWUJz5pRpyckhiebay2DB+B3/3bt3b5s2bQYPHuzl5dWqVav169er33vs2DEvL69GjRpNnDjx0aNH2g8vKirKU8NrqQAAAJbv5k1imDLhb8cOYlmEP2vDsHx29jo6OhLRzJkzBw8enJycPG3atLVr144YMYKItm3b5uzsHBgYmJ6e/uGHHwqFwqSkJNuyi4zPnz9/wYIF6i0ymUwkEvFXMAAAgGUqKSG7soN+XbvS0aNGqgZqJC8vTywW1yQU8Zv/BAJBmzZtTp06xd2cOnVqcnJyUlKSxmH//PNPUFDQoUOHIiIi1NuLioqKioq4n/Py8vz8/JD/AAAAqiw8nBITy7SUlJAN1oAzVzXPf/z+7n18fJo0aaK62bhx48zMTO3D6tevL5FIbt26pdHu4OAgUsNrqQAAABbo11+JYcqEv5s3iWUR/qwcv7/+Tp06paamqm7evHkzICBA+7B///330aNHPj4+vBYDAABgRXJyiGHo7bdftCxdSizL9x6+YBb4vf53xowZHTt2/OKLL4YMGXL27Nl169atW7eOiORy+YIFCyIjI729vdPT0+fMmdOgQYNevXrxWgwAAIC10NjJo1Yt0nWdJVgtfvv/2rZt+9tvv/3888/NmjVbtGjRypUrhw0bRkS2trYpKSlvvPFGw4YNx4wZ07p168TERCwBCAAAUFPjx2uGv4IChD/QwO/1H3pU86mOAAAAluzECQoLK9Ny6hR16GCkaoBHNQ9F2P8XAADAzCkU5OJSpmXiRFqzxkjVgBlA/gMAADBnIhHl55dpMZORPTAiXP4NAABgnr78khimTPjLyUH4g8pA/x8AAIC5uXmTGjUq07JjB0VGGqkaMD/IfwAAAOZDexu3116jI0eMVA2YK+Q/AAAAM9G5M508WaYF27hBteBDAwAAYPK4bdzUw9+tW9jGDaoNnxsAAAATlp2tuY3b8uXEshQUZLyawOxh/BcAAMBUaezk4eFBUqmRSgGLgv4/AAAA0zNunI5t3BD+QE+Q/wAAAEzJiRPEMPTddy9akpKIZcnR0Xg1gaXB+C8AAIBp0N7GbdIk+vprI1UDlgz5DwAAwARgGzcwIIz/AgAAGNXixZrbuEmlCH/AK/T/AQAAGElqKoWElGnZuZMGDTJSNWBFkP8AAAAMTnsbt27d6PBhI1UDVgf5DwAAwLCwjRsYGz5tAAAAhrJtG7ZxA1OADxwAAAD/uG3coqJetKxYgW3cwFgw/gsAZkymUErlyrzCYpGTvcRFIHYWGLsiAF00dvLw9KTsbCOVAkCE/AcA5isrtyBmZ0pi2n87YoUHS+IjQ33dnIxbFUAZY8fShg1lWgoKsJMHGB3GfwHALMkUSvXwR0QJadK5O1NkCqURqwJ4ITGRGKZM+MM2bmAykP8AwCxJ5Ur18MdJSJNK5ch/YGwyGTEMhYe/aImOJpal9u2NVxNAGRj/BQCzlFdYrLM9v5x2AAPRmOpH2MYNTBH6/wDALIkc7XW2u5bTDsC7/v01wx+2cQNThfwHAGZJIhSEB0s0GsODJRIhLgEGg9uzhxiG/vjjRctnnxHLkoeH8WoCqAjGfwHALImdBfGRoXN3piSoXf+7ODIUS8CAQRUXk0DrI4c+PzB5yH8AYK583ZxWR7WSypX5hcWujvYSIdb/A8PSnur37BnZ2hqjFICqQf4DADMmdkbmgyrQ24LhAwbQ3r1lWv7+m3r0qHmFAIaB/AcAAP+x7P1U9LNg+OnT1KFDmZZ69SgjQ081AhgI8h8AABBZ+n4q5S0YvjqqVRViLtZ2AUuB638BAMDy91Op6YLhDIO1XcCSIP8BAIDl76dS/QXDx43TTH6zZ2NtFzB3GP8FAADL30+lOguGZ2VRnTqajejzA4uA/j8AALD8/VSqvGA4w2iGP5ZF+AOLgfwHAACWv58Kt2C4+nssd8Fw7al+ly8j+YGFYVgz+Uzn5eWJxWKZTCYSiYxdCwCABcrKLdDeT8XHUq7/5XAL3JS7YPh339G4cWVa2rals2cNWSFAZdQ8FGH+HwAAEFnHfirlLhheVESOjpqNZtI/AlANyH8AAPAfK91PRXtVv+JissO/j2DJMP8PAACsVb16muHv11+JZRH+wOLhIw4AANYnKYk6dtRsxIAvWA3kPwAAsCYsSzZaY19IfmBlMP4LAABWg2E0wx+2cQOrhPwHAAD6J1Mo07PlFzOfpOfITWIT4bFjNaf6xcRgGzewWrznv3v37r377rseHh5OTk7Nmzc/d+4c186y7Keffurj4+Pk5NS9e/e0tDS+KwEAAMPIyi2Y/PPFiOXH31xzKmLZ8Sk/X8zKLTBeNVnEMLRhQ5lGlqX4eCMVBGB8/Oa/J0+edOrUyd7efv/+/deuXVu2bJm7uzt315dffrlq1aq1a9eeOXPGxcWlV69ehYWFvBYDAAAGIFMoY3amJD5fR5qIEtKkc3emGKcXENu4AejC7/Ufixcv9vPz27hxI3czMDCQ+4Fl2ZUrV3788ccDBgwgoh9++KF27dq7d+9+5513eK0HAAD4JpUr1cMfJyFNKpUrDbq4oPaqfikp1Ly54QoAMGH89v/t3bu3TZs2gwcP9vLyatWq1fr167n2jIyMBw8edO/enbspFovbtWuXlJSk8fCioqI8NbyWCgAAepFXWKyzPb+cdv1bv14z/LVrRyyL8Aegwm/+++eff7755pvg4OADBw5MnDhx6tSpmzdvJqIHDx4QUe3atVVH1q5dm2tUFxcXJ37Oz8+P11IBAEAvRI72Ottdy2nXp6IiYhh6//0yjSxLp0/z/tIAZoXf/FdaWvrKK6988cUXrVq1ev/998eNG7d27drKPzw2Nlb23N27d/mrEwAA9EUiFIQHSzQaw4MlEiHPg78Mo7mH77NnmOoHoBO/+c/Hx6dJkyaqm40bN87MzCQib29vInr48KHqrocPH3KN6hwcHERqeC0VAAD0QuwsiI8MVY+A4cGSxZGhPE7+8/fXHPDdsYNYlmxt+XpFADPH7/UfnTp1Sk1NVd28efNmQEAAEQUGBnp7ex8+fLhly5ZElJeXd+bMmYkTJ/JaDAAAGIavm9PqqFZSuTK/sNjV0V4iFGiEP5lCKZUr8wqLRU72EhfNe6vg5Enq3FmzEX1+AC/Db/6bMWNGx44dv/jiiyFDhpw9e3bdunXr1q0jIoZhpk+f/tlnnwUHBwcGBn7yySe+vr4DBw7ktRgAADAYsXO5qS4rt0B9gZjwYEl8ZKivm1PVXgDbuAHUAMPy/H/LH3/8ERsbm5aWFhgYOHPmzHHjxnHtLMvOmzdv3bp1ubm5nTt3XrNmTcOGDSt4nry8PLFYLJPJMBAMAGC+ZArl5J8vaiwQEx4sWR3Vqgq9gNpruzx6RLVq6aNAADNQ81DEe/7TF+Q/AAALkJ4tj1h+XLv98MwuQV7Clz9+9Gh6vqbsf+bOpbg4PVUHYB5qHor4Hf8FAABQV/3VAe/do7p1NRvNpAsDwNQg/wEAgOFUc3VA7QFfJD+AGuB3/RcAAAB1VV4dkGE0w9+VKwh/ADWE/AcAAIZThdUBv/1WM/l17EgsS82a8V8mgIXD+C8AABjUS1cHpMJCctJaDgZ9fgD6g/wHAACGVsHqgDqm+j17hp08APQL478AAGAa6tbFNm4AhoH+PwAAMDZs4wZgWMh/AABgPNjGDcAYMP4LAABGwjCa4e/xY4Q/AANA/gMAAIPr2lVzql9sLLEsubsbqSAA64LxXwAAMKCMDKpfX7MRfX4AhoX8BwAAhoJt3ABMA8Z/AQCAf9rbuJ07h/AHYCzIfwAAwKdFizSTn0RCLEutWxupIADA+C8AAPBEoSAXF81G9PkBmADkPwAA0yJTKKVyZV5hscjJXuJS/j5pJg7buAGYMOQ/AAATkpVbELMzJTFNyt0MD5bER4b6ujkZt6qq0U5+GzbQ6NHGKAUAdMP8PwAAUyFTKNXDHxElpEnn7kyRKZRGrKoKduzQfYUvwh+AiUH/HwCAqZDKlerhj5OQJpXKlaY+Coxt3ADMCvr/AABMRV5hsc72/HLaTYX2Nm4PHiD8AZgy5D8AAFMhcrTX2e5aTrvxBQRoDvj27k0sS7VrG6kgAKgUjP8CAJgKiVAQHixJKDsEHB4skQhNb/A3NZVCQjQb0ecHYCbQ/wcAYCrEzoL4yNDwYImqJTxYsjgy1OQm/zGMZvhjWYQ/ADOC/j8AABPi6+a0OqqVVK7MLyx2dbSXCE1s/T/ty3tPnKBOnYxRCgBUH/IfAIBpETubWObjLFxI8+ZpNqLPD8A8If8BAECFsI0bgMVB/gMAgPJhGzcAS4TrPwAAQBeG0Qx/339PLIvwB2AB0P8HAABl7d9Pr7+u2YgBXwALgvwHAADPYRs3AOuA8V8AACAiXdu45eQg/AFYJOQ/AAORKZTp2fKLmU/Sc+QyhdLY5QCoqVtXc6rf2LHEsiSRlPMAADBvGP8FMISs3IKYnSmJz/f1Cg+WxEeG+ro5GbcqALpxgxo31mxEnx+ApUP/HwDvZAqlevgjooQ06dydKegFBCNjGM3wh23cAKwD8h8A76RypXr44ySkSaVy5D8wEu21XU6eRPIDsB7IfwC8yyss1tmeX047AI8mTdKxpDPLUseOxqgGAIwD8/8AeCdytNfZ7lpOOwAv5HJyddVsRJ8fgFVC/x8A7yRCQXiw5nWU4cESiVBglHrAGjGMZvh79gzhD8BqIf8B8E7sLIiPDFWPgOHBksWRoWJn5D/gn/ZUv6++wjZuAFYO478AhuDr5rQ6qpVUrswvLHZ1tJcIBQh/wLtffqF33tFsRJ8fACD/ARiM2BmZDwwF27gBQIUw/gsAYFm0t3F7+BDhDwDUIf8BAFgKHx/NqX79+hHLkpeXkQoCABPFb/6bP38+oyYkJIRr79q1q3r7hAkTeC0DAMDCXb9ODEMPHpRpZFn6/XcjFQQAJo33+X9NmzY9dOjQfy9m9+Llxo0bt3DhQu5nZ2dnvssAALBYOtdzBgAoH+/5z87OztvbW7vd2dlZZzsAAFSWdvJLSqL27Y1RCgCYE97n/6Wlpfn6+tavX3/YsGGZmZmq9i1btkgkkmbNmsXGxioUCp2PLSoqylPDd6kAAGZjwgTd3X4IfwBQCfz2/7Vr127Tpk2NGjW6f//+ggULwsLCrl696urqOnTo0ICAAF9f35SUlJiYmNTU1F27dmk/PC4ubsGCBbxWCABgZvLzSSTSbMSALwBUBcMa6lsjNzc3ICBg+fLlY8aMUW8/cuRIRETErVu3goKCNB5SVFRUVFTE/ZyXl+fn5yeTyUTaX3wAAFZCu8/v2TPs5AFgbfLy8sRicU1CkeHWf3Fzc2vYsOGtW7c02tu1a0dE2u1E5ODgIFJjiCoBAEyT9jZuq1ZhGzcAqB7D5T+5XJ6enu7j46PRfunSJSLSbgcAACKibdt0T/WbMsUY1QCAJeB3/t/s2bP79+8fEBCQlZU1b948W1vbqKio9PT0rVu3vv766x4eHikpKTNmzAgPDw8NDeW1EgAA84Nt3ACAH/zmv3///TcqKurRo0eenp6dO3c+ffq0p6dnYWHhoUOHVq5c+fTpUz8/v8jIyI8//pjXMgAAzI92n192Nnl6GqMUALA0hrv+o4ZqPtURAMA8eHlRTk6ZljfeoD17jFQNAJicmoci3td/BgCAyrp2jZo21Ww0k7/SAcCMIP8BAPBLplBK5cq8wmKRk73ERSB2Fug+Dtu4AYChIP8BgNmrbMAyhqzcgpidKYlpUu5meLAkPjLU182pzEHYxg0ADKui/NeqVStG+1tJzYULF/RdDwBA1VQqYBmJTKFUr42IEtKkc3emrI5q9V9IHT+e1q3TfBi6/QCAZxXlv4EDBxqqDACA6nh5wDIqqVypXhsnIU0qlSvFJUXYxg0AjKWi/Ddv3jyD1QEAUA0VBSwTyH95hcU624Nqu2o2YRs3ADAgzP8DADNWXsDKL6fdwESO9hottxf30zzo//6PoqMNVBAAABFVcv+3kpKSpUuXvvrqq97e3rXU8F0cAEDFtAMWx7WcdgOTCAXhwRLu5zeuHdMOf8O/O501bLTB6wIAa1ep/LdgwYLly5e//fbbMpls5syZgwYNsrGxmT9/Ps+1AQC8hHrAUgkPlkiExh/8JSKxsyA+MjS8gcftxf1W/b5U/a56MX/Ui/mDm60oUyiNVSEAWKdK7f8RFBS0atWqvn37urq6Xrp0ibt5+vTprVu3GqBEDvb/AACdsnIL5u5MSVC7/ndxZKiPaVz/S6RjbZeOs7Zl2QnVWw7P7BLkJSQAgMox0P4fDx48aN68OREJhUKZTEZE/fr1++STT6r3kgAAeuTr5rQ6qpVUrswvLHZ1tJcITWb9P4mEHj1Sb8jt1bdly4naB5rIbEUAsB6VGv+tW7fu/fv3iSgoKOjvv/8mouTkZAcHB35LAwCoHLGzIMhL2NLfPchLaBLh7+pVYhiN8Ecs++iHbToPN5HZigBgPSqV/958883Dhw8T0ZQpUz755JPg4ODhw4ePHo05ywAAWhiGmjcv08Ky3MJ+Jj5bEQCsR6Xm/6k7ffr0qVOngoOD+/fvz1NNOmH+HwCYOu0Nk06fpnbt1BtMfbYiAJiDmoeiKuc/Y0H+AwDTNWAA7d2r2VjOtyu3W7HJzVYEAPNhoOs/4uLiateurT7g+/333+fk5MTExFTvVQEALERuLrm7azZW+He12BmZDwCMrFLz/7799tuQkBD1lqZNm65du5afkgAAzATDaIa/khLs4QsApq9S+e/Bgwc+Pj7qLZ6entwVwQAA1ohhNGf7xcURy5JNpb5UAQCMq1JfVX5+fidPnlRvOXnypK+vLz8lAQCYsLVrta/zkD0tSh89+WLmk/QcOTbzAADTV6n5f+PGjZs+fXpxcXG3bt2I6PDhw3PmzJk1axbPtQEAmBKd3Xssm5VbEPPzxUS1S3rjI0N9cUkvAJiwSuW/Dz744NGjR5MmTVIqlUTk6OgYExMTGxvLc20AACZDe22Xhw/Jy0umUMbsTFGFPyLitvRdHdUKF3kAgMmqwvovcrn8+vXrTk5OwcHBht/8A+u/AIBxaCe/jh3p+ZSY9Gx5xPLj2g/Clr4AwB8Drf/CEQqFbdu2rd7LAACYn/PnqU0bzcayfzPnlbN1L7b0BQBTVlH+GzRo0KZNm0Qi0aBBg3QesGvXLn6qAgAwNu1uP12jJaJytu7Flr4AYMoqyn9isZhhGCISiUSM9lchAIBF0v66S0igsDCdx3Jb+iaozf8jbOkLACYP+78BADzXrx/t26fZ+LIvSWzpCwAGZqD5f926ddu1a5ebm5v6Cw8cOPDIkSPVe1UAANNS9W3cVHzdnFZHtcKWvgBgRiqV/44dO8at/KJSWFiYmJjIT0kAAIalPeD77BnZ2lb+CbClLwCYl5fkv5SUFO6Ha9euPXjwgPu5pKTkr7/+qlOnDr+lAQDwTTv5ffklffCBMUoBADCcl+S/li1bMgzDMAy384eKk5PT6tWr+SwMAIBPa9ZQdLRmo5nMhwYAqKGX5L+MjAyWZevXr3/27FlPT0+uUSAQeHl52VZlcAQAzJdMoZTKlXmFxSIne4mL+Q90lrONmzFKAQAwjpfkv4CAgOLi4hEjRnh4eAQEBBimJgAwHVm5Ber7m5n95rbaA77Z2fT8j1sAACuh9UewFnt7+99++80ApQCAqSlvc1uZQlnBo0wUw2iGv06diGUR/gDACr08/xHRgAEDdu/ezXMlAGBypHJlYtmVjYkoIU0qlZtV/jtzRvdmHidOGKMaAADjq9T6L8HBwQsXLjx58mTr1q1dXFxU7VOnTuWtMAAwPkvY3LZy27gBAFiVSuW/DRs2uLm5nT9//vz586pGhmGQ/wAsm3lvbqud/I4fp/BwY5QCAGBaKpX/MjIy+K4DAEyQuW5u27UrHT+u2YhuPwCA5yo1/4+jVCpTU1OfPXvGXzUAYFLEzoL4yNDwYImqhdvc1nSXgHn8mBhGM/yxLMIfAIC6SvX/KRSKKVOmbN68mYhu3rxZv379KVOm1KlTZ+7cuTyXBwBGZk6b22oP+JaU6FjqDwDA6lXqmzE2Nvby5cvHjh1zdHTkWrp37/7LL7/wWRgAmAqxsyDIS9jS3z3IS2ii4U97bZfPPtO9zjMAAFSy/2/37t2//PJL+/btmeffsE2bNk1PT+ezMACASpg/nxYs0GzEaC8AQIUqlf9ycnK8vLzUW54+fcpoD7UAABhMaSlp70KJ5AcAUAmVGhxp06bNvn37uJ+52Pfdd9916NCBx7oAACrAMJrh7/59hD8AgEp6Sf/f1atXmzVrFhcX17t372vXrhUXF3/11VfXrl07derUce3lFQAA+KY98sAwVFpqjFIAAMzVS/r/QkND27Vrd+3atZMnTz579iw0NPTvv//28vJKSkpq3br1S599/vz5jJqQkBCuvbCwMDo62sPDQygURkZGPnz4UA9vBQAs299/697MA+EPAKCKXtL/d/z48Y0bN86aNau0tDQyMnLp0qXhVVw9v2nTpocOHfrvxez+e7kZM2bs27dv+/btYrF48uTJgwYNOnnyZDWqB9AgUyilcmVeYbHIyV7iYsIrlUBVYRs3AAD9eUn+CwsLCwsLW7169a+//rpp06auXbs2aNBgzJgxI0aM8Pb2rtQL2NlpHCmTyTZs2LB169Zu3boR0caNGxs3bnz69On27dtX+20AEFFWbkHMzpTE55tVhAdL4iNDfd2cjFsV1JR28tu7l/r3N0YpAAAWolLXf7i4uIwaNer48eM3b94cPHjw119/7e/v/8Ybb1TmsWlpab6+vvXr1x82bFhmZiYRnT9/vri4uHv37twBISEh/v7+SUlJ2o8tKirKU1PpNwXWSKZQqoc/IkpIk87dmSJTKI1YFdSIWKy72w/hDwCgZqq2OGqDBg0+/PDDjz/+2NXVVXVFcAXatWu3adOmv/7665tvvsnIyAgLC8vPz3/w4IFAIHBzc1MdVrt27QcPHmg/PC4uTvycn59flUoFayOVKxPLblNLRAlpUqkc+c8MPXxIDEMaf/VhGzcAAD2p1Pp/nISEhO+//37nzp02NjZDhgwZM2bMSx/Sp08f7gfuOpKAgIBff/3Vyamy43GxsbEzZ87kfs7Ly0MEhArkFRbrbM8vpx1Ml3af37NnOpb6AwCA6np5/19WVtYXX3zRsGHDrl273rp1a9WqVVlZWevXr6/qdD03N7eGDRveunXL29tbqVTm5uaq7nr48KHO2YQODg4iNVV6ObA2Ikd7ne2u5bSDKdLexm3CBGJZhD8AAP16Sf7r06dPQEDA6tWr33zzzevXr584cWLUqFEuLi7VeCW5XJ6enu7j49O6dWt7e/vDhw9z7ampqZmZmVhNGmpIIhSEB0s0GsODJRIhLgE2B9Om6Z7q9803xqgGAMDCvWT8197efseOHf369bOt1t/fs2fP7t+/f0BAQFZW1rx582xtbaOiosRi8ZgxY2bOnFmrVi2RSDRlypQOHTrg4l+oIbGzID4ydO7OlAS1638XR4ZiCRhTh23cAAAM7iX5b+/evTV59n///TcqKurRo0eenp6dO3c+ffq0p6cnEa1YscLGxiYyMrKoqKhXr15r1qypyasAcHzdnFZHtZLKlfmFxa6O9hIh1v8zedp9fvfuka+vMUoBALAiDGsmf2fn5eWJxWKZTIaJgACWQDv52duTEhdrAwC8XM1DUdXWfwEAqKm//tI91Q/hDwDAUKqw/gsAQE3pexs37PgHAFANyH8AYBDayW/fPnr99Zo8JXb8AwCoHoz/AgDPXFx0d/vVLPxhxz8AgGpD/gMA3jx4QAxDCkWZRj1t44Yd/wAAqg3jvwDAD+0+v5ISstHb35zY8Q9MB+ahgtlB/gMAfdNOfpMn0+rV+n0R7PgHJgLzUMEcYfzXcGQKZXq2/GLmk/QcOaYogWWaPFn3VD99hz/Cjn9gGjAPFcwU+v8MBH8ggoUz+DZu2PEPTEEF81DxUQRThvxnCOX9gbg6qhW+IMASaPf5ZWWRjw/fL4sd/8DoMA8VzBTynyHgD0SwWNrJz9GRCgoM9vpiZ2Q+MCbMQwUzhfl/hoA/EMEC7d+ve6qfAcMfgNFhHiqYKeQ/Q8AfiGBpGEZz9WY9reoHYF64eajqERDzUMEsYPzXELg/EBPKDgHjD0QwS9p9fvv3U+/exigFwCRgHiqYI+Q/Q8CFimAJHB2pqEizEX1+AJiHCmYI+c9A8AcimLGHD8nbW7MRyQ8AwGwh/xkO/kAEs8TzNm4AAGB4+BIHgHIwjGb4mzKFWNbswh+23gEA0ID+PwDQEh9PsbGajeY54IutdwAAtJnZ3/EAwK/SUmIYzfBntmu7YG9WAACdkP8A4DmG0dzDNzvbTJMfp4Ktd4xSDwCAiUD+AwBdU/06diSWJU9PIxWkH9h6BwBAJ+Q/AOt24oTubdxOnjRGNXqGrXcAAHTC9R8AVkxn8rMg2HoHAEAn9P8BWCXtAd9Tpyws/BH2ZgUAKAf6/wCsTJs2dP68ZqPFJT8VbL0DAKAN+Q/AauTkkJeXZqPlJj8VbL0DAKAB+Q/AOmAbNwAAeA7f/gCWTnuq35Il5riNmzZs7AYAUD3o/wOwXP/3fzRlimajpQz4YmM3AIBqM/sOAADQgdvGTSP8me02btqwsRsAQE0g/wFYHO1t3J48sZjkx8HGbgAANYH8B2BBtKf6RUYSy5Kbm3Hq4Q02dgMAqAnM/wOwCMePU9eumo2W1eenDhu7AQDUBPIfgPmz9G3ctGFjNwCAmsD4L4A50x7wTUqy+PBH2NgNAKBm0P8HYJ5eeYUuXtRstILkp4KN3QAAqg35D8DcPHxI3t6ajdaU/FSwsRsAQPUg/wGYFe2pftxSfwAAAJWG+X8AZkJ7qt+yZcSyCH8AAFBVyH8AJm/RIt1X+M6caYxqAADA7GH8F8CElZSQndb/pFY51Q8AAPQI/X8ApophNMPfo0cIfwAAUHPIfwCmR3uqX9euxLJUq5aRCgIAAIuC8V8AU3LsGL32mmYj+vwAAECvDNT/Fx8fzzDM9OnTuZtdu3Zl1EyYMMEwZQCYNIbRDH8si/AHAAB6Z4j+v+Tk5G+//TY0NFS9cdy4cQsXLuR+dnZ2NkAZAKZL+/LeM2fo1VeNUQoAAFg+3vv/5HL5sGHD1q9f7+7urt7u7Ozs/ZxIJNL52KKiojw1fJcKYAQtW+pe2wXhDwAAeMN7/ouOju7bt2/37t012rds2SKRSJo1axYbG6tQKHQ+Ni4uTvycn58f36UCGNTDh8QwdPlymUYM+AIAAP/4Hf/dtm3bhQsXkpOTNdqHDh0aEBDg6+ubkpISExOTmpq6a9cu7YfHxsbOfL7CbV5eHiIgWA5s4wYAAMbDY/67e/futGnTDh486OjoqHHX+++/z/3QvHlzHx+fiIiI9PT0oKAgjcMcHBwcHBz4qxDACLRD3ooV9PzSKAAAAAPgcfz3/Pnz2dnZr7zyip2dnZ2d3fHjx1etWmVnZ1dSUqJ+WLt27Yjo1q1b/FUCYBIWLtQ91Q/hDwAADIvH/r+IiIgrV66obo4aNSokJCQmJsbW1lb9sEuXLhGRj48Pf5UAGBm2cQMAAFPCY/5zdXVt1qyZ6qaLi4uHh0ezZs3S09O3bt36+uuve3h4pKSkzJgxIzw8XGN1GADLod3n9/gxlb0cHgAAwJCMsP+bQCA4dOhQz549Q0JCZs2aFRkZ+fvvvxu+DADeaW/j1q0bsSzCHwAAGBfDmskgVF5enlgslslk5S0WCGBCjh6lbt00G83k/zUAADBxNQ9F2P8XQN90XuQBAABgMoww/gtgsbQHfM+eRfgDAABTg/4/AH1o1oz+9z/NRiQ/AAAwSch/AC/IFEqpXJlXWCxyspe4CMTOgpc/5sED0l69CMkPAABMGPIfwH+ycgtidqYkpkm5m+HBkvjIUF83p4oeg23cAADADGH+HwARkUyhVA9/RJSQJp27M0WmUOp+gPZUv6++IpZF+AMAANOH/AdARCSVK9XDHychTSqVa+W/+fN1X+E7dSpv1QEAAOgTxn8BiIjyCot1tuert2MbNwAAsAjo/wMgIhI52utsd1W1M4xm+HvyBOEPAADMEfIfABGRRCgID5ZoNIYHSyRCgY6pft27E8uSm5vBygMAANAj5D8AIiKxsyA+MlQ9AoYHS1ZIHoldHDQPZVk6eNCgxQEAAOgV5v8B/MfXzWl1VCupXJlfWOzqaB9U21XzCIz2AgCARUD+A3hB7CwQOwt0XN579iy1bWuMigAAAPQP478Aarp10722C8IfAABYEPT/ARARUXY21a6t2YgBXwAAsETIfwDYxg0AAKwLxn/Bummt7bJu1MdZTxQIfwAAYMGQ/8BaLVumHfLqxfzxhVf7irb9BQAAMH8Y/wXro2sbt3oxf6h+5rb9FTsLDFsWAACAgSD/gZXR6vNrNv1XuYOzRmN+OdsBmyCZQimVK/MKi0VO9hIXAWIrAAC8FPIfWA3tKX3vvpu+7Bv58uPax7qWsx2wqcnKLYjZmZKYJuVuhgdL4iNDfd2cjFsVAACYOMz/A97JFMr0bPnFzCfpOXLjzKs7cUL3qn4//ljRtr8mT6ZQqoc/IkpIk2LyIgAAvBT6/4Bfxu+g0pn8nuO2/Z27MyVBrcLFkaFmMYoqlSvVwx8HkxcBAOClkP+AR+V1UK2OamWIgKKd/FJSqHlzVW2qaXNLBrd4WvQsr6DY1dFeIjSbKXR55UxSNKPJiwAAYBTIf8Ajo3VQvfYaHTtWpkUgoKIi1S2dvZL1PYU8lsQDUTmTFM1l8iIAABgL5v8Bj4zQQfXwITGMZvhjWfXwZzHT5vibvGj8KZsAAMAn9P8BjwzdQVW5bdwsZtocT5MXjT9lEwAAeIb8BzziOqgSyoYtXq6u1U5+P/xA772n81hLmjbn6+a0OqqVVK7ML9TP5EUjT9kEAACDwPgv8IjroFIfo9T/1bXr1um+wrec8EcWN21O7CwI8hK29HcP8hLW/MRW0Dlaw2cGAADTgf4/4JfeO6he0LWNm/raLuUxXK+kGbKkzlEAACgP+v+Ad/rtoPoPw2iGv/z8yoQ/MkyvpNmysM5RAADQCf1/YG6cnKiwsEzL7Nm0ZEmVnoPHXkkzh85RAABrgPwH5iM5mV59VbOxcn1+2sTOyHw6mPWGKAAAUEnIf2AmKtzGDfQInaMAABYP+Q9MnnbyS02lhg2NUYq1QOcoAIBlw/UfYMKiojTDX5MmxLIIfwAAADWB/j8wSVIpeXpqNmLAFwAAQB+Q/8D0VG4bNwAAAKgejP+CKWEYzZy3ezexLMIfAACAHiH/gWn49lvdV/gOGGCMagAAACwZxn/B2Kq7jRsAAABUD/If8EimUErlyrzCYpGTvcRF15Ii2n1+cjm5uBimPAAAAOuE/Ad8ycotiNmZkqi2jUR8ZKivm9N/dwsEVFxc5gEffEBffmnYGgEAAKwR5v8BL2QKpXr4I6KENOncnSkyhZLOniWG0Qx/LIvwBwAAYBgGyn/x8fEMw0yfPp27WVhYGB0d7eHhIRQKIyMjHz58aJgywGCkcqV6+OMkpEnFLg7Url2ZVpbFbD8AAABDMkT+S05O/vbbb0NDQ1UtM2bM+P3337dv3378+PGsrKxBgwYZoAwwpLzCYo2W24v73V7cr0zTzZtIfgAAAIbHe/6Ty+XDhg1bv369u7s71yKTyTZs2LB8+fJu3bq1bt1648aNp06dOn36NN+VgCGJHO1VP79/Zqdm8mvenFiWgoMNXRYAAAAYIP9FR0f37du3e/fuqpbz588XFxerWkJCQvz9/ZOSkrQfW1RUlKeG71JBjyRCQXiwxFlZcHtxvw+PbVS/6+Kdx+mHT8kUSmPVBgAAYOX4vf5327ZtFy5cSE5OVm988OCBQCBwc3NTtdSuXfvBgwfaD4+Li1uwYAGvFQJPxM6CH8a212h8b11SYvojWnOKtC8HBgAAAEPhsf/v7t2706ZN27Jli6OjY/WeITY2Vvbc3bt39Vse8KhHD42F/e7/dfS99acT0x+pWl5cDgwAAACGxWP+O3/+fHZ29iuvvGJnZ2dnZ3f8+PFVq1bZ2dnVrl1bqVTm5uaqjnz48KG3t7f2Mzg4OIjU8Fcq6M3p08QwdOjQi5bhw4llFa3aJN7ScTmwVI78BwAAYGg8jv9GRERcuXJFdXPUqFEhISExMTF+fn729vaHDx+OjIwkotTU1MzMzA4dOvBXCRhCaSnZ2mo2Pr+8V/tyYE5+Oe0AAADAHx7zn6ura7NmzVQ3XVxcPDw8uJYxY8bMnDmzVq1aIpFoypQpHTp0aN9ec64YmBPtbdyKikjwYrc39cuB1bmW0w4AAAD8Mc7+HytWrOjXr19kZGR4eLi3t/euXbuMUgbowdy5muHvzz+JZdXDHz2/HFjjoeHBEolQa0dgAAAA4BnDmskCvHl5eWKxWCaTYSKgqcjMpICAMi0NG1JqanmHZ+UWzN2ZkqC2HfDiyFAfXP8LAABQRTUPRfyu/wIWS3vA92V/SPi6Oa2OaiWVK/MLi10d7SVCgdgZnX/6JFMopXJlXmGxyMle4oLTCwAA5UL+gyoSCKi47EUbUil5eFTmoWJnhBK+ZOUWxOxMSVTrXsXyigAAUB7jzP8Ds/TTT8QwZcLfypXEspUMf8AfmUKpHv4IyysCAECF0P8HlSCXk6urZqOZzBy1BlK5Uj38cbjlFdHhCgAA2pD/4GW0p/qVlupoBOPB8ooAAFAlGP+F8kVEaOa8//2PWBbhz9RgeUUAAKgS5D/QJSmJGIaOHHnRMmIEsSw1aWK8mqBcWF4RAACqBOO/UFaF27iBaRI7C+IjQ7WXV8TkPwAA0An5D9S8bBs3MFlYXhEAACoP479AREQxMZrhb/9+7W3cwJSJnQVBXsKW/u5BXkKEPwAAqAD6/6zenTtUr16ZlpAQun7dOMUAAAAA/5D/rFvVt3EDAAAAc4fxX2tlb68Z/qRShD8AAABrgPxnfX74gRiGnj170YJt3AAAAKwJxn/Ng0yhlMqVeYXFIid7iUt1L+3MzyeRSLMRfX4WTT+fHMMyx5oBAMwL8p8ZyMotiNmZkqi2tFt8ZKivm1PVngXbuFWX+cYR/XxyDMscawYAMDsY/zV1MoVS/Z9DIkpIk87dmSJTKCv7FN26aea8a9ewjVslZeUWTP75YsTy42+uORWx7PiUny9m5RYYu6hK0cMnx+DMsWYAAHOE/GfqpHKl+j+HnIQ0qVReiX8RT50ihqGjR1+0jBpFLEuNG+u1Rotl1nGkRp8cIzHHmgEAzBHGf01dXmGxzvb8ctr/g23c9KGCOGL6o8DV/OQYlTnWDABgjtD/Z+pEjvY6213LaSciYhjN8KdUIvxVg1nHkep8cozNHGsGADBHyH+mTiIUhAdLNBrDgyUSoa7+J+1t3P76i1iW7PHPZ3WYdRyp2ifHNJhjzQAA5gj5z9SJnQXxkaHq/yiGB0sWR4Zqjj/euUMMQ19++aKlaVNiWerVy1CVWiCzjiOV/eSYEnOsGQDAHDGsmQwL5uXlicVimUwm0l7BzgpwS5DkFxa7OtpLhFpLkGAbN95k5RbM3ZmSoLYcyeLIUB/zWY7kJZ8ck2SONQMAGFLNQxHyn5mzsdGMeo8eUa1aRqrGMiGOAACASal5KML4r9nitnFTD39ffUUsi/Cnd2JnQZCXsKW/e5CXEOEPAAAsANZ/MUPYxg0AAABqAPnP3GAbNwAAAKgZjP+aj65dNXPe9evYxg0AAACqCvnPHFy7RgxDx4+/aBkzhliWQkKMVxMAAACYK4z/mjZs4wYAAAD6hv4/E1a7tmb4Ky5G+AMAAIAaQv4zSevXE8NQdvaLlvPniWXJDv21AAAAUFPIEybm4UPy9i7TMmECffONkaoBAAAAC4T8Z0qwjRsAAADwD+O/pqFPH83wl5eH8AcAAAB8QP4ztoMHiWHor79etOzdSyxLrq7Gq8mcyBTK9Gz5xcwn6TlymUJp7HIAAADMAMZ/jUepJAeHMi0dO9LJk0aqxixl5RbE7ExJTJNyN8ODJfGRob5uTsatCgAAwMSh/89IBg3SDH8si/BXJTKFUj38EVFCmnTuzhT0AgIAAFQM+c/gduwghqHffnvRcvcupvpVg1SuVA9/nIQ0qVSO/AcAAFARjP8aUEEBOTuXaTl0iCIijFSN2csrLNbZnl9OOwAAAHDQ/2cQLEs7dpQJf5MmEcsi/NWEyNFeZ7trOe0AAADAQf7j3+XL1K0bDR78300vLyopoa+/NmpNlkAiFIQHSzQaw4MlEqHAKPUAAACYC+Q/PkmlNHEivfIKHTtGjo40bx49fUoPH5INTrseiJ0F8ZGh6hEwPFiyODJU7Iz8BwAAUBHM/+NHcTGtWUPz51NuLhHR22/Tl1+Sv7+Rq7I4vm5Oq6NaSeXK/MJiV0d7iVCA8AcAAPBS/HZEffPNN6GhoSKRSCQSdejQYf/+/Vx7165dGTUTJkzgtQxDO3CAQkNp+nTKzaVWrSghgbZt0w5/WLhYL8TOgiAvYUt/9yAvIcIfAABAZfDb/1e3bt34+Pjg4GCWZTdv3jxgwICLFy82bdqUiMaNG7dw4ULuMGeNq2LNV1oazZpFv/9OROTpSV98QaNGka2t9oFYuBgAAACMhd/+v/79+7/++uvBwcENGzb8/PPPhULh6dOnubucnZ29nxOJRLyWYQh5eTRnDjVtSr//TnZ2NHMm3bxJY8fqDH9YuBgAAACMyEAXIpSUlGzbtu3p06cdOnTgWrZs2SKRSJo1axYbG6tQKHQ+qqioKE+NYUqtstJS+v57atiQliyh4mLq04euXqVly8jNrbxHYOFiAAAAMCLer/+4cuVKhw4dCgsLhULhb7/91qRJEyIaOnRoQECAr69vSkpKTExMamrqrl27tB8bFxe3YMECviuskVOnaOpUOn+eiKhhQ1qxgl5//aUPwsLFAAAAYEQMy/POY0qlMjMzUyaT7dix47vvvjt+/DgXAVWOHDkSERFx69atoKAgjccWFRUVFRVxP+fl5fn5+clkMlMZLP73X4qJoa1biYhEIpo3jyZPJkGlrj9Iz5ZHLD+u3X54ZpcgL6F+ywQAAAALk5eXJxaLaxKKeB//FQgEDRo0aN26dVxcXIsWLb766iuNA9q1a0dEt27d0n6sg4ODSA3fpVZWQQEtWkSNGtHWrcQwNG4cpaXRzJmVDH+EhYsBAADAqAy6EHFpaamqP0/l0qVLROTj42PISqqJ28atcWP69FNSKKhzZzp3jtatIy+vKj0NFi4GAAAAI+J3/l9sbGyfPn38/f3z8/O3bt167NixAwcOpKenb9269fXXX/fw8EhJSZkxY0Z4eHhoaCivlejB5cs0bRodP05E5OdHS5bQkCHEMNV7MixcDAAAAMbCb/7Lzs4ePnz4/fv3xWJxaGjogQMHevTocffu3UOHDq1cufLp06d+fn6RkZEff/wxr2XUVE4OffIJrV9PpaXk5EQxMfTBB1TjNQvFzsh8eiNTKKVyZV5hscjJXuKCEwsAAFAR3q//0JeaT3WsDmzjZg6wmDYAAFgVM7j+w4xVbhs3MC4spg0AAFBVyH+6pKVR//7UuzfduEGenrR+PSUnU1iYscsCHbCYNgAAQFUh/5Ull/+3jdsff7x0GzcwBVhMGwAAoKp43//DzJSW0ubNVFxMr79Oy5dTo0bGLgheQuRor7PdtZx2AAAAQP4rSySitWvJwaEy27iBKeAW004oOwSMxbQBAAAqgPFfLW++ifBnRrCYNgAAQFWh/w/MHhbTBgAAqBLkP7AEWEwbAACg8jD+CwAAAGBdkP8AAAAArAvyHwAAAIB1wfy/MmQKpVSuzCssFjnZS1wwpQwAAAAsEPLfC1m5Beo7yYYHS+IjQ33dnIxbFQAAAIB+Yfz3PzKFUj38EVFCmnTuzhSZAtvIAgAAgEVB/vuPVK5MLLuHBBElpEmlcuQ/AAAAsCjIf//JKyzW2Z5fTjsAAACAmUL++4/I0V5nu2s57QAAAABmCvnvPxKhQH0PWU54sEQixCXAAAAAYFGQ//4jdhbER4aqR8DwYMniyFAsAQMAAAAWBuu/vODr5rQ6qpVUrswvLHZ1tJcIsf4fAAAAWCDkvzLEzsh8AAAAYOEw/gsAAABgXZD/AAAAAKwL8h8AAACAdUH+AwAAALAuyH8AAAAA1gX5DwAAAMC6IP8BAAAAWBfkPwAAAADrgvwHAAAAYF2Q/wAAAACsC/IfAAAAgHVB/gMAAACwLsh/AAAAANYF+Q8AAADAutgZu4DKYlmWiPLy8oxdCAAAAIAxcXGIi0bVYzb5Lz8/n4j8/PyMXQgAAACA8eXn54vF4uo9lqlJeDSk0tLSrKwsV1dXhmGMXUs15eXl+fn53b17VyQSGbsWI8Op4OA8qOBUcHAeVHAqODgPKjgVHO48ZGZmMgzj6+trY1PNiXxm0/9nY2NTt25dY1ehByKRyMo/uyo4FRycBxWcCg7OgwpOBQfnQQWngiMWi2t4HnD9BwAAAIB1Qf4DAAAAsC7If4bj4OAwb948BwcHYxdifDgVHJwHFZwKDs6DCk4FB+dBBaeCo6/zYDbXfwAAAACAXqD/DwAAAMC6IP8BAAAAWBfkPwAAAADrgvwHAAAAYF2Q/3gRHx/PMMz06dO5m4WFhdHR0R4eHkKhMDIy8uHDh6ojMzMz+/bt6+zs7OXl9cEHHzx79sw4FfND4zx07dqVUTNhwgTVkRZ5HubPn6/+fkNCQrh2K/w8lHcqrO0jQUT37t179913PTw8nJycmjdvfu7cOa6dZdlPP/3Ux8fHycmpe/fuaWlpqoc8fvx42LBhIpHIzc1tzJgxcrncSLXrWXmnYuTIkeqfit69e6seYnmnol69ekxZ0dHRZJXfEuWdCmv7ligpKfnkk08CAwOdnJyCgoIWLVqkuk5Xz98SLOjb2bNn69WrFxoaOm3aNK5lwoQJfn5+hw8fPnfuXPv27Tt27Mi1P3v2rFmzZt27d7948eKff/4pkUhiY2ONVre+aZ+HLl26jBs37v5zMpmMa7fU8zBv3rymTZuq3m9OTg7XboWfh/JOhbV9JB4/fhwQEDBy5MgzZ878888/Bw4cuHXrFndXfHy8WCzevXv35cuX33jjjcDAwIKCAu6u3r17t2jR4vTp04mJiQ0aNIiKijLeO9CbCk7FiBEjevfurfpUPH78WPUoyzsV2dnZqnd68OBBIjp69Chrld8S5Z0Ka/uW+Pzzzz08PP7444+MjIzt27cLhcKvvvqKu0u/3xLIf3qWn58fHBx88ODBLl26cLknNzfX3t5++/bt3AHXr18noqSkJJZl//zzTxsbmwcPHnB3ffPNNyKRqKioyEi165P2eWBZVv1ndZZ6HubNm9eiRQuNRuv8POg8Faz1fSRiYmI6d+6s3V5aWurt7b1kyRLuZm5uroODw88//8yy7LVr14goOTmZu2v//v0Mw9y7d89gNfOkvFPBsuyIESMGDBig3W6pp0Jl2rRpQUFBpaWl1vktoU51Kljr+5bo27fv6NGjVTcHDRo0bNgwlodvCYz/6ll0dHTfvn27d++uajl//nxxcbGqJSQkxN/fPykpiYiSkpKaN29eu3Zt7q5evXrl5eX973//M3zZeqd9HjhbtmyRSCTNmjWLjY1VKBRcowWfh7S0NF9f3/r16w8bNiwzM5Os9fNAuk4Fx6o+Env37m3Tps3gwYO9vLxatWq1fv16rj0jI+PBgweqT4VYLG7Xrp3qU+Hm5tamTRvuru7du9vY2Jw5c8Yo9etReaeCc+zYMS8vr0aNGk2cOPHRo0dco6WeCo5Sqfzpp59Gjx7NMIzVfktw1E8F12JV3xIdO3Y8fPjwzZs3iejy5csnTpzo06cP8fAtYcfjm7A+27Ztu3DhQnJysnrjgwcPBAKBm5ubqqV27doPHjzg7lJ9drl2rtFA5fJG53kgoqFDhwYEBPj6+qakpMTExKSmpu7atYss9zy0a9du06ZNjRo1un///oIFC8LCwq5evWqFnwcq51S4urpa20fin3/++eabb2bOnPnhhx8mJydPnTpVIBCMGDGCe2sab1n1qfDy8lK129nZ1apVy4JPBRH17t170KBBgYGB6enpH374YZ8+fZKSkmxtbS31VHB2796dm5s7cuRIssp/NdSpnwqyvn845s6dm5eXFxISYmtrW1JS8vnnnw8bNoyevzU9fksg/+nN3bt3p02bdvDgQUdHR2PXYkwVnIf333+f+6F58+Y+Pj4RERHp6elBQUEGr9FAuD/aiCg0NLRdu3YBAQG//vqrk5OTcasyCp2nYsyYMdb2kSgtLW3Tps0XX3xBRK1atbp69eratWu50GNtKjgV77zzDndM8+bNQ0NDg4KCjh07FhERYcxy+bdhw4Y+ffr4+voauxDj0zgV1vYt8euvv27ZsmXr1q1Nmza9dOnS9OnTfX19+fiWwPiv3pw/fz47O/uVV16xs7Ozs7M7fvz4qlWr7OzsateurVQqc3NzVUc+fPjQ29ubiLy9vdWv6uJ+5u4yX+Wdh5KSEvXD2rVrR0S3bt0iCz0PGtzc3Bo2bHjr1i1vb2+r+jxoU50KjXZr+Ej4+Pg0adJEdbNx48bcUDj31jTesupTkZ2drWp/9uzZ48ePLfhUaKhfv75EIlF9KizyVBDRnTt3Dh06NHbsWO6mNX9LaJwKDdbwLfHBBx/MnTv3nXfead68+XvvvTdjxoy4uDji4VsC+U9vIiIirly5cum5Nm3aDBs2jPvB3t7+8OHD3GGpqamZmZkdOnQgog4dOly5ckX1azt48KBIJFL/TjRH5Z0HW1tb9cMuXbpERD4+PmSh50GDXC5PT0/38fFp3bq1VX0etKlOhUa7NXwkOnXqlJqaqrp58+bNgIAAIgoMDPT29lZ9KvLy8s6cOaP6VOTm5p4/f56768iRI6Wlpdy/gmatvFOh4d9//3306JHqU2GRp4KINm7c6OXl1bdvX+6mNX9LaJwKDdbwLaFQKGxsXmQzW1vb0tJS4uNbgpfLV6DsJUsTJkzw9/c/cuTIuXPnOnTo0KFDB66du3y9Z8+ely5d+uuvvzw9PS3j8nV1qvNw69athQsXnjt3LiMjY8+ePfXr1w8PD+eOsdTzMGvWrGPHjmVkZJw8ebJ79+4SiSQ7O5u1ys+DzlNhhR+Js2fP2tnZff7552lpaVu2bHF2dv7pp5+4u+Lj493c3Pbs2ZOSkjJgwACNlR1atWp15syZEydOBAcHW8CiJ2z5pyI/P3/27NlJSUkZGRmHDh165ZVXgoODCwsLuUdZ5KkoKSnx9/ePiYlRb7TCbwlW16mwwm+JESNG1KlTh1v/ZdeuXRKJZM6cOdxd+v2WQP7ji3r+KygomDRpkru7u7Oz85tvvnn//n3VYbdv3+7Tp4+Tk5NEIpk1a1ZxcbFxyuWN6jxkZmaGh4fXqlXLwcGhQYMGH3zwgWoZJ9ZCz8Pbb7/t4+MjEAjq1Knz9ttvq5Y3s8LPg85TYYUfCZZlf//992bNmjk4OISEhKxbt07VXlpa+sknn9SuXdvBwSEiIiI1NVV116NHj6KiooRCoUgkGjVqVH5+vjEK1z+dp0KhUPTs2dPT09Pe3j4gIGDcuHGqBT5YCz0VBw4cICL13zhrld8SrK5TYYXfEnl5edOmTfP393d0dKxfv/5HH32kWtRGv98SDPt8XWkAAAAAsAaY/wcAAABgXZD/AAAAAKwL8h8AAACAdUH+AwAAALAuyH8AAAAA1gX5DwAAAMC6IP8BAAAAWBfkPwAAAADrgvwHAFCR+fPnt2zZ8qWHde3adfr06bxXAwCgD8h/AGClmHLMnz9f/bDZs2er9lwHALAMdsYuAADAOO7fv8/98Msvv3z66aepqancTaFQyP3AsmxJSYlQKFS1AABYBvT/AYCV8n5OLBYzDMP9fOPGDVdX1/3797du3drBweHEiRPq478jR44cOHDgggULPD09RSLRhAkTlEql9jMXFRXNnj27Tp06Li4u7dq1O3bsmCHfFwDAS6H/DwBA09y5c5cuXVq/fn13d3eN9Hb48GFHR8djx47dvn171KhRHh4en3/+ucbDJ0+efO3atW3btvn6+v7222+9e/e+cuVKcHCw4d4AAECF0P8HAKBp4cKFPXr0CAoKqlWrlsZdAoHg+++/b9q0ad++fRcuXLhq1arS0lL1AzIzMzdu3Lh9+/awsLCgoKDZs2d37tx548aNBiwfAOAl0P8HAKCpTZs25d3VokULZ2dn7ucOHTrI5fK7d+8GBASoDrhy5UpJSUnDhg1VLUVFRR4eHvxVCwBQVch/AACaXFxcqv1YuVxua2t7/vx5W1tbVSOuIAEAk4L8BwBQBZcvXy4oKHByciKi06dPC4VCPz8/9QNatWpVUlKSnZ0dFhZmpBoBAF4C8/8AAKpAqVSOGTPm2rVrf/7557x58yZPnmxjU+aLtGHDhsOGDRs+fPiuXbsyMjLOnj0bFxe3b98+YxUMAKAN/X8AAFUQERERHBwcHh5eVFQUFRWlsVg0Z+PGjZ999tmsWbPu3bsnkUjat2/fr18/g1cKAFAuhmVZY9cAAGAeRo4cmZubu3v3bmMXAgBQIxj/BQAAALAuyH8AAAAA1gXjvwAAAADWBf1/AAAAANYF+Q8AAADAuiD/AQAAAFgX5D8AAAAA64L8BwAAAGBdkP8AAAAArAvyHwAAAIB1Qf4DAAAAsC7/D9nr3fuDQOPcAAAAAElFTkSuQmCC"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-5",
            "pill": "Compute-R2",
            "label": "Compute R^2 score",
            "geometry": {
              "x": 510.0,
              "y": 360.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 720.0,
              "y": 500.0,
              "width": 400.0,
              "height": 60.0
            },
            "function_name": "compute_compute_r2",
            "function_result_var": "compute_r2_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "r_squared is a float.",
                      "r_squared represents the coefficient of determination for the linear regression model calculated using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                      "The regression model is defined by the slope and intercept in compute_slope_result."
                    ],
                    "algorithm": [
                      "Extract the slope and intercept from compute_slope_result.",
                      "Define a function to compute the predicted vertical values given a triple value using the equation: predicted_vertical = (slope * triple) + intercept.",
                      "Apply the function across the 'triple' column of clean_jumps_result to calculate predicted values for each row, resulting in a new column called 'predicted_vertical'.",
                      "Compute the total sum of squares (SST) as the sum of squared differences between each actual 'vertical' value in clean_jumps_result and the mean of the 'vertical' column.",
                      "Compute the sum of squares of residuals (SSR) as the sum of squared differences between each predicted 'predicted_vertical' value and the actual 'vertical' values in clean_jumps_result.",
                      "Calculate the R^2 score using the formula: r_squared = 1 - (SSR/SST).",
                      "Return r_squared."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_compute_r2(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> float:",
                      "    # Extract slope and intercept",
                      "    slope, intercept = compute_slope_result",
                      "",
                      "    # Calculate predicted vertical values",
                      "    clean_jumps_result['predicted_vertical'] = clean_jumps_result['triple'].apply(lambda x: slope * x + intercept)",
                      "",
                      "    # Compute total sum of squares (SST)",
                      "    vertical_mean = clean_jumps_result['vertical'].mean()",
                      "    sst = ((clean_jumps_result['vertical'] - vertical_mean) ** 2).sum()",
                      "",
                      "    # Compute sum of squares of residuals (SSR)",
                      "    ssr = ((clean_jumps_result['vertical'] - clean_jumps_result['predicted_vertical']) ** 2).sum()",
                      "",
                      "    # Calculate R^2 score",
                      "    r_squared = 1 - (ssr / sst)",
                      "",
                      "    return r_squared"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "r_squared is a float.",
              "r_squared represents the coefficient of determination for the linear regression model calculated using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
              "The regression model is defined by the slope and intercept in compute_slope_result."
            ],
            "description": "This computation step calculates the R^2 score (coefficient of determination) for the linear regression model determined by the given slope and intercept. The score provides a measure of how well the independent variable 'triple' predicts the dependent variable 'vertical'. The R^2 score is a value between 0 and 1, where a higher value indicates a better fit of the regression model to the data.",
            "function_return_type": {
              "type": "float"
            },
            "function_computed_value": "The R^2 score of the regression model.",
            "algorithm": [
              "Extract the slope and intercept from compute_slope_result.",
              "Define a function to compute the predicted vertical values given a triple value using the equation: predicted_vertical = (slope * triple) + intercept.",
              "Apply the function across the 'triple' column of clean_jumps_result to calculate predicted values for each row, resulting in a new column called 'predicted_vertical'.",
              "Compute the total sum of squares (SST) as the sum of squared differences between each actual 'vertical' value in clean_jumps_result and the mean of the 'vertical' column.",
              "Compute the sum of squares of residuals (SSR) as the sum of squared differences between each predicted 'predicted_vertical' value and the actual 'vertical' values in clean_jumps_result.",
              "Calculate the R^2 score using the formula: r_squared = 1 - (SSR/SST).",
              "Return r_squared."
            ],
            "code": [
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_compute_r2(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> float:",
              "    # Extract slope and intercept",
              "    slope, intercept = compute_slope_result",
              "",
              "    # Calculate predicted vertical values",
              "    clean_jumps_result['predicted_vertical'] = clean_jumps_result['triple'].apply(lambda x: slope * x + intercept)",
              "",
              "    # Compute total sum of squares (SST)",
              "    vertical_mean = clean_jumps_result['vertical'].mean()",
              "    sst = ((clean_jumps_result['vertical'] - vertical_mean) ** 2).sum()",
              "",
              "    # Compute sum of squares of residuals (SSR)",
              "    ssr = ((clean_jumps_result['vertical'] - clean_jumps_result['predicted_vertical']) ** 2).sum()",
              "",
              "    # Calculate R^2 score",
              "    r_squared = 1 - (ssr / sst)",
              "",
              "    return r_squared"
            ],
            "result": {
              "result": {
                "pickle": "gASVagAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCFohBjIzRuY/lIaUUpQu\n",
                "text": "0.6960693337469295\n"
              },
              "output": {
                "output_type": "text",
                "data": "0.6960693337469295\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-6",
            "pill": "Plot-Residuals",
            "label": "Plot Residuals",
            "geometry": {
              "x": 440.0,
              "y": 500.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 550.0,
              "y": 670.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_plot_residuals",
            "function_result_var": "plot_residuals_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "Residuals are computed as the difference between the actual values in the 'vertical' column and the predicted values based on the regression line from compute_slope_result.",
                      "A scatter plot of the residuals versus the 'triple' values from clean_jumps_result is generated.",
                      "The plot includes labels for the axes with 'Triple' on the x-axis and 'Residuals' on the y-axis."
                    ],
                    "algorithm": [
                      "Extract the slope and intercept from compute_slope_result.",
                      "Compute predicted vertical values using the formula: predicted_vertical = slope * triple + intercept for each row in clean_jumps_result.",
                      "Compute residuals as the difference between actual vertical values and predicted vertical values for each row.",
                      "Initialize a scatter plot.",
                      "Plot triple values on the x-axis and calculated residuals on the y-axis.",
                      "Label the x-axis as 'Triple' and the y-axis as 'Residuals'.",
                      "Display the plot."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import matplotlib.pyplot as plt",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_plot_residuals(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
                      "    slope, intercept = compute_slope_result",
                      "    # Calculate predicted vertical values",
                      "    predicted_vertical = slope * clean_jumps_result['triple'] + intercept",
                      "    # Calculate residuals",
                      "    residuals = clean_jumps_result['vertical'] - predicted_vertical",
                      "    # Create the scatter plot",
                      "    plt.figure()",
                      "    plt.scatter(clean_jumps_result['triple'], residuals)",
                      "    plt.xlabel('Triple')",
                      "    plt.ylabel('Residuals')",
                      "    plt.draw()",
                      "    return None"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "Residuals are computed as the difference between the actual values in the 'vertical' column and the predicted values based on the regression line from compute_slope_result.",
              "A scatter plot of the residuals versus the 'triple' values from clean_jumps_result is generated.",
              "The plot includes labels for the axes with 'Triple' on the x-axis and 'Residuals' on the y-axis."
            ],
            "description": "This step involves calculating the residuals based on the linear regression model obtained from the previous computation. The residuals are the differences between the actual 'vertical' values and the predicted values obtained using the slope and intercept from compute_slope_result. These residuals are then plotted in a scatter plot with 'triple' values on the x-axis, helping visualize any patterns or randomness in the residuals.",
            "function_return_type": {
              "type": "None"
            },
            "function_computed_value": "None",
            "algorithm": [
              "Extract the slope and intercept from compute_slope_result.",
              "Compute predicted vertical values using the formula: predicted_vertical = slope * triple + intercept for each row in clean_jumps_result.",
              "Compute residuals as the difference between actual vertical values and predicted vertical values for each row.",
              "Initialize a scatter plot.",
              "Plot triple values on the x-axis and calculated residuals on the y-axis.",
              "Label the x-axis as 'Triple' and the y-axis as 'Residuals'.",
              "Display the plot."
            ],
            "code": [
              "import matplotlib.pyplot as plt",
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_plot_residuals(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
              "    slope, intercept = compute_slope_result",
              "    # Calculate predicted vertical values",
              "    predicted_vertical = slope * clean_jumps_result['triple'] + intercept",
              "    # Calculate residuals",
              "    residuals = clean_jumps_result['vertical'] - predicted_vertical",
              "    # Create the scatter plot",
              "    plt.figure()",
              "    plt.scatter(clean_jumps_result['triple'], residuals)",
              "    plt.xlabel('Triple')",
              "    plt.ylabel('Residuals')",
              "    plt.draw()",
              "    return None"
            ],
            "result": {
              "result": {
                "pickle": "gAROLg==\n",
                "text": "None\n"
              },
              "output": {
                "output_type": "image",
                "data": "data:image/png;base64,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"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-7",
            "pill": "Bootstrap-Regression",
            "label": "Bootstrap regression line for resamples of data",
            "geometry": {
              "x": 90.0,
              "y": 290.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 350.0,
              "y": 290.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_bootstrap_regression",
            "function_result_var": "bootstrap_regression_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
                      "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
                      "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
                      "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
                    ],
                    "algorithm": [
                      "Define a function `bootstrap_regression` that takes `clean_jumps_result` as input.",
                      "Initialize an empty list `bootstrap_results` to store slope and intercept of each bootstrap sample.",
                      "Set the number of bootstrap samples, `n_bootstrap_samples`, to at least 1000 to ensure reliable estimates.",
                      "For each in the range from 0 to `n_bootstrap_samples`:",
                      ".1. Create a bootstrap sample by drawing with replacement from `clean_jumps_result`. This creates two arrays—`x_sample` from 'triple' and `y_sample` from 'vertical'.",
                      ".2. Perform linear regression on the bootstrap sample `x_sample`, `y_sample`. Use a suitable linear regression method (e.g., using numpy's `polyfit`) to compute the slope and intercept of the regression.",
                      ".3. Store the computed slope and intercept as a tuple in the `bootstrap_results` list.",
                      "After completing all bootstrap samples, convert the `bootstrap_results` list into a pandas DataFrame with column names 'slope' and 'intercept'.",
                      "Return the DataFrame containing the slopes and intercepts for all bootstrap samples."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import numpy as np",
                      "import pandas as pd",
                      "",
                      "def compute_bootstrap_regression(clean_jumps_result: pd.DataFrame) -> pd.DataFrame:",
                      "    bootstrap_results = []",
                      "    n_bootstrap_samples = 1000 # Number of resamples for bootstrap analysis",
                      "    ",
                      "    for _ in range(n_bootstrap_samples):",
                      "        # Create a bootstrap sample by sampling with replacement",
                      "        bootstrap_sample = clean_jumps_result.sample(n=len(clean_jumps_result), replace=True)",
                      "        x_sample = bootstrap_sample['triple']",
                      "        y_sample = bootstrap_sample['vertical']",
                      "        ",
                      "        # Calculate the slope and intercept using numpy polyfit for linear regression",
                      "        slope, intercept = np.polyfit(x_sample, y_sample, 1)",
                      "        ",
                      "        # Store results",
                      "        bootstrap_results.append((slope, intercept))",
                      "    ",
                      "    # Convert the bootstrap results to a DataFrame",
                      "    bootstrap_regression_result = pd.DataFrame(bootstrap_results, columns=['slope', 'intercept'])",
                      "    ",
                      "    return bootstrap_regression_result"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
              "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
              "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
              "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
            ],
            "description": "This computation step performs a bootstrap analysis of the regression line based on the 'clean_jumps_result' DataFrame. By taking many resamples (with replacement), the slope and intercept of a linear regression are calculated for each resample. This approach allows for estimation of the variability in the regression line's parameters.",
            "function_return_type": {
              "type": "pd.DataFrame['slope': float, 'intercept': float]"
            },
            "function_computed_value": "A DataFrame containing calculated slope and intercept values for each bootstrap resample of the data.",
            "algorithm": [
              "Define a function `bootstrap_regression` that takes `clean_jumps_result` as input.",
              "Initialize an empty list `bootstrap_results` to store slope and intercept of each bootstrap sample.",
              "Set the number of bootstrap samples, `n_bootstrap_samples`, to at least 1000 to ensure reliable estimates.",
              "For each in the range from 0 to `n_bootstrap_samples`:",
              ".1. Create a bootstrap sample by drawing with replacement from `clean_jumps_result`. This creates two arrays—`x_sample` from 'triple' and `y_sample` from 'vertical'.",
              ".2. Perform linear regression on the bootstrap sample `x_sample`, `y_sample`. Use a suitable linear regression method (e.g., using numpy's `polyfit`) to compute the slope and intercept of the regression.",
              ".3. Store the computed slope and intercept as a tuple in the `bootstrap_results` list.",
              "After completing all bootstrap samples, convert the `bootstrap_results` list into a pandas DataFrame with column names 'slope' and 'intercept'.",
              "Return the DataFrame containing the slopes and intercepts for all bootstrap samples."
            ],
            "code": [
              "import numpy as np",
              "import pandas as pd",
              "",
              "def compute_bootstrap_regression(clean_jumps_result: pd.DataFrame) -> pd.DataFrame:",
              "    bootstrap_results = []",
              "    n_bootstrap_samples = 1000 # Number of resamples for bootstrap analysis",
              "    ",
              "    for _ in range(n_bootstrap_samples):",
              "        # Create a bootstrap sample by sampling with replacement",
              "        bootstrap_sample = clean_jumps_result.sample(n=len(clean_jumps_result), replace=True)",
              "        x_sample = bootstrap_sample['triple']",
              "        y_sample = bootstrap_sample['vertical']",
              "        ",
              "        # Calculate the slope and intercept using numpy polyfit for linear regression",
              "        slope, intercept = np.polyfit(x_sample, y_sample, 1)",
              "        ",
              "        # Store results",
              "        bootstrap_results.append((slope, intercept))",
              "    ",
              "    # Convert the bootstrap results to a DataFrame",
              "    bootstrap_regression_result = pd.DataFrame(bootstrap_results, columns=['slope', 'intercept'])",
              "    ",
              "    return bootstrap_regression_result"
            ],
            "result": {
              "result": {
                "pickle": "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\n",
                "text": "        slope  intercept\n0    0.079948   4.990699\n1    0.089357   0.376534\n2    0.099633  -3.897056\n3    0.095368  -1.784043\n4    0.101629  -6.612154\n..        ...        ...\n995  0.096266  -3.894805\n996  0.101951  -7.306179\n997  0.086624   2.236808\n998  0.106705  -8.635379\n999  0.090075  -0.627934\n\n[1000 rows x 2 columns]\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-8",
            "pill": "Show-Confidence",
            "label": "Show confidence interval for prediction based on the mean jump in the data set",
            "geometry": {
              "x": 90.0,
              "y": 480.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 90.0,
              "y": 630.0,
              "width": 400.0,
              "height": 50.0
            },
            "function_name": "compute_show_confidence",
            "function_result_var": "show_confidence_result",
            "predecessors": [
              "Step-7",
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "confidence_interval is a Tuple[float, float].",
                      "confidence_interval represents the 95% confidence interval for the predicted 'vertical' value of the mean 'triple' jump in the clean_jumps_result dataset."
                    ],
                    "algorithm": [
                      "Calculate the mean value of 'triple' from the clean_jumps_result dataset. This will be the mean_triple.",
                      "Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
                      "Iterate over each row in the bootstrap_regression_result DataFrame:",
                      "  a) For each row, extract the 'slope' and 'intercept' values.",
                      "  b) Use these to calculate the predicted 'vertical' value using the formula:\n     predicted_vertical = (slope * mean_triple) + intercept.",
                      "  c) Append this predicted_vertical to the list of predicted verticals.",
                      "After completing the loop, convert the list of predicted verticals to a NumPy array for easier manipulation.",
                      "Calculate the 95% confidence interval from these predicted verticals using NumPy:\n  a) Use numpy.percentile() to find the 2.5th percentile and 97.5th percentile.\n  b) The result is the lower and upper bounds of the 95% confidence interval.",
                      "Create a tuple called confidence_interval containing the lower and upper bounds.",
                      "Return confidence_interval."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import numpy as np",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "",
                      "def compute_show_confidence(bootstrap_regression_result: pd.DataFrame, clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
                      "    # Step 1: Calculate the mean value of 'triple' from the clean_jumps_result dataset.",
                      "    mean_triple = clean_jumps_result['triple'].mean()",
                      "",
                      "    # Step 2: Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
                      "    predicted_verticals = []",
                      "",
                      "    # Step 3: Iterate over each row in the bootstrap_regression_result DataFrame.",
                      "    for _, row in bootstrap_regression_result.iterrows():",
                      "        slope, intercept = row['slope'], row['intercept']",
                      "        # Step 3b: Calculate the predicted 'vertical' using the formula.",
                      "        predicted_vertical = (slope * mean_triple) + intercept",
                      "        # Step 3c: Append this to the list.",
                      "        predicted_verticals.append(predicted_vertical)",
                      "",
                      "    # Step 4: Convert the list to a NumPy array for further manipulation.",
                      "    predicted_verticals = np.array(predicted_verticals)",
                      "",
                      "    # Step 5: Calculate the 95% confidence interval from the predicted verticals.",
                      "    lower_bound = np.percentile(predicted_verticals, 2.5)",
                      "    upper_bound = np.percentile(predicted_verticals, 97.5)",
                      "    # Step 6: Create a tuple of the confidence interval.",
                      "    confidence_interval = (lower_bound, upper_bound)",
                      "",
                      "    # Step 7: Return confidence_interval.",
                      "    return confidence_interval"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "bootstrap_regression_result",
                "type": {
                  "type": "pd.DataFrame['slope': float, 'intercept': float]"
                }
              },
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "bootstrap_regression_result": [
                "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
                "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
                "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
                "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
              ],
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "confidence_interval is a Tuple[float, float].",
              "confidence_interval represents the 95% confidence interval for the predicted 'vertical' value of the mean 'triple' jump in the clean_jumps_result dataset."
            ],
            "description": "This computation calculates the 95% confidence interval for the predicted 'vertical' value based on the mean of the 'triple' jumps in the clean_jumps_result data. It uses the bootstrap regression results to estimate variability in slope and intercept values. The mean 'triple' value is used to predict 'vertical', and the confidence interval reflects the uncertainty in this prediction.",
            "function_return_type": {
              "type": "Tuple[float, float]"
            },
            "function_computed_value": "The confidence interval for the predicted 'vertical' at the mean 'triple' value.",
            "algorithm": [
              "Calculate the mean value of 'triple' from the clean_jumps_result dataset. This will be the mean_triple.",
              "Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
              "Iterate over each row in the bootstrap_regression_result DataFrame:",
              "  a) For each row, extract the 'slope' and 'intercept' values.",
              "  b) Use these to calculate the predicted 'vertical' value using the formula:\n     predicted_vertical = (slope * mean_triple) + intercept.",
              "  c) Append this predicted_vertical to the list of predicted verticals.",
              "After completing the loop, convert the list of predicted verticals to a NumPy array for easier manipulation.",
              "Calculate the 95% confidence interval from these predicted verticals using NumPy:\n  a) Use numpy.percentile() to find the 2.5th percentile and 97.5th percentile.\n  b) The result is the lower and upper bounds of the 95% confidence interval.",
              "Create a tuple called confidence_interval containing the lower and upper bounds.",
              "Return confidence_interval."
            ],
            "code": [
              "import numpy as np",
              "import pandas as pd",
              "from typing import Tuple",
              "",
              "def compute_show_confidence(bootstrap_regression_result: pd.DataFrame, clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
              "    # Step 1: Calculate the mean value of 'triple' from the clean_jumps_result dataset.",
              "    mean_triple = clean_jumps_result['triple'].mean()",
              "",
              "    # Step 2: Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
              "    predicted_verticals = []",
              "",
              "    # Step 3: Iterate over each row in the bootstrap_regression_result DataFrame.",
              "    for _, row in bootstrap_regression_result.iterrows():",
              "        slope, intercept = row['slope'], row['intercept']",
              "        # Step 3b: Calculate the predicted 'vertical' using the formula.",
              "        predicted_vertical = (slope * mean_triple) + intercept",
              "        # Step 3c: Append this to the list.",
              "        predicted_verticals.append(predicted_vertical)",
              "",
              "    # Step 4: Convert the list to a NumPy array for further manipulation.",
              "    predicted_verticals = np.array(predicted_verticals)",
              "",
              "    # Step 5: Calculate the 95% confidence interval from the predicted verticals.",
              "    lower_bound = np.percentile(predicted_verticals, 2.5)",
              "    upper_bound = np.percentile(predicted_verticals, 97.5)",
              "    # Step 6: Create a tuple of the confidence interval.",
              "    confidence_interval = (lower_bound, upper_bound)",
              "",
              "    # Step 7: Return confidence_interval.",
              "    return confidence_interval"
            ],
            "result": {
              "result": {
                "pickle": "gASVfwAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCGva6QI6uEdAlIaUUpRoAmgIQwi83o9oOZtJQJSGlFKUhpQu\n",
                "text": "(np.float64(47.43927036684621), np.float64(51.212689466713954))\n"
              },
              "output": {
                "output_type": "text",
                "data": "(np.float64(47.43927036684621), np.float64(51.212689466713954))\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          }
        ],
        "edges": [
          {
            "id": "2",
            "src": "Step-1",
            "dst": "Step-2"
          },
          {
            "id": "3",
            "src": "Step-1",
            "dst": "Step-3"
          },
          {
            "id": "4",
            "src": "Step-3",
            "dst": "Step-4"
          },
          {
            "id": "5",
            "src": "Step-3",
            "dst": "Step-5"
          },
          {
            "id": "6",
            "src": "Step-3",
            "dst": "Step-6"
          },
          {
            "id": "7",
            "src": "Step-1",
            "dst": "Step-7"
          },
          {
            "id": "8",
            "src": "Step-7",
            "dst": "Step-8"
          }
        ],
        "image": null
      },
      "tables": {
        "tables": {
          "triple_vertical": {
            "table_name": "triple_vertical",
            "contents": "triple,vertical\n383.00,33.00\n781.00,71.10\n561.62,62.25\n624.52,61.33\n446.24,40.19\n515.30,38.96\n449.22,39.69\n560.91,46.51\n519.12,37.68\n595.38,53.48\n686.42,65.85\n601.67,57.60\n553.23,37.66\n529.22,41.70\n561.16,48.98\n465.88,34.14\n497.30,56.12\n592.71,53.91\n679.95,67.60\n531.92,51.29\n562.83,53.82\n447.53,42.05\n683.56,48.55\n630.60,66.76\n644.69,59.38\n479.34,43.68\n745.95,66.14\n667.12,61.50\n411.63,37.65\n483.32,37.59\n638.67,60.10\n477.62,42.57\n467.60,49.97\n400.31,48.42\n586.62,52.41\n513.26,42.27\n464.71,35.76\n403.22,34.96\n475.63,41.84\n568.04,47.53\n",
            "md5": "c7cc20224b239b2bb69a9501f2c31440"
          }
        }
      },
      "versions": []
    },
    {
      "file_name": "jumps.json",
      "dfg": {
        "description": "",
        "nodes": [
          {
            "id": "Step-1",
            "pill": "Clean-Jumps",
            "label": "Clean Jumps data",
            "geometry": {
              "x": 90.0,
              "y": 70.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 350.0,
              "y": 70.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_clean_jumps",
            "function_result_var": "clean_jumps_result",
            "predecessors": [],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                      "clean_jumps_result contains no missing (NA) values in any column.",
                      "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
                    ],
                    "algorithm": [
                      "Obtain the raw data by calling the global function `triple_vertical_table()`, which returns a DataFrame containing columns 'triple' and 'vertical'.",
                      "Assign the DataFrame obtained from `triple_vertical_table()` to a variable, say `jumps_data`.",
                      "Identify any missing (NA) values in `jumps_data`.",
                      "Remove any rows that contain missing (NA) values in `jumps_data`. This can be done by using available pandas functions to drop missing values.",
                      "Assign the cleaned DataFrame to `clean_jumps_result`.",
                      "Return `clean_jumps_result` as the final output, ensuring it contains no missing values."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "def compute_clean_jumps() -> pd.DataFrame:",
                      "    # Obtain the raw data from the global function",
                      "    jumps_data = triple_vertical_table()",
                      "    ",
                      "    # Remove any rows with missing values",
                      "    cleaned_data = jumps_data.dropna()",
                      "    ",
                      "    return cleaned_data"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [],
            "preconditions": {
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
              "clean_jumps_result contains no missing (NA) values in any column.",
              "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
            ],
            "description": "The 'Clean Jumps' step involves processing the data obtained from `triple_vertical_table()` to ensure it is suitable for further analysis. This function removes any missing values and ensures the data integrity and completeness are maintained, resulting in a cleaned DataFrame. The cleaning process ensures that subsequent computations are working with the most relevant and accurate data possible.",
            "function_return_type": {
              "type": "pd.DataFrame['triple': float, 'vertical': float]"
            },
            "function_computed_value": "A cleaned DataFrame of jump data with no missing values, containing 'triple' and 'vertical' columns.",
            "algorithm": [
              "Obtain the raw data by calling the global function `triple_vertical_table()`, which returns a DataFrame containing columns 'triple' and 'vertical'.",
              "Assign the DataFrame obtained from `triple_vertical_table()` to a variable, say `jumps_data`.",
              "Identify any missing (NA) values in `jumps_data`.",
              "Remove any rows that contain missing (NA) values in `jumps_data`. This can be done by using available pandas functions to drop missing values.",
              "Assign the cleaned DataFrame to `clean_jumps_result`.",
              "Return `clean_jumps_result` as the final output, ensuring it contains no missing values."
            ],
            "code": [
              "import pandas as pd",
              "def compute_clean_jumps() -> pd.DataFrame:",
              "    # Obtain the raw data from the global function",
              "    jumps_data = triple_vertical_table()",
              "    ",
              "    # Remove any rows with missing values",
              "    cleaned_data = jumps_data.dropna()",
              "    ",
              "    return cleaned_data"
            ],
            "result": {
              "result": {
                "pickle": "gASVFwUAAAAAAACMEXBhbmRhcy5jb3JlLmZyYW1llIwJRGF0YUZyYW1llJOUKYGUfZQojARfbWdylIwecGFuZGFzLmNvcmUuaW50ZXJuYWxzLm1hbmFnZXJzlIwMQmxvY2tNYW5hZ2VylJOUjBZwYW5kYXMuX2xpYnMuaW50ZXJuYWxzlIwPX3VucGlja2xlX2Jsb2NrlJOUjBZudW1weS5fY29yZS5tdWx0aWFycmF5lIwMX3JlY29uc3RydWN0lJOUjAVudW1weZSMB25kYXJyYXmUk5RLAIWUQwFilIeUUpQoSwFLAksohpRoD4wFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGKJQoACAAAAAAAAAPB3QAAAAAAAaIhAKVyPwvWMgUBcj8L1KISDQKRwPQrX43tAZmZmZmYagEDsUbgehRN8QOF6FK5Hh4FAKVyPwvU4gEDXo3A9CpuCQI/C9Shcc4VAj8L1KFzNgkCkcD0K10mBQPYoXI/CiYBA4XoUrkeJgUCuR+F6FB59QM3MzMzMFH9ASOF6FK6FgkCamZmZmT+FQI/C9Shcn4BAcT0K16OWgUAUrkfhevh7QBSuR+F6XIVAzczMzMy0g0DsUbgehSWEQD0K16Nw9X1AmpmZmZlPh0ApXI/C9diEQK5H4XoUunlAhetRuB41fkCPwvUoXPWDQFK4HoXr2X1AmpmZmZk5fUApXI/C9QR5QClcj8L1VIJArkfhehQKgECPwvUoXAt9QOxRuB6FM3lArkfhehS6fUC4HoXrUcCBQAAAAAAAgEBAZmZmZmbGUUAAAAAAACBPQArXo3A9qk5AuB6F61EYREB7FK5H4XpDQLgehetR2ENA4XoUrkdBR0DXo3A9CtdCQD0K16NwvUpAZmZmZmZ2UEDNzMzMzMxMQBSuR+F61EJAmpmZmZnZREA9CtejcH1IQFK4HoXrEUFAj8L1KFwPTEAUrkfhevRKQGZmZmZm5lBAhetRuB6lSUApXI/C9ehKQGZmZmZmBkVAZmZmZmZGSEBxPQrXo7BQQHE9CtejsE1A16NwPQrXRUApXI/C9YhQQAAAAAAAwE5AMzMzMzPTQkDsUbgehctCQM3MzMzMDE5AKVyPwvVIRUBcj8L1KPxIQPYoXI/CNUhAFK5H4Xo0SkDD9ShcjyJFQOF6FK5H4UFAexSuR+F6QUDsUbgehetEQKRwPQrXw0dAlHSUYowIYnVpbHRpbnOUjAVzbGljZZSTlEsASwJLAYeUUpRLAoeUUpSFlF2UKIwYcGFuZGFzLmNvcmUuaW5kZXhlcy5iYXNllIwKX25ld19JbmRleJSTlGgpjAVJbmRleJSTlH2UKIwEZGF0YZRoDmgRSwCFlGgTh5RSlChLAUsChZRoGIwCTziUiYiHlFKUKEsDjAF8lE5OTkr/////Sv////9LP3SUYoldlCiMBnRyaXBsZZSMCHZlcnRpY2FslGV0lGKMBG5hbWWUTnWGlFKUaCuMGXBhbmRhcy5jb3JlLmluZGV4ZXMucmFuZ2WUjApSYW5nZUluZGV4lJOUfZQoaD1OjAVzdGFydJRLAIwEc3RvcJRLKIwEc3RlcJRLAXWGlFKUZYaUUpSMBF90eXCUjAlkYXRhZnJhbWWUjAlfbWV0YWRhdGGUXZSMBWF0dHJzlH2UjAZfZmxhZ3OUfZSMF2FsbG93c19kdXBsaWNhdGVfbGFiZWxzlIhzdWIu\n",
                "text": "    triple  vertical\n0   383.00     33.00\n1   781.00     71.10\n2   561.62     62.25\n3   624.52     61.33\n4   446.24     40.19\n5   515.30     38.96\n6   449.22     39.69\n7   560.91     46.51\n8   519.12     37.68\n9   595.38     53.48\n10  686.42     65.85\n11  601.67     57.60\n12  553.23     37.66\n13  529.22     41.70\n14  561.16     48.98\n15  465.88     34.14\n16  497.30     56.12\n17  592.71     53.91\n18  679.95     67.60\n19  531.92     51.29\n20  562.83     53.82\n21  447.53     42.05\n22  683.56     48.55\n23  630.60     66.76\n24  644.69     59.38\n25  479.34     43.68\n26  745.95     66.14\n27  667.12     61.50\n28  411.63     37.65\n29  483.32     37.59\n30  638.67     60.10\n31  477.62     42.57\n32  467.60     49.97\n33  400.31     48.42\n34  586.62     52.41\n35  513.26     42.27\n36  464.71     35.76\n37  403.22     34.96\n38  475.63     41.84\n39  568.04     47.53\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-2",
            "pill": "Computer-Pearson",
            "label": "Computer Pearson Correlation",
            "geometry": {
              "x": 350.0,
              "y": 70.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 610.0,
              "y": 70.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_computer_pearson",
            "function_result_var": "computer_pearson_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "pearson_correlation is a float.",
                      "pearson_correlation represents the Pearson correlation coefficient between 'triple' and 'vertical' columns of clean_jumps_result."
                    ],
                    "algorithm": [
                      "Define a function `compute_pearson_correlation(clean_jumps_result)`.",
                      "Within the function, start by verifying that the input `clean_jumps_result` is a pandas DataFrame with the columns `triple` and `vertical`.",
                      "Ensure that there are no missing (NA) values within `clean_jumps_result`. If there are any, raise an error or warning, as the input precondition is not met.",
                      "Use the pandas DataFrame method `corr()` on `clean_jumps_result` to compute the Pearson correlation matrix.",
                      "Extract the correlation value between the `triple` and `vertical` columns from the matrix. This can often be accessed via `corr().loc['triple', 'vertical']`.",
                      "Assign this correlation value to the variable `pearson_correlation`.",
                      "Return the `pearson_correlation`."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "def compute_computer_pearson(clean_jumps_result: pd.DataFrame) -> float:",
                      "    # Verify the input is a valid DataFrame with correct columns",
                      "    if not isinstance(clean_jumps_result, pd.DataFrame) or 'triple' not in clean_jumps_result.columns or 'vertical' not in clean_jumps_result.columns:",
                      "        raise ValueError(\"Input must be a DataFrame with 'triple' and 'vertical' columns.\")",
                      "    ",
                      "    # Calculate the Pearson correlation",
                      "    correlation_matrix = clean_jumps_result.corr(method='pearson')",
                      "    pearson_correlation = correlation_matrix.loc['triple', 'vertical']",
                      "    ",
                      "    return pearson_correlation"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "pearson_correlation is a float.",
              "pearson_correlation represents the Pearson correlation coefficient between 'triple' and 'vertical' columns of clean_jumps_result."
            ],
            "description": "This computation calculates the Pearson correlation coefficient between the 'triple' and 'vertical' columns of the 'clean_jumps_result' DataFrame. Pearson correlation measures the linear correlation between two sets of data, providing a value between -1 and 1. This step helps in understanding the strength and direction of the linear relationship between the two types of jumps.",
            "function_return_type": {
              "type": "float"
            },
            "function_computed_value": "The computed value is the Pearson correlation coefficient as a float.",
            "algorithm": [
              "Define a function `compute_pearson_correlation(clean_jumps_result)`.",
              "Within the function, start by verifying that the input `clean_jumps_result` is a pandas DataFrame with the columns `triple` and `vertical`.",
              "Ensure that there are no missing (NA) values within `clean_jumps_result`. If there are any, raise an error or warning, as the input precondition is not met.",
              "Use the pandas DataFrame method `corr()` on `clean_jumps_result` to compute the Pearson correlation matrix.",
              "Extract the correlation value between the `triple` and `vertical` columns from the matrix. This can often be accessed via `corr().loc['triple', 'vertical']`.",
              "Assign this correlation value to the variable `pearson_correlation`.",
              "Return the `pearson_correlation`."
            ],
            "code": [
              "import pandas as pd",
              "def compute_computer_pearson(clean_jumps_result: pd.DataFrame) -> float:",
              "    # Verify the input is a valid DataFrame with correct columns",
              "    if not isinstance(clean_jumps_result, pd.DataFrame) or 'triple' not in clean_jumps_result.columns or 'vertical' not in clean_jumps_result.columns:",
              "        raise ValueError(\"Input must be a DataFrame with 'triple' and 'vertical' columns.\")",
              "    ",
              "    # Calculate the Pearson correlation",
              "    correlation_matrix = clean_jumps_result.corr(method='pearson')",
              "    pearson_correlation = correlation_matrix.loc['triple', 'vertical']",
              "    ",
              "    return pearson_correlation"
            ],
            "result": {
              "result": {
                "pickle": "gASVagAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCGVQVA6msuo/lIaUUpQu\n",
                "text": "0.8343076972837592\n"
              },
              "output": {
                "output_type": "text",
                "data": "0.8343076972837592\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-3",
            "pill": "Compute-Slope",
            "label": "Compute slope and intercept of regression line",
            "geometry": {
              "x": 340.0,
              "y": 200.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 600.0,
              "y": 200.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_compute_slope",
            "function_result_var": "compute_slope_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                      "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                      "The slope and intercept are both floats."
                    ],
                    "algorithm": [
                      "Initialize a function to compute the slope and intercept of a regression line using a DataFrame input, clean_jumps_result, with 'triple' as the independent variable and 'vertical' as the dependent variable.",
                      "Access the 'triple' column from clean_jumps_result and set it as the independent variable X.",
                      "Access the 'vertical' column from clean_jumps_result and set it as the dependent variable Y.",
                      "Import the LinearRegression class from the sklearn.linear_model module.",
                      "Create an instance of the LinearRegression class.",
                      "Reshape X into a 2D array compatible with sklearn's requirements.",
                      "Fit the linear regression model to the data by passing X and Y into the fit method of the LinearRegression instance.",
                      "Retrieve the coefficient property of the fitted linear regression model, which represents the slope of the regression line.",
                      "Retrieve the intercept property of the fitted linear regression model, which represents the intercept of the regression line.",
                      "Return a tuple containing the computed slope and intercept as floats."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "from typing import Tuple",
                      "import pandas as pd",
                      "from sklearn.linear_model import LinearRegression",
                      "def compute_compute_slope(clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
                      "    X = clean_jumps_result[['triple']].values  # Reshape to 2D array",
                      "    Y = clean_jumps_result['vertical'].values",
                      "    model = LinearRegression()",
                      "    model.fit(X, Y)",
                      "    slope = float(model.coef_[0])  # Get the slope (coefficient) and convert to float",
                      "    intercept = float(model.intercept_)  # Get the intercept and convert to float",
                      "    return (slope, intercept)"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
              "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
              "The slope and intercept are both floats."
            ],
            "description": "This computation step calculates the slope and intercept of a linear regression line that models the relationship between the 'triple' and 'vertical' columns in the clean_jumps_result DataFrame. It uses simple linear regression methods to determine how changes in 'triple' values predict changes in 'vertical' values. The slope represents the rate of change in 'vertical' for a unit change in 'triple', and the intercept represents the expected value of 'vertical' when 'triple' is zero.",
            "function_return_type": {
              "type": "Tuple[float, float]"
            },
            "function_computed_value": "A tuple containing the float values for the slope and intercept of the regression line.",
            "algorithm": [
              "Initialize a function to compute the slope and intercept of a regression line using a DataFrame input, clean_jumps_result, with 'triple' as the independent variable and 'vertical' as the dependent variable.",
              "Access the 'triple' column from clean_jumps_result and set it as the independent variable X.",
              "Access the 'vertical' column from clean_jumps_result and set it as the dependent variable Y.",
              "Import the LinearRegression class from the sklearn.linear_model module.",
              "Create an instance of the LinearRegression class.",
              "Reshape X into a 2D array compatible with sklearn's requirements.",
              "Fit the linear regression model to the data by passing X and Y into the fit method of the LinearRegression instance.",
              "Retrieve the coefficient property of the fitted linear regression model, which represents the slope of the regression line.",
              "Retrieve the intercept property of the fitted linear regression model, which represents the intercept of the regression line.",
              "Return a tuple containing the computed slope and intercept as floats."
            ],
            "code": [
              "from typing import Tuple",
              "import pandas as pd",
              "from sklearn.linear_model import LinearRegression",
              "def compute_compute_slope(clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
              "    X = clean_jumps_result[['triple']].values  # Reshape to 2D array",
              "    Y = clean_jumps_result['vertical'].values",
              "    model = LinearRegression()",
              "    model.fit(X, Y)",
              "    slope = float(model.coef_[0])  # Get the slope (coefficient) and convert to float",
              "    intercept = float(model.intercept_)  # Get the intercept and convert to float",
              "    return (slope, intercept)"
            ],
            "result": {
              "result": {
                "pickle": "gASVFQAAAAAAAABHP7fMDGRrR45Hv/kQeEu2BMCGlC4=\n",
                "text": "(0.09295728160512182, -1.5665209729634597)\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-4",
            "pill": "Plot-That",
            "label": "Plot that line and the data on a scatter plot",
            "geometry": {
              "x": 640.0,
              "y": 150.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 1090.0,
              "y": 350.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_plot_that",
            "function_result_var": "plot_that_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "Generate a scatter plot of the 'triple' column on the x-axis and 'vertical' column on the y-axis from clean_jumps_result.",
                      "Overlay the regression line using the computed slope and intercept from compute_slope_result.",
                      "Ensure that the plot includes appropriate labels and a legend for clarity."
                    ],
                    "algorithm": [
                      "Load the 'triple' and 'vertical' columns from the 'clean_jumps_result' DataFrame for plotting.",
                      "Create a scatter plot with the 'triple' column on the x-axis and the 'vertical' column on the y-axis using matplotlib.",
                      "Retrieve the slope and intercept from the 'compute_slope_result' tuple.",
                      "Compute the y-values for the regression line using the formula: \\[ \\text{y} = (\\text{slope} \\times \\text{triple}) + \\text{intercept} \\]",
                      "Overlay the regression line on the scatter plot.",
                      "Add labels for the x-axis as 'Triple' and y-axis as 'Vertical'.",
                      "Include a title for the plot, such as 'Scatter Plot with Regression Line'.",
                      "Add a legend to distinguish between data points and the regression line.",
                      "Display the plot."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import matplotlib.pyplot as plt",
                      "import seaborn as sns",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_plot_that(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
                      "    # Extract the slope and intercept from the compute_slope_result",
                      "    slope, intercept = compute_slope_result",
                      "    # Create the scatter plot",
                      "    plt.figure(figsize=(10, 6))",
                      "    sns.scatterplot(x='triple', y='vertical', data=clean_jumps_result, label='Data Points')",
                      "    # Compute the regression line values",
                      "    x_values = clean_jumps_result['triple']",
                      "    y_values = slope * x_values + intercept",
                      "    # Plot the regression line",
                      "    plt.plot(x_values, y_values, color='red', label='Regression Line')",
                      "    # Add labels and title",
                      "    plt.xlabel('Triple')",
                      "    plt.ylabel('Vertical')",
                      "    plt.title('Scatter Plot with Regression Line')",
                      "    plt.legend()",
                      "    # Draw the plot",
                      "    plt.draw()"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "Generate a scatter plot of the 'triple' column on the x-axis and 'vertical' column on the y-axis from clean_jumps_result.",
              "Overlay the regression line using the computed slope and intercept from compute_slope_result.",
              "Ensure that the plot includes appropriate labels and a legend for clarity."
            ],
            "description": "This step generates a visual representation of the linear relationship between the 'triple' and 'vertical' columns in the clean_jumps_result dataset. A scatter plot is created to display the data points, and the computed regression line is overlaid to illustrate the fit. This plot helps to visually assess the correlation and the accuracy of the linear model.",
            "function_return_type": {
              "type": "None"
            },
            "function_computed_value": "None",
            "algorithm": [
              "Load the 'triple' and 'vertical' columns from the 'clean_jumps_result' DataFrame for plotting.",
              "Create a scatter plot with the 'triple' column on the x-axis and the 'vertical' column on the y-axis using matplotlib.",
              "Retrieve the slope and intercept from the 'compute_slope_result' tuple.",
              "Compute the y-values for the regression line using the formula: \\[ \\text{y} = (\\text{slope} \\times \\text{triple}) + \\text{intercept} \\]",
              "Overlay the regression line on the scatter plot.",
              "Add labels for the x-axis as 'Triple' and y-axis as 'Vertical'.",
              "Include a title for the plot, such as 'Scatter Plot with Regression Line'.",
              "Add a legend to distinguish between data points and the regression line.",
              "Display the plot."
            ],
            "code": [
              "import matplotlib.pyplot as plt",
              "import seaborn as sns",
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_plot_that(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
              "    # Extract the slope and intercept from the compute_slope_result",
              "    slope, intercept = compute_slope_result",
              "    # Create the scatter plot",
              "    plt.figure(figsize=(10, 6))",
              "    sns.scatterplot(x='triple', y='vertical', data=clean_jumps_result, label='Data Points')",
              "    # Compute the regression line values",
              "    x_values = clean_jumps_result['triple']",
              "    y_values = slope * x_values + intercept",
              "    # Plot the regression line",
              "    plt.plot(x_values, y_values, color='red', label='Regression Line')",
              "    # Add labels and title",
              "    plt.xlabel('Triple')",
              "    plt.ylabel('Vertical')",
              "    plt.title('Scatter Plot with Regression Line')",
              "    plt.legend()",
              "    # Draw the plot",
              "    plt.draw()"
            ],
            "result": {
              "result": {
                "pickle": "gAROLg==\n",
                "text": "None\n"
              },
              "output": {
                "output_type": "image",
                "data": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA1UAAAIjCAIAAABkkab5AABtIElEQVR4nO3de1xT9f8H8PfhMm5jAxkIKCAiijfU1LyCJl5T0yQttLybF7xrIt28VWBe019mmqmVZnlJLTPzDioqXtGvikgoJipMZTAHDOH8/jg5xzaQy86ur+ejP9hnZ9t7hzVffD6f8/kwLMsSAAAAAFgNG2MXAAAAAAAGhfwHAAAAYF2Q/wAAAACsC/IfAAAAgHVB/gMAAACwLsh/AAAAANYF+Q8AAADAuiD/AQAAAFgX5D8AAAAA64L8BwBGc/v2bYZhNm3aZPiXZhhm/vz5FR8wefJkQ5VjEo4dO8YwzLFjxwz8uvPnz2cYxsAvCmDlkP8ATNqVK1feeuutgIAAR0fHOnXq9OjRY/Xq1TV/2q1bt65cuVK9JSsra/78+ZcuXar5k6vjIgXH3t6+fv36w4cP/+eff6rxVKdOnZo/f35ubq5+K9TLM3NBlmNjY1OrVq0+ffokJSXpr0az17Vr12bNmhm7CgD4D/IfgOk6depUmzZtLl++PG7cuP/7v/8bO3asjY3NV199VfNn1pn/FixYoPf8x5k6deqPP/64bt26vn37/vLLL23bts3Kyqrqk5w6dWrBggX6yn8FBQUff/yxfp85Kirqxx9/3Lhx48SJE0+fPv3aa69duXKlpoUaUHh4eEFBQXh4uIFf9+OPPy4oKDDwiwJYOTtjFwAA5fr888/FYnFycrKbm5uqMTs723gVVeTp06cuLi467woLC3vrrbeIaNSoUQ0bNpw6dermzZtjY2MNW2AZjo6Oen/OV1555d133+V+DgsL69OnzzfffLNmzRq9v1AFp7ombGxs+DgtL2VnZ2dnh3+MAAwK/X8Apis9Pb1p06bq4Y+IvLy81G/+9NNPr776qrOzs7u7e3h4+N9//82179mzp2/fvr6+vg4ODkFBQYsWLSopKeHu6tq16759++7cucONV9arV+/YsWNt27YlolGjRnGNqjl5Z86c6d27t1gsdnZ27tKly8mTJ1UvzU3bunbt2tChQ93d3Tt37lyZN9WtWzciysjI0HnvkSNHwsLCXFxc3NzcBgwYcP36ddVrffDBB0QUGBjIVXj79m2Nx65atcrW1lbVjbds2TKGYWbOnMndLCkpcXV1jYmJ4W6q5v9V/My7d+9u1qyZg4ND06ZN//rrr8q8QU5YWBgRpaenq1pyc3OnT5/u5+fn4ODQoEGDxYsXl5aWqu599OjRe++9JxKJ3NzcRowYcfnyZfXfwsiRI4VCYXp6+uuvv+7q6jps2DAiKi0tXblyZdOmTR0dHWvXrj1+/PgnT56onvDcuXO9evWSSCROTk6BgYGjR49W3bVt27bWrVu7urqKRKLmzZurepS15/9t3769devWTk5OEonk3XffvXfvnuourqR79+4NHDhQKBR6enrOnj1b9RmrEo35f9zMywrO/L1790aPHl27dm3u3u+//74aLwpg5fAnF4DpCggISEpKunr1ankTpxYsWDB//vyOHTsuXLhQIBCcOXPmyJEjPXv2JKJNmzYJhcKZM2cKhcIjR458+umneXl5S5YsIaKPPvpIJpP9+++/K1asICKhUNi4ceOFCxd++umn77//PhdcOnbsSERHjhzp06dP69at582bZ2Njs3Hjxm7duiUmJr766quqGgYPHhwcHPzFF1+wLFuZN8VFIg8PD+27Dh061KdPn/r168+fP7+goGD16tWdOnW6cOFCvXr1Bg0adPPmzZ9//nnFihUSiYSIPD09NR4eFhZWWlp64sSJfv36EVFiYqKNjU1iYiJ378WLF+VyufbgZgXPfOLEiV27dk2aNMnV1XXVqlWRkZGZmZk6K9fGhUh3d3fupkKh6NKly71798aPH+/v73/q1KnY2Nj79+9zo/ClpaX9+/c/e/bsxIkTQ0JC9uzZM2LECI0nfPbsWa9evTp37rx06VJnZ2ciGj9+/KZNm0aNGjV16tSMjIz/+7//u3jx4smTJ+3t7bOzs3v27Onp6Tl37lw3N7fbt2/v2rWLe56DBw9GRUVFREQsXryYiK5fv37y5Mlp06ZpvwXuydu2bRsXF/fw4cOvvvrq5MmTFy9eVP1BUlJS0qtXr3bt2i1duvTQoUPLli0LCgqaOHFiZc5PxSo48w8fPmzfvj2XET09Pffv3z9mzJi8vLzp06fX/HUBrAgLAKbq77//trW1tbW17dChw5w5cw4cOKBUKlX3pqWl2djYvPnmmyUlJarG0tJS7geFQqH+VOPHj3d2di4sLORu9u3bNyAgQP2A5ORkItq4caP6UwUHB/fq1Uv9OQMDA3v06MHdnDdvHhFFRUVV8BaOHj1KRN9//31OTk5WVta+ffvq1avHMExycjLL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"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-5",
            "pill": "Compute-R2",
            "label": "Compute R^2 score",
            "geometry": {
              "x": 510.0,
              "y": 360.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 720.0,
              "y": 500.0,
              "width": 400.0,
              "height": 60.0
            },
            "function_name": "compute_compute_r2",
            "function_result_var": "compute_r2_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "r_squared is a float.",
                      "r_squared represents the coefficient of determination for the linear regression model calculated using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                      "The regression model is defined by the slope and intercept in compute_slope_result."
                    ],
                    "algorithm": [
                      "Extract the slope and intercept from compute_slope_result.",
                      "Define a function to compute the predicted vertical values given a triple value using the equation: predicted_vertical = (slope * triple) + intercept.",
                      "Apply the function across the 'triple' column of clean_jumps_result to calculate predicted values for each row, resulting in a new column called 'predicted_vertical'.",
                      "Compute the total sum of squares (SST) as the sum of squared differences between each actual 'vertical' value in clean_jumps_result and the mean of the 'vertical' column.",
                      "Compute the sum of squares of residuals (SSR) as the sum of squared differences between each predicted 'predicted_vertical' value and the actual 'vertical' values in clean_jumps_result.",
                      "Calculate the R^2 score using the formula: r_squared = 1 - (SSR/SST).",
                      "Return r_squared."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_compute_r2(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> float:",
                      "    # Extract slope and intercept",
                      "    slope, intercept = compute_slope_result",
                      "",
                      "    # Calculate predicted vertical values",
                      "    clean_jumps_result['predicted_vertical'] = clean_jumps_result['triple'].apply(lambda x: slope * x + intercept)",
                      "",
                      "    # Compute total sum of squares (SST)",
                      "    vertical_mean = clean_jumps_result['vertical'].mean()",
                      "    sst = ((clean_jumps_result['vertical'] - vertical_mean) ** 2).sum()",
                      "",
                      "    # Compute sum of squares of residuals (SSR)",
                      "    ssr = ((clean_jumps_result['vertical'] - clean_jumps_result['predicted_vertical']) ** 2).sum()",
                      "",
                      "    # Calculate R^2 score",
                      "    r_squared = 1 - (ssr / sst)",
                      "",
                      "    return r_squared"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "r_squared is a float.",
              "r_squared represents the coefficient of determination for the linear regression model calculated using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
              "The regression model is defined by the slope and intercept in compute_slope_result."
            ],
            "description": "This computation step calculates the R^2 score (coefficient of determination) for the linear regression model determined by the given slope and intercept. The score provides a measure of how well the independent variable 'triple' predicts the dependent variable 'vertical'. The R^2 score is a value between 0 and 1, where a higher value indicates a better fit of the regression model to the data.",
            "function_return_type": {
              "type": "float"
            },
            "function_computed_value": "The R^2 score of the regression model.",
            "algorithm": [
              "Extract the slope and intercept from compute_slope_result.",
              "Define a function to compute the predicted vertical values given a triple value using the equation: predicted_vertical = (slope * triple) + intercept.",
              "Apply the function across the 'triple' column of clean_jumps_result to calculate predicted values for each row, resulting in a new column called 'predicted_vertical'.",
              "Compute the total sum of squares (SST) as the sum of squared differences between each actual 'vertical' value in clean_jumps_result and the mean of the 'vertical' column.",
              "Compute the sum of squares of residuals (SSR) as the sum of squared differences between each predicted 'predicted_vertical' value and the actual 'vertical' values in clean_jumps_result.",
              "Calculate the R^2 score using the formula: r_squared = 1 - (SSR/SST).",
              "Return r_squared."
            ],
            "code": [
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_compute_r2(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> float:",
              "    # Extract slope and intercept",
              "    slope, intercept = compute_slope_result",
              "",
              "    # Calculate predicted vertical values",
              "    clean_jumps_result['predicted_vertical'] = clean_jumps_result['triple'].apply(lambda x: slope * x + intercept)",
              "",
              "    # Compute total sum of squares (SST)",
              "    vertical_mean = clean_jumps_result['vertical'].mean()",
              "    sst = ((clean_jumps_result['vertical'] - vertical_mean) ** 2).sum()",
              "",
              "    # Compute sum of squares of residuals (SSR)",
              "    ssr = ((clean_jumps_result['vertical'] - clean_jumps_result['predicted_vertical']) ** 2).sum()",
              "",
              "    # Calculate R^2 score",
              "    r_squared = 1 - (ssr / sst)",
              "",
              "    return r_squared"
            ],
            "result": {
              "result": {
                "pickle": "gASVagAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCFohBjIzRuY/lIaUUpQu\n",
                "text": "0.6960693337469295\n"
              },
              "output": {
                "output_type": "text",
                "data": "0.6960693337469295\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-6",
            "pill": "Plot-Residuals",
            "label": "Plot Residuals",
            "geometry": {
              "x": 440.0,
              "y": 500.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 550.0,
              "y": 670.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_plot_residuals",
            "function_result_var": "plot_residuals_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "Residuals are computed as the difference between the actual values in the 'vertical' column and the predicted values based on the regression line from compute_slope_result.",
                      "A scatter plot of the residuals versus the 'triple' values from clean_jumps_result is generated.",
                      "The plot includes labels for the axes with 'Triple' on the x-axis and 'Residuals' on the y-axis."
                    ],
                    "algorithm": [
                      "Extract the slope and intercept from compute_slope_result.",
                      "Compute predicted vertical values using the formula: predicted_vertical = slope * triple + intercept for each row in clean_jumps_result.",
                      "Compute residuals as the difference between actual vertical values and predicted vertical values for each row.",
                      "Initialize a scatter plot.",
                      "Plot triple values on the x-axis and calculated residuals on the y-axis.",
                      "Label the x-axis as 'Triple' and the y-axis as 'Residuals'.",
                      "Display the plot."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import matplotlib.pyplot as plt",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_plot_residuals(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
                      "    slope, intercept = compute_slope_result",
                      "    # Calculate predicted vertical values",
                      "    predicted_vertical = slope * clean_jumps_result['triple'] + intercept",
                      "    # Calculate residuals",
                      "    residuals = clean_jumps_result['vertical'] - predicted_vertical",
                      "    # Create the scatter plot",
                      "    plt.figure()",
                      "    plt.scatter(clean_jumps_result['triple'], residuals)",
                      "    plt.xlabel('Triple')",
                      "    plt.ylabel('Residuals')",
                      "    plt.draw()",
                      "    return None"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "Residuals are computed as the difference between the actual values in the 'vertical' column and the predicted values based on the regression line from compute_slope_result.",
              "A scatter plot of the residuals versus the 'triple' values from clean_jumps_result is generated.",
              "The plot includes labels for the axes with 'Triple' on the x-axis and 'Residuals' on the y-axis."
            ],
            "description": "This step involves calculating the residuals based on the linear regression model obtained from the previous computation. The residuals are the differences between the actual 'vertical' values and the predicted values obtained using the slope and intercept from compute_slope_result. These residuals are then plotted in a scatter plot with 'triple' values on the x-axis, helping visualize any patterns or randomness in the residuals.",
            "function_return_type": {
              "type": "None"
            },
            "function_computed_value": "None",
            "algorithm": [
              "Extract the slope and intercept from compute_slope_result.",
              "Compute predicted vertical values using the formula: predicted_vertical = slope * triple + intercept for each row in clean_jumps_result.",
              "Compute residuals as the difference between actual vertical values and predicted vertical values for each row.",
              "Initialize a scatter plot.",
              "Plot triple values on the x-axis and calculated residuals on the y-axis.",
              "Label the x-axis as 'Triple' and the y-axis as 'Residuals'.",
              "Display the plot."
            ],
            "code": [
              "import matplotlib.pyplot as plt",
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_plot_residuals(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
              "    slope, intercept = compute_slope_result",
              "    # Calculate predicted vertical values",
              "    predicted_vertical = slope * clean_jumps_result['triple'] + intercept",
              "    # Calculate residuals",
              "    residuals = clean_jumps_result['vertical'] - predicted_vertical",
              "    # Create the scatter plot",
              "    plt.figure()",
              "    plt.scatter(clean_jumps_result['triple'], residuals)",
              "    plt.xlabel('Triple')",
              "    plt.ylabel('Residuals')",
              "    plt.draw()",
              "    return None"
            ],
            "result": {
              "result": {
                "pickle": "gAROLg==\n",
                "text": "None\n"
              },
              "output": {
                "output_type": "image",
                "data": "data:image/png;base64,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"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-7",
            "pill": "Bootstrap-Regression",
            "label": "Bootstrap regression line for resamples of data",
            "geometry": {
              "x": 90.0,
              "y": 290.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 350.0,
              "y": 290.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_bootstrap_regression",
            "function_result_var": "bootstrap_regression_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
                      "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
                      "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
                      "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
                    ],
                    "algorithm": [
                      "Define a function `bootstrap_regression` that takes `clean_jumps_result` as input.",
                      "Initialize an empty list `bootstrap_results` to store slope and intercept of each bootstrap sample.",
                      "Set the number of bootstrap samples, `n_bootstrap_samples`, to at least 1000 to ensure reliable estimates.",
                      "For each in the range from 0 to `n_bootstrap_samples`:",
                      ".1. Create a bootstrap sample by drawing with replacement from `clean_jumps_result`. This creates two arrays—`x_sample` from 'triple' and `y_sample` from 'vertical'.",
                      ".2. Perform linear regression on the bootstrap sample `x_sample`, `y_sample`. Use a suitable linear regression method (e.g., using numpy's `polyfit`) to compute the slope and intercept of the regression.",
                      ".3. Store the computed slope and intercept as a tuple in the `bootstrap_results` list.",
                      "After completing all bootstrap samples, convert the `bootstrap_results` list into a pandas DataFrame with column names 'slope' and 'intercept'.",
                      "Return the DataFrame containing the slopes and intercepts for all bootstrap samples."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import numpy as np",
                      "import pandas as pd",
                      "",
                      "def compute_bootstrap_regression(clean_jumps_result: pd.DataFrame) -> pd.DataFrame:",
                      "    bootstrap_results = []",
                      "    n_bootstrap_samples = 1000 # Number of resamples for bootstrap analysis",
                      "    ",
                      "    for _ in range(n_bootstrap_samples):",
                      "        # Create a bootstrap sample by sampling with replacement",
                      "        bootstrap_sample = clean_jumps_result.sample(n=len(clean_jumps_result), replace=True)",
                      "        x_sample = bootstrap_sample['triple']",
                      "        y_sample = bootstrap_sample['vertical']",
                      "        ",
                      "        # Calculate the slope and intercept using numpy polyfit for linear regression",
                      "        slope, intercept = np.polyfit(x_sample, y_sample, 1)",
                      "        ",
                      "        # Store results",
                      "        bootstrap_results.append((slope, intercept))",
                      "    ",
                      "    # Convert the bootstrap results to a DataFrame",
                      "    bootstrap_regression_result = pd.DataFrame(bootstrap_results, columns=['slope', 'intercept'])",
                      "    ",
                      "    return bootstrap_regression_result"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
              "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
              "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
              "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
            ],
            "description": "This computation step performs a bootstrap analysis of the regression line based on the 'clean_jumps_result' DataFrame. By taking many resamples (with replacement), the slope and intercept of a linear regression are calculated for each resample. This approach allows for estimation of the variability in the regression line's parameters.",
            "function_return_type": {
              "type": "pd.DataFrame['slope': float, 'intercept': float]"
            },
            "function_computed_value": "A DataFrame containing calculated slope and intercept values for each bootstrap resample of the data.",
            "algorithm": [
              "Define a function `bootstrap_regression` that takes `clean_jumps_result` as input.",
              "Initialize an empty list `bootstrap_results` to store slope and intercept of each bootstrap sample.",
              "Set the number of bootstrap samples, `n_bootstrap_samples`, to at least 1000 to ensure reliable estimates.",
              "For each in the range from 0 to `n_bootstrap_samples`:",
              ".1. Create a bootstrap sample by drawing with replacement from `clean_jumps_result`. This creates two arrays—`x_sample` from 'triple' and `y_sample` from 'vertical'.",
              ".2. Perform linear regression on the bootstrap sample `x_sample`, `y_sample`. Use a suitable linear regression method (e.g., using numpy's `polyfit`) to compute the slope and intercept of the regression.",
              ".3. Store the computed slope and intercept as a tuple in the `bootstrap_results` list.",
              "After completing all bootstrap samples, convert the `bootstrap_results` list into a pandas DataFrame with column names 'slope' and 'intercept'.",
              "Return the DataFrame containing the slopes and intercepts for all bootstrap samples."
            ],
            "code": [
              "import numpy as np",
              "import pandas as pd",
              "",
              "def compute_bootstrap_regression(clean_jumps_result: pd.DataFrame) -> pd.DataFrame:",
              "    bootstrap_results = []",
              "    n_bootstrap_samples = 1000 # Number of resamples for bootstrap analysis",
              "    ",
              "    for _ in range(n_bootstrap_samples):",
              "        # Create a bootstrap sample by sampling with replacement",
              "        bootstrap_sample = clean_jumps_result.sample(n=len(clean_jumps_result), replace=True)",
              "        x_sample = bootstrap_sample['triple']",
              "        y_sample = bootstrap_sample['vertical']",
              "        ",
              "        # Calculate the slope and intercept using numpy polyfit for linear regression",
              "        slope, intercept = np.polyfit(x_sample, y_sample, 1)",
              "        ",
              "        # Store results",
              "        bootstrap_results.append((slope, intercept))",
              "    ",
              "    # Convert the bootstrap results to a DataFrame",
              "    bootstrap_regression_result = pd.DataFrame(bootstrap_results, columns=['slope', 'intercept'])",
              "    ",
              "    return bootstrap_regression_result"
            ],
            "result": {
              "result": {
                "pickle": "gASVGUEAAAAAAACMEXBhbmRhcy5jb3JlLmZyYW1llIwJRGF0YUZyYW1llJOUKYGUfZQojARfbWdylIwecGFuZGFzLmNvcmUuaW50ZXJuYWxzLm1hbmFnZXJzlIwMQmxvY2tNYW5hZ2VylJOUjBZwYW5kYXMuX2xpYnMuaW50ZXJuYWxzlIwPX3VucGlja2xlX2Jsb2NrlJOUjBZudW1weS5fY29yZS5tdWx0aWFycmF5lIwMX3JlY29uc3RydWN0lJOUjAVudW1weZSMB25kYXJyYXmUk5RLAIWUQwFilIeUUpQoSwFLAk3oA4aUaA+MBWR0eXBllJOUjAJmOJSJiIeUUpQoSwOMATyUTk5OSv////9K/////0sAdJRiiUKAPgAAoTIvb3x3tD8CZHfWF+C2P5FbFdqMgbk/DAA7mwJquD/53veuXwS6P5vbbEI49bk/XQURqdwFtz/3DOBYVsu8P4/T48zVFLU/V64cZA7FuT+B2cQ2nIWxPwX7vRwP7bY/VfkW+kzGtD+aa6GSFmW4P9MY9BJWF7w/rXKdUctBtj+j8ctyFpq6PxnYta4/obA/ELK0c4pHuT8zaMxgZ8iyP19hatDCFbg/WR2pv1w1tT8amOV+Q1G6P6dM3ObkArQ/tJFpxxdQuT88iOhO6GG1P2lE4HffCbk/tPpQ8hiHuD+2OqEnMva6P1mpDEkeNbM/2d+7QfiytD958EoY9XawPwLbufS8zbo/nmA01UiVtz+Sj67IwP+zP+iByCUK7bU/MgrpqLV7tz/mr1cJOJK0P4OYq3AbGbk/zc2ujpYktj9bhlzf1Na1P+jmTLA7fLk/ZKJFPBy9tj+WneKL++a3Py/PwtFcjLc/ZYa+AMXKuT8DffBnAHW5PyvJcIFKpbY/LU/n9lp3sz9kHmhrtHC3PxSVhRMGg7c/Ou7EsGX7tz8IcN+W0w+3P42WJNC1nbc/n9OdR9vOsz8YfjvNGB+8PwC2NQqNG7s/YmGrkxbqtD/tewJ0ly+0P6fSMLga9LY/gIAgbFd0tz9yux8UVEW2PwBLX3GHD7c/bNVc8ZLAtj8NVMbRlDC3P7kMApKgGrk/QLiNZGtzuD+8NFba5bi3P74UpS3ggLo/ZeBx3fygtj8SeclNDyi0P9OYoeNGubg/nKfGw40TvD+LI55pfjW5P2ItJaKVHbc/zrF6HEsJuD/qNfdx0bmxP9bvM8JIW7c/z4wNRXxquz/6HvQy0TC2P0hMqcmH2bM/m7M6JYHiuT/qChtAV3K2P3sLIPtX3bY/Q0OXgOJjtz/MHLJwRCa4Pyl4WKgFFrk/+Zu8Y8mNtT/NwY0DNM22PwQxVl9+E7M/Rf6v1fnCtT88oXw7LTq7P4v1KYBz6bQ/aYOrwUDRtz9Ob+Z34jG1P8q+1i6lQ7k/Oq5lS0ySuj/jnpuG4ii6P4j43nG4qLk/Z8AnTa1guj90vWyxoA+4P0Vc01t3rrY/ABfpWzdgtj/LgKI8zLu6P5ZGq3tCBbs/CZeUgHYVuD8HtK7Qp/O3P5P3ZNO5m7c/sjYHyhjmuD89EZBSC8K9P08byQbNZ7U/qmPY/iwtuD+zyd67sgi3P3Sqg+WX3LY/DCEZwX5QuD/8fAF6MHS3PyW6H0pztLY/SrgCR7OGtz+Xat1P4UG1P2ab+8zg5Lc/dsR8yy0Auj8X/o47Wqa5P1m2UbjQdrg/v3xJpf7xuz9wVje6PC23P5Fyu8dbH7o/Gc4YnTIptz8QD3QCyG68P7eMMAyAGrY/BCN+VYYOuD8Py/kOyXa2P4UHnqToerk/UaQGVKo9tD/5U4zngAC7P+ZbT9LaPbQ/9b2n/gzOuT8fDF8AZoO3P1rorAbonbM/EH0SkBQnuT9DmQBYDnq3P+oSoy2dm7Y/Vf6cEucdtz/Sz3wiOQm0PxKsreuNB7g/hqgIXhmYsz+aEnSHvWi4PwNoxPBN6LY/o94QJu21tT8iqceaJLa4P9hO4du017Y/uo5LAv/Wtj+aR2Mpgxe2P3SgbE0Bz7Q/kiL/GSp7uj/sfqZxYZG4PxlG+LJCY7s/uMMy3CM3uD8dqPLB26W5PyYruEG2ULo/M2WR5x3ctD+JQjto2Tq5P8cAb9lhyrM/FNZuE3FNtz+tABQIeKS4P/Xjg6WEHLc/cXmdwGkatz+Ig7vHTya4P2m9iJe7b7M/sXOJIQSStT+I0HFboGq5P0rzgZa5Pbc/Xe3CwYXutz8or8x51Dq7P3X0CeeYjbc/trT7eRG0tz+foqmnPSq4P7Ed1UbMH7I/nW5+nFS9tz94hkb2iP64P8glUHR3c7U/eUEacM9fuD9VzZ/nD9S2Px1iaV2zWbU/+Pzr7KLFuT/kX85Aife5P/CzuZfa4Lg/1Cxbwtl0uT/YTIbWyEG5P4gn/PEhQLk/I4ZCso9euT8OmvSIGzW0P9ffuCsGcLY/vFS9GYSTtj/s4ER4Jx64P03NhKwMXrc/HXcnaO9auD+N3kLf/uC2PyZ8VuC2y7g/rfnz7dzAsj/9KlnjViu9P+J5T/nnz7M/cLL99cPEuj/EBro4ynW2P8ZUkBIXQbo/2WK175qNtz+5nRghq2q3P0C8L2uBb7Q/AftsliY8uD9DgtwA9q+2P/+zLGxvmLg/XHOSmNtruj/ckFuM4Cq4P8dIWLG9mLU/OLRf+EHZuj9mAcI4pGi4Pyyi/0sHULc/YipeEBVDuz8T/MuhAFeyP+X+WkUKnbU/M2MhpnANuj9MFSyiR7y2P0wVG/XJIbU/c65NkUpAuD/T+DkeRlu6P3V6IRY69Lc/GImuzVbIuT/kITTXCpS4P6mvqL6UrLQ/pRp3+J6Quj/3btYEI4e4PzPH3wJChrY/2T7vP911sz/oX/NTuGi2PxCxBCmG+LU/dWuqBVpYtz/Sf1HYZj+5P6YbVj+13bY/tV8uAjO5tT9tkHpG0ZS1Py2SyGYzr7g/Yx2sswxGuj8Ju0jRGE+4P6SvF2QAbLY/v057jJE1vj/g9iMD5DG2P/3pNbh9MLo/6smTZD51uD8AweTT3FyyP/JthRGJx7k/q7nF/vcGtj9DVJmKMSK6P4CDO9yAqbc/2HeZYhKdvT/4lhSuMJS3P24NO5jcq7k/FBR5W6yxuD/XwZ2CtmC7PyF59Yz+YLo/XSn3P10ruD+dkXzl9ti3P0QI24uRAbg/jemUUesOtj/n0Uavw7i1P5SHQLZp27Q/E09Ai06jtj+BsOfFiKu7P76MjYNDYLc/YHfKSQRAtj/5Vt7Pjae6PwzuU8VP07Y/EnKxxhhGtj+cnfqOtU+0P0s5hK3E97o/316sQ43kuj+FIGljUEm4PyQH3M8v/bU/9tg/QGYktz/83aBtg322P1gSmcPyG7g/WYdJV08VuD9OzKKoq8e3P01bCvhRIbc/hfd+ILHdtT+NgPySVRO3P9Rigc1f3LQ/6Jp1j1QyuD8qXdUJTIC1P+HG8Rv+ELk/wZ5n1bZ9uj86leDka0a6P5XphAVAxLg/fFFMLV72uT+pJeqJd4W2Pw5GrVjFTbk/c5FbQeqmuT+haCBRw+a1P0jkajHQxLc/oo8pgDVBuD/CJCUAQi63PxmRpDxeQbc/05ngOkSOtT9KtH9oAjG5P3ao35+WyL0/oOa6NF1isz8Ehte21xu3P4o9r6xdALo/Tf02LZVCtT+tAnxfUqy6Px9p0HwoTLg/gPb/CbrUtT8MpQ2Fw8azP0b0ZySZ2bc/Y8CrLxzEuz/tTRv0bJe2P22fAeuE3rY/BbkOVnWRuD+cB/3b67yxPz6OIDB27ro/hLnX1mHguT9Q1dsCLQe3P1aTn/HiWrc/iUVGFyUOtz9QxWWdKMK5P8c1Y0T6rLI/7t8naLm7tD9gEa1LgNS4P8JsKKS8Abk/XL6jdOxWsj8jw+IK4OS2P6OgUF0/e7o/wP9fBIWQuT8yiob/Ype2P9jX3A4vrrY/eeGBBj4Ztj/UvBpQt726P3k3niMprrY/LLpJBmLjuT+Ihep6H3C2P/RoDIs24Lg/5DuBkMMVuz99A/nLQVm5P+K1TQ7rerU/PXoKLlV/uj/oSCeA3Nu0P35sQokTTLU/ybCT1OmDtz9xE8GDAG26P8AmSHzg7bY/49jpSuQFuD8pm37osoK7P73Om0VvDbo/MFXCf9G8uT/HaABTQQy6P9dsVBRf4rM/RkKLfOBauz8+RQ/9Uz+1Pyx/HMRfxrc/YvbKFqY4vD+4ahLx7uK6PyKhy7o4i7Y/qCf6XiDptj8Ro9Bvcsa4P32Z8LKAnro/eiiJoB/JuD94X4hYfV+3P23ngFttq7U/KUji9BMZtT+20pvL0PW5P8TdcSDHsbc/NDjnXqzUtz8rdt1Hlca4P3hmxz6x6Lg//fUNKuastz8lCHvDhH28P1QEcKlfZrg/Y4tURyBauD8lxTDxf6i4P0u1KTld/LY/RldaGdL4uD9Dzc2quha4P/ZOgyjI07Y/FKOHnLR6uD+CV0aTvCi6Py8d+Sn2V7o/BLv7AEI0tz93SwKDwYS3Pymgc5Da27k//KOpN0x+uD8I36FMWpO1P/6oFutBaL4/x4sKyz6DuD/jtj9ClEGzP6fRBzWnobg/84eJaK7kuT8CVjNlMzy6Pw4Dz7y4j7c/Y3XRD49RtT8a2JtQINi3P+O+VGAN2LY/nM/ogWQ2tT8UfODejFu0P4j/oYx10rU/wCM5yoUwuT8i5Gtd8Ym4P+htqMBW9bU/NIC9G5ZPsz/NIVp+8Qu6P7fBv148jrk/kz/dNB58uj8T0SRMhsi1P6kY9zVLqbk/WHWK4hHiuT9S6jDQzVO7P7hiVp/fbLo/FMt8JBgvuT+DEvBge9K4PwfPbzoxPLc/C4shKpvFuz+48fJjtPi8PxGWvPhHLrw/+eJvWemSuD9OZ02Fqza1Pzszz7DKrrc/se/qRIk/uD9LKzF91Z20PwSLLJHIGbg/nQnvZ+hwuD92svXyv2i7P/Pc+hI4sbg/45uFtErquj//kzNl2M23P/ftDpI3CLc/aOcrNDPiuD8FHaaeYSG5P/L+EOWD6bY/0C3rR8e/tj+stRBP/3y3P431Q8Q0brY/hbjkPLK4tD+GgLOhPUi3Pz0ra+3MkrQ/YoqZUDGIuz//XGegYUm9P+t3w6uIQbo/dPfIxpM7uT9itpl0clC0P1t37ZI7xbo/J8WiQ6hhuD9/6sqOdLizPxDp+MMiPbg/wETbk+e3uT+cjl+KGW62P7lrWeJyxLY/Bj+CRfaYrj9fRP5H1+22PysrS79Rlrg/twGi3W8utz+FHSyk+ES4P1YJ6nRqXbw///tGm/UIuz+ozlOa18CzP9PN52+qX7c/nyuxhYT4tj+2jO/Giyi1PwEE5xOAIbU/eTHmN4WUsz/4Z9v5wye2P4POIXkQaLc/vnhTGFvrtT+9EcQjk1+zP95n9vf1QbY/Nb0NFsOgtz9bMZ63OZm3P9mzN4I+ubo/xmnIJTPJtT/3eoLkyHi9P0MblK5hvrU/TS/4oF9ntT+VH6MXDL61Pw2HEZMY37U/sMgITzGkuD+prxLpSXy2Px2wf1CmMbo/a1yhgE0Ztj/7hT7g0IO5Py4mn9GSdrs/kk4O+QCpuD/KT94OZHO6P+BfN8wum7o/RvnLLCoWuT88FvUsGAW8Pxks6u6SN7c/TUsK2GNJuj/S4ybJflW1P8hb+nraDbc/ww+/FofCuT+6+JF2qo61PwBmh4byK78/rVLJBz47tj+pcH9k0UO8P6JlFj7etLU/1lNDMhoPtj/c8Yc8zrq7Px53KcPvjrk/NEkRJN1ouT+V0gwlnP22P+XX/74kE7k/4kvjGg9qtz9535AC5YK1P3Qd9muJC7Y/doezUCb3uz84ERCYDS66P2HeTtbs57c/B/5fvltruT9ZEZR1alC6P3wqZH7hX7g/drqQmvDouT+VRwJc2Ji1P1s+k7Hvx7Y/gf1xPtkDuT9Z3/SLrvC0PxJHtGJ4yb4/Ew4TyjSEuD/O7ILj8a26PzGdFP/607c/T4QLIwvmtj+wRKu5Moq2Px0nlLXhGbg/38nKy8YvtT+Tza6ejxK7P3xoXhfHe7U/tWvmf6z0uT+Nyapqxje4P77MeLX8l7Q/GHezTbuUtz8xWkZA/xm7P21zkv1ayLc/REsYiw04sz+yikJUDg+3PzuYkO+TTLg/gpQy7kHTuT+F62j4OPy5P8goXc1js7c/hy2nbfYKuj/ohpgS7Lu5P+XCOhLNxbo/QDCqqRICuz9lUrJvjSu8PyB1bCnIiLk/ZXs7/FdKtj9X+qAoJ/y3P3ezj2WNd7c/p4qBXsWjtD+KrFcpeTW2P4/PJaixKbk/ndsWQ/tVuT+PUyPdtHy4P/vIacZgTLY//ZNISl7juj/lgPZbGcW6PxzPMwyAdbk/ecDerYS/uD/2JhztqxO5P+lbPmUck7c/qSp4v/Nitj8pitWpSuW6P/gX6A9pFbc/bO0gSYY2vD8auc9wC3i9P1lrsu5Xsrk/uuQRGyBttj/deC/83zW5P97rO5GWE7Y/J+yppyD0tj+dXmSPQqq1Pzu38omUP7Y/O0ISiCk+tj9cf9NSrZu0P+tI8lGgSbo/L6awl4QfuD+Mxxevw2u2Pxu94lnulbk/8sbjibpntD+fmeQjYk24P6+oZmuqTbY//EIOuFRttj+5T+RoH6a8Px6hiVGgnbY/b9ujAiJRtD9ybyBYLc27P+c1WtpWtLQ/lfuYY1rCtD+E/0FNMpa2Px5p1DYS1LU/4Y4idldxuD8GGwcyBx24PxaLEkcifr0/rcFaF8dQuT9OJSVVHpW3P7yym7ZSlLU/hroxHm61tD8R/HQ99hKzPxd3U1OA/bo/qs3rUd38uz8hEH7bC0a4PxSS+uRTsLg/DT4+ZPdEtz+6NeJu29u6P6vm8/e7Qbo/CdWBl9tUtj+rWtIeGga5P8SDnfnv5bY/2b7dscSfuT8fX2AmyHi5P7TzcNrnfro/50PG7e0Gtz/NMOxan3W3P41Os0SwhrA/T8lB+ijFuT/thKA7qUeyP826MeLI0Lo/350zGoPpuz+GdLZPlNe3P6aKvQfqe7g/RA6rLcVQuj8Cxm9S8Mi6P5Kc7AXkRsA/n+ug59wjuj/eM0PKe7W1PydOfQU/Ark/hdmVN1w4tj/yVOlYeEWyPzF2Lq7JqrI/aPEKsCnBuj+lTSDC8Zq3P2to7nL8vLc/3rRrwbk6tz9pnTDidsK2Pw2PiTYXY7k/OC314eQptz9F1VSdZ+m3P5z0F20hWbM/VR1K12mduj+DbJmaxYq5P+VEkNdWQb4/pvNrWINiuj+Xy5bQ0hq2P1zKABvgwbc/zGs+fJJCuT9KydkgvKa3P2G1Q+jql7M/50tir2+1uD95Crx3rhu6P+Wjk1VAdbU/coNSSk5ctz/1FmfVfFO6P0Riq2t+4bg/P3MHYrqjtT9ED3jUGfe4P14jHM4IKrg/wKN8fJe6tD/ylmrOlMK2Pzij8SIpG7Y/vObmxkiBtz/x6qfHqIyzP8bgJxQGn7k/G6gxn0aTtT+xm9lpm363PzN1ayih1Lo/SQrbacEBuD8bVnj8Fj25P3cYrP15w7o/cQqjfMuFtj/EHZomdfW2PyK5X46R4bk/er97JEL3tT8P1b9h6UK4P8UQinwke7o/tV5zhb6VtD85/uiU6fG4P+RpHsZpQLc/OF+CStdHtz/1l0vwB0q0P2LkiH9Yz7M/d9ydWGQ2uj9pbY59biq3P1arKTYAHbM/8CGIb+34tz+yn6cgv8u2PykoDTGTobY/VhEgFEhEtz/m0Z0wD0S3P1/UHOOrn7g/sJjc7BTKtD/XiAsxDAm0P2OA3yVc77c/erbGBkZNuD86sO7Y/bO3P0wp2IvbcLQ/ClF1YeaBtz/Kr1iKflS4P8pFUyf4Kbo/ivBybp12uT9IlKULosm2P4WxXvIrI7U/3N5z9P+itz93YWtxI+C3P55SFpkpyLg/DHRR6O1euT9TTWheEKu1P4hhGPBeurg/HdkbAH3nuj/IyKnNkLG4P2AR6rQk47U/82a+MdJitz9plgVQv223P5K4CR0Febg/UkzhH8x+tD9wQ5fpyVC5P3RY9vetOLY/kFzd4j2euT97E9xTS9+yP6EZmsJ71Lg/4C2AqxpbuD+U6LJJRoS3P20zbI3lN7c/WIiZmzSAtz9GPbWB8MW6P2e6D0CY17Q/rIjkAO2jtT83l5ddPWK0P6VPwPW2WL0/oZsjeLkKuj9Ss85CVrq2P/GVMXouXbY/V2n4iXm/tT91b8jwC2S3P5pAcIjeQ7k/yFqalf/xtj/mno7tChS4P3aObceHt7Y/p8nuGT8suj/1ybI0lM63P11Awah3yLc/VQnN0feltz+XonlUQT64PwmxOZk76Lc/amZ1TtjSuD9u6C0aPo2zP3BKFE7Ih7g/edSOyqSgvD+c1s2tOQe5PzDuFQh1CLY/gO0FFIrPtT9taIFFDQW4P6nmwSJGdLY/qAqmxSIHuD9SnkW53ky0P5bOGPawKbg/wDrkBLvOuz8QtF4M3/m2P+jxEiP2uLg/hXs3pSaxuD+kzphqNqu3PzPVHtDs6bU/8hnc2Qmhtj/YMN7+D4e6P/Ugz6KCbrU/gghaUsEGtT+9zi8ufzO7P530013/YbY/+OxmoH1Ltj+ZG0Vgag21P/+UlAQ3/rY/dt/oVSL7uD+W+vdR+bG2P33PWQ21Fbk/YDcdVam9tj/DzOAU6cG2Pzxqq9aIrrc/g+Fy5zmYtT/fFdUs/eKzP+Lo+3QXiLk/4zuyfISqtD8DIBhD0yC5PyBhPw+HELo/n0uw8WqBtz9hUNiNIuu2P5AhQwUlfrc/LZMR3NM0uD9QsJoMHPa3P5qm0sQdELg/jC4XogSLtj+yCkgNnK23P/aqafqb97Y/n3wi/nP7tz/WjWUpTeW3PwvBHzzU27Y/W4zvBV/6uD+L1hvemlS6P6s+tG68drk/xmN+M+Sctj9MolQcgeW5P5wFBbGDdrw/WxuwNDmEuT8nCmkZUPG5P0NndSqmUbo/pw93Y1tatT+Stb4olNm3P7/bQAqkqrg/ky/2NCBPuj9/1Op5b5+6PzNwZz50LLk/uW1WWRmQuD8/06aoQT23PwegScfY9LU/aQdCNPbBuj+XkbP3oQa6PyU+ST5ncrk/2/MRgFIotz9XISnqIgy4P3GnFCuECLg/a735+gaytT8NH+7Dao+7P38njsyFA7c/33xeWIb9tT8qpSTvPIC5P+adAbnBcLk/wG8YGiMJtj+vsiYKqQq8P65Ud0BP87c/5o8ekMH7vD+IsDSHA5+2PxI6elWtXLk/6SH+AqiWuj/CI1mmUg+5Pw6Lnz8Ftbc/EudyuQnWuj+VMLnodAe2P5vxIMlfULY/7VXumKwPvD9LIZ62ohK6PyAtl+zWOrY/ugLWuHhXtz9dweDO3w62P9X7enAWv7s/vgHitslhtj/oTfHYUNm2Py6OPT0LLrg/AO53tBEkuj/NSZkS+mG6PysG1p2b87E/AyORFd0Ytz9xxHXecvi4PwwfMrJ5e7Y/1KEYqlQJtz8d8Vf6f1+5P0TQao5Pero/kCUqLp/vuj/xEYpxIreyPwFpN808E7M/OxiOySQnuD+2O7JW7k63P0xomgpENLo/hlTqaB9ytj8h8ye5yBG0PzO4r7KlpLc/eypNiXITuj8B5o2XMCi5PyvRSnPUeLo/iRMRKSWZuT+x7gIsb+26Pxd8mK8EorY/i1PszQtEsz/07bSvF0C6P3GUx8iJ8rs/sgb2/7dYtz90Z10PuNW5Py+uMKdn1L0/JYE3lf6Etj+quTUqEO+5P+3SxQNMRLc/CtfMd4R/uz/6Wa2urN20PxjRSVaM4LU/iiVArWwCvj+W6/i11pC2P+eCTdHwurk/FuKjF0U1uj+snae0El26P4W47TWPdLY/J2Lr8fOgsz9YMjDMDxa5PxIPzyTwK7o/AlOXBY2dtj/iA9R6Cp22P0rb7SAVRLc/cKx8D6fbuT8SUpNafWi0PyZ/lOEWsbo/PoJGDR+6uD/JqAaWZOW3P2cPZ4lXIbg/MpBSK6l5uD/jup2e2BS3P9avSFc1wbU/yANDgM5mtz9lwxYEacq6PwjLlOOV0rs/Mog6fdWKvD+LH5FewN61P4iNDdiSd7o/2IsvkoTTuj8GsKck68O5P4Frb4Ggs68/+bHL1Vm2uz8aHBC/iWS4P7w3Gml9eLk/d0PVwR6LuD9+6XR8PR23P31L/G9Qabk/Hj8qcUi3uT9bxMVEWWm3P42n89OC0Lk/OdRniuWltj9zqKQKeyi4P5IkucDFNbc/1ekF3ERztT/lItBsPly5P8BbLtL1ibY/k1aKpnVXvD9pSCSp6Wi3P8aCzSKjerk/6do8OtoTuT/khhhAAEa4P9eoOj6zkbk/ys0NzQ1ruT8o8hTZVne2P/Z8RsUdvrc/oCjtAYCZuj9WZBqMeYy7Pye9IxWxTbU/n6MG1W+0tj9EdBNeQcO5P2CwKO7sRbg/0rcib9C5tj+0M4DKo5W1PxA3vTRhcbQ/lv4P4wFZtz+WCcWX4zi0P5IfN/uURbk/NelQM5bKtD+Y4rLXaIy2P0KSSlCG0rY/McAmnR8+tj9thvOjjlK8PzYOyiyDn7g/IlxhPlKjtj/a4Sl8FZO3P1SSb3Rr/bg/Tad3hfEjuz+XB4UjFYy2P8SjWn3XU7g/NG+Qop0ktD+C4ASnPDqyP2x37dJYtLc/44adlazouD+yFl0KvJW2PwRC0Gd8mbo/qtT1iaCYuT9+U+G0iaa7Pwdq3tbyqbg/4OiDF9Q7tz9UjwTrNm+0P1bD4IvlKrs/yuyvlm2Ruj+s54Wb+UC5P/H7klIJdbY/uyPfkOautj+p0vntNIWuP7OQQlMkebo/Z/Ta+BqHuD8PrYnQAnC2P9/OVA1yorc/Uw/CY/youD8WzBA+Wey2PzyN65Xcrrk/YsNiyrY6tz855SS0WHu1PwJ2cgJKqbU/Epcz9acPsz/UxWisTKS1P5LCC1X347c/k+7uzsGrtT8w2zigJa60P7RJQqHbpLg/V7X6ym4Zuj8hHkcc+yy2PxqDfW79ULs/w0/x6yEPtz/Yj6DmefYTQPqU8qIjGdg/85FIsystD8DNonSqcIv8vweGBXTYchrAWvKgU44wGsBZd25qjaD8P+J7jRZW2ibAtpZ2p347FUDPrANLHToawFt7Y7/OdiZAKuX4NqyAA0CSf2lqsIIQQB+P1RBjBRHAz+YVVD/fIsCZftU7v+H5Pys7EuVJ7BvA7DgyU98LK0CAVG738esVwPB24oNxCSRAnJJLjoUXC8AFqaEj2UgWQGGABVv73xrA8mcasttSGkAbwiI+n3QEwOu+4UQf5AZAZjinNt8/FMDtDG5sivwEwJz3wIG1NiTAF8C9XsfDIEAH5If0uzESQHBiT00LtC1ABpGhRVSdIMDewmhMHyXmv3xDflfXSxpA/jVwTYphEUAlNcu0Hr/hv3bLZQ6v6hZAwkaB1ldVDsAwAB0i2iYCQEprhuH0lfQ/Y+rPKAuxEsBIQxmoPLP7P/Zv2EiE7um/yspAKN1+778f1jSVN/UWwD7O4/95ThHAIdbDqA9+BECwusLFtl8XQDoTgOpSxvO/N7i2EtEG+r87uK/CyqX2v9QBTGKMH8E/fHC7HHqF8r9FSj2VlvUbQCKx0mSZoybAleHOQAyjI8D45P3ciJIRQDOwhOF0ihlAo0DWOyHZ7j/4NAZJM/LQv3qTb0xaoQBA+xHVeGam+L8BMgGva7Xav/bTCJOwFdu/ccTC45OsEcCaNGkKw7gCwAQDLGX9AfO/W4cuT59uIcD9HjYlEyDzP7FrbedHhxpAY7HKwqvtCMASjvBpX0YmwEoe9Y5Nkw3AwPcwM06P4T/ua+ObMoHmvyHYHja1hCFANN14Wr7G0L9TtvDsOqAhwFZbDOjdw/g/mKJZypQcIEBsg/BbS7QewAsfROwjIfA/HyE3zXAE7z8NcvDnL4DpP66pyAjBSATARWXOl+4vCsCadIfCVVsMQLElyIB9ENs/69ZoF87DIEC7x/rl9fQEQG1CPT4kzB/AwoC/3x3pEEAl6/XoDuHwv2qf5v/GIRFAYjNJxmDUGMArclZo8BkawIIq/Pk0qxvAhpJNKm+BGsBRIy9/UZQawOf2WGkIlgLAD4JU5OT3or9GJ49HudrTP5Kc36ciniDApJe9glERIMARysSFVDDzv4wADDRgQADAN3iU8FWC7r8UMlPGTSIMwPpMC9a6ZCrABKD40S5aEUBRnEUB0TMDwLX3/96Im8y/5EraJ/JVxL++cvgArp4MwN5Bl0o2ofa/UPjAAdqo6z/8+U4g/2rNvyr9FjviKQ5AffHzsxsK9r/ZF9iUBUkXwDMcb1A1kBXAJEh308IOAsAOjmdU1SIlwBov7ruIo9M/WGLJc7SrE8C/JV1HJD7Yv0hCBiAPhCbAQDl5hxaL8T8dSQcVYn76v112voRcgvw/eMSsPNj/GMCEg2pMOxgXQLXrS8WjwB3Aw/mxgXhSF0AfXPAWVIwYwBeACaL7Zfm/HeLFXJ3hHkCRz1yLmHMQwKGyX/fNG+O/fi2brM8gDEAPBBGtvob4P6gLyq113RdAatJgmaUeA8ANNqiuA2YbQOxl/OOTjwnAlC03UUV047+trEw/vosAQGbeleG5BQDAZJxd5QgS5b9hGPlLFQPWP7eHYKIUieE/G2UNr84mFkBuJhRs5hAgwHcargTLGQTAbPApWePvJcB34V8dSOXyv2SxXCDWwxbAIWWfA8bpGcBUwRmD12MLQBJSi1reGhPAaJaKr9T9HUC36cO4SBIAwDSh65IOewHAWa4PVm9o6j+qOeH5M07WPyutRBQVzxHA3lx/hpZoIkBaySYq3NIRQHTXJVzzxRXAwTZ0ABmv9r+DS8IOWdMNwHPfklNi7yLA8vXvcP6M87+IVumjYWXkv9CJZ1847f6/CajIbBGnIUC0ewVIv/X1vyyF1B0BhhbAtviAUlPOCECAh99QRt0HwGgXYUzwnOG/5ThzUJEoBUB64NI74lwcwAj2CB99tBnAe0kr8t3sFcBuKvCaqtYWwDVaWYYrXRHAU8FmsUssGcDH9Cf3OhsWwAlpRXqmzxZAUN8R2d7W4D+E4Zud/SzyPz6E6IYveQTALDwcDT3R5L/r1dbetEoHwL8feeEwz/E/HlyWo9obEcAcGxwUGOkkQAVEtCHV/yrAhg1AbHUIG0B8BosYI+wewByYB7BWlfo/oBfPmGv5IMCvE9eCAd3kv7pfHLGv3fK/MBt65AsdGUDq+56RiCYFwGKD32aTzLi/aiTHKY2AEsBF7Yak9UMbwBTsVBdfdALAUt3Q+eh1EkAXf2TCcNMiwEljneIRJAXAw14OQsMm/7+PcDXtjwgdwC34RDiARSFAhEgCcPUvAEBbw+Fk/tAWwGqKlICtcPc/7C0Kr9IpFUBhnCdKAnwEwI8qolmwQhXAHB74ts/x3b8M1Zwc/IIVwHQoaLzFXwTA7V8fOKDhFUBRvSoQ0asgwApV1b5vkhPAyNJG5KI267+iuAEDfd4fQPTfq5/MQ/M/YzT54Cx6AUBt5QRULMb5v0yRKv35GhTAkyA23Rd53r868sMhKgf5P9+c+V/7QAtAgPWg9yyjEcBtpesWolkawF2IXbRRyA3ASfzlN4yXEEBZyH2h/oswwM63N/qU5fI/fSPuXNvTHMAtlXj4NooEwEqkJ+nHQSBAo+UkoVf3HcDpMfWw8SIFQNp36JsXwh/A382sZJrL6L8C+8SUIskrwL8UcM6ONfO/is+4Bgg6EsD4y2meCzgPwNEzMQGhPiPAQClXtfxFGMC8Vhso4t7Dv+JE7ivVYfO/YmyIjkst9L+zHBYdfmsQQOMHJOd7nApAQLyrMycrEkAtVRXUnifxPxDYks2jKCHAd3oDVw6+rL9iDQdMLl4FQLNSoQYwDBrApaQEvxfS3D9cN1QG1nACQFHGL230Gx1AxmDLXxCkIsCdBIr2M2MdwEaL4s1aWArAlg64pqaeB0BddAU4+QK0P2pPmq485+o/qETNjHclDsA+0m4FQ+jtv49M8byqdwTAEyb50bO2n7+04MsKwoISQOnV8YXX9tU/MrNLiytXE0BAEloqO0sNwAXCeDzbYAdAOREU03IxE8B1aMcYu+sdwJ8bUx/y/xPAM4KwxTPuAsBzt/4ZBpYZwMkO/c3vK/c/JMJ24utiDcAunsSGbTcdwAtCQFGFcgpA8l7owQjC9b/2vw8zW7MBwByvgG8/ada/7gbbPa+ozj/As2ICMlASQHF3GpsNmxfAFBe00CsBL8BN6N3s7D0hQLRZuAqMROC/COUJNzqjGsAlBv6LL5MKQE/TywTVQyHANFIYyxOQ+7+bFzPjPTsVQBlc6pK+ehxA+mRz1Nph/b9jU96giYQmwOSqIQFXseI/qmd3VUR35L87sr65uukPwLgENyqmviRAzbHzVzO6IcC6/vChIZ0SwPD0EknwleE/iFELyeY+9r8vEqQBhcLkv5mt3OvvjhrAAEy473usJEAAGo2NzTAaQJWp5TZiFgzAEwygOXQ0C8BW/WDIGJYjQDFPAeMo+fO/YVpjsAU9FsBW5D8r6OoXwAEfG420It2/JO1T+Qad+D8swFGzaHQMQBGYt89P5BnANFF3TjHx/D92aRSP/NEZwFfdS9upNPs/xu6pSupPDcBfF1/7zdUhwEjz7/jrHRbAvWnmo4thEUBULf6qL9QUwBvDxs0JYAhAuSuJlvNDD0DEu+eg8q3vv3isVzo5nB/A0R647+745L9vbqbyAnHAP1fqdEqtQCDAEjnAVR4dGsCwxbH7i/UTwFfTNaRalhbAuugch5w7GEAIF/K2UkQkwPsElaPo6g9A3zhcYvMgAMCALGetchInwDk7vuh79B7AS3ViRHK9x78Tcye7inH0P9Nso90k4wbAdaaZfkx+HMAHvHRLHlcVwKav4Nw4GPe/WWrOqtuYBEDGU8jfnkAOQAIFMz3TeRzAujRV4vu697+i5dQInzzdvzKXYJSqcgzASUC9Wzo7EcB/UPkRPj/RP7xYCYJIBinAocj0W6KRDcAdH68rIG8LwOhTF/3LfgbAoT37nGlu9b/GDN8GKIgOwGgOns9RUsw/Rjg3iqaX/T9RNDB59cUCwC/+pVSuXxbAZ+1sroOyGcDRIyQ9jaPsv91fPiQ/tPw/MRgaFTRZHMAiDSBNMp0NwJk0WVjTdf8/boEVeCswMMCrDlZ2tjcHwJDflaKsCh1AgN5Ic6+oDsAalaCjdrsUwDmW1PUU9hjAhBW62rBt+r9+7n+kydsRQFJ89SaGfvG/o0qZQlOM4L+S8C9Z2lwSQMaOtlXNYRJApAhP8prx/D+UHpdz1LYTwAQPbNV3sg7AYih+rtlKBEDDQ1JWXTwhQD+xOcMydyHArCirbnFjEcCDY5bNK9QgwHKwx9yzRQhAnMsxvAmOFsClknPc2ysYwHbuw8jnISHA1KY8SdBNHMDxXufKCqEUwEAZZYklPhLAef+RPAYk478jukt5IlcjwGfEkLXvlirAoiCFe4NiI8D3P+Q+fIQDwOnTncssfgJANKMVBLc4/79UwHhvEP4AwGg4r33hQBdA9dOYr2thEsCrW8hyBRr9v5VOCp6p/CLAt5P6tGj0CMAMShdM94EhwI0cJq63hfm/cwlq9L/55z9IHno+zPUQwLtJ7WpukRPAntvBvkV0BEB6uKPDFErnP95V06G6kPW/ANnwpLXp9z/MrjQQaC0VQA75hF3fzUY/jDJyM1L0FEAq5akTTboiwGu6kGvM1yvAUT8raTDvF8BQ+/5dHaUOwA85T9o5+BZAxEI3PrjVH8Ap2Uae3z8MwKc7NqMhVxlAhDjSs3vOA8Dd+JbS/nQYwBmPWz4zHQ1AgGIV22F2vj9bKAYqNWcwQL5IWAey+M6/8knkSCEiCMA7CePTTsvfPzgLH0OKkgDAdW0ouF/HJcD9Yw+MyoMiwKKILsaIsBtAHzvNGA6b6b9QZ3Y65v3ov2N7/gneQxJAjjje6uhZFUAHZNK+hZIhQDW1p7ZjXPM/VrfFlTF48L8woNosD+8NQJVfvk1c6iJAK6hvUYFpB0C49hdAD2fKv22o8s1fcfm/AiviOpReIMBbiB9kiO0QQN1xQunNdCrA/s5z+OLFEECKyCd5dBf6P0eEFzuR0ANAkiVavA1CAUDUTjtzrfIDwHkYMusK5v8/BtmopDgzGcBr2jEaeMYBQJULqr4buxfArhAXniamIMBr2zgkHRMAwDv3mfpkDSLAZhgEw1rrIMBvTMm2YyQRwET6BP9b/SXAirZiz0Pj2r9I8+4qXxsgwH5lde1I3AtA2Hj0dr3I5r+SjyGp7FAXwL4dI36jbwxAo2v6eI49McCeywtGVT3xP0RyBRIkYynAxD0L4DSXAkCOUeBV5bgJQNDg/adEpCbAdCHPwzN4GcD8Y/7GiP8RwK8CZ0GSScY/ssZXBbs4C8ALYuUICJb3v+yCBrn1QgtA50po/rNwAEB7GMcNttwjwL8vOsOfvhvA4m8B7XvM778YjAo5n08QwOq4tF4OmhrAclezfARJCcBwvHp1KUYZwPPOwpQZaQtALnJ2Q8Kw6T8UMN/cQGYKwLcYY52SsQhAhgCyP5WuLcCSrDjbwT77v8S2fLfB2CPArYjBllNg+r+JfIim+erqv2culufiYP0/kz/YWujcAMDwudvsSukGQJogdqfNAyPA4yMQtW8jD0Drrnj5vn4YwBuyl7vW+wDAmwRRiDhqFEDqLkADFmHvvyqcjCuohxzAfMocNAzr4r8tCmtncuQgQK71LcacWPm/rone7UolC8D1b6zBEikRwBTuHwIpUyDA7ZttExG//b+BnP96eLAWwOwIaCRXohPAN/yDx9hUIMBS3xoXKZcjwHiNDR81qyXA1lMLjCSjFsDCV/j8+RIBQLkaDYJioA7ACx8a9BGs2D/ZLgqHtLUUQCFSJCqI5/U/lfnCEA7pDcCGCLbpvzAWwDZgM6BxzgvAeUIBCzl11j/NLB6K4iQgwPRW1WZEDRvAv67MrShSC8CrqXjZVLoHwLcCYA+RVhLA7wwItB8u+L+6Tc/0vEfxP13uQgdgiB/AismhhxPu0r+r1jQrcqwjwILDXfteVirAr11dHnzjD8BmtXGFOksAQFs9qhE2GQnALdGwwgNf6j+xyDrAcR71P9rzB1ygLxNAA2SVFrSAA0CZaXOYw/rdP6ZQUECUAxNA5zjTGCV3GcA0TdDzrjYCwL+53S3FNwJAwIDn+QFwFcAuI2kMYyoRQPPtHsYDOQrAKgac3trY+j+YfoAxqYHCv5n35DnuYijA+nO9dhOi6z8XuJePXOUfQJW5G3W6DyPA9/SeOu5eB0A3CupkMDATQHJbBeuBmQNAbA9heMwEEUDwgmGsELPvv9R4Iz+09/+/92gJDzIWK8DWJRzN+MEWwNDCoOH3iI6/VrILvoKLEUBhgdX42AAWQOjwArm4qRxANxrPUKuAIMDUL7wJB3IkwPO70+DZoeS/KpichydxEMDlFs6VGk/TP0JHDp6ZpRrABgGRqSULGMAII9dNERwHQJehe5Z6pRDAHbIHh4tT/b8bmA+SIjAWwAnVl2RV3xTAyz6h6aYLG8C3tC7jgCWuP8oNAV16ZPK/bH9dQfI8MECsMICC/roTwDP7dV2YayBASmErPYn/HMCV8FgMvGQkwINH/RmGbAnAmFeO0oUoAMAVhFDLCHAfwKq2uHf49iDA0aqh/KaONsDLj+dvkMUZwNNAo0T7/hBAK/huwZMNBMAe+rEoGjoBQOZOgOou6yRAgUfyxmgRIkCMiPB0gaUbwEPxZlWmre2/GiE/+kpb/r/q/cctmLDzvz6AsAJTGPk/13RWiqoVD8ABaZ7pJSb3P8gKOEMomwDAyq9CCj4QIEAACFmgO5MhwCHgrkDi8RrAVTjjxM+PL8B9G+yN5UAZwPjriuo2aQ1AZ4Y3uXip/r/4Yi2srDEQwD3FWdo6m/G/t1mSu7sGHUBjCudRqzYSwDtRiex1QBrARZrReixNA0C4+0pWxRv5v+obMtY6FSLAnmoTRxV0EMDlGT4JsTEGQGpOSONG0wrAAtbNibpzDMDsTk9N4WgXQH1cvOWwtuK/Sp+OO+8I7z+6zv2tx2gEwGc+mdIf6R1AzuvV0+jOGMAdBtUNypEFQIrBlWJD3wDATsHSFVulIcBZYFJ+BsgCwOhYrgZEHRbATlFkJRJnHMDRPXCJ/Ln2P1jcb8c8POy/vrOutYwGIMATJlF7mk8JQBjhZhuvG/m/o2QJm4T8GsCxCehLc+kWQNMtXLixCxLAjOyiKWxnyD8CYfwuJfbjv46qPcQARhdAys/SM9lsF0BBrR9VQvIZwMZSWqYN4f6/vxW+cuU0IEBOSxSQ/wz2vyuWz2onuO0/isWkA6Fe3T8RFRYyGK/jv+3aPQlnx/i/Hxy/lpwKEMCPWUrhpNoVQIi9916smhdA8z4FD9Y62b9jtAty1CILwJItfbomi/O/efqKfcf7FkDnCaLoO7Lnv3CzE1xkBQXAwik8Fz6CIMAbccN1ubwQwAtugY6rnQBAHjP5bBpiEEAp3J5QUNIAwNuwhKW3XwHAxfxdgo9bA8Cf0iPocY4ZwGacXie5YwVAzAwttC8AAMBtMTWVEbsjwKc0kbOu2w3AteX8sP64AEBazUwxqLX7v8WybI/i5Oy/THLg9kezA8Ay29TsPCwRQFi20vnxtRPA4cSaQmmmBkDQMt7JdRcUwM7n7CpxkB5ADI0wJ9F+EMDHCl/y9UQIwJsrwK51reC/Moi+8PzHpb9snLGX5FjmP1oDsN3KeyDA2r3xdc0AE0Asa8KrQin7P+wovVj7WxpAdgL5gfcmKsCFsGdMDiAawL7eK2EjPvI/EZ9K7JJJ7j/625UwmRMTQPSn7nDfD+K/zCiAQj7cEcC6hn3+DL/4P2TZwNBzcRHAlrAr4Qj34D/rdNXhrHkbwGSvfT/0GBDAfJrZyiDI6L+C4ziDD9IHwDK/eNgoQAbAOQAQsjkV8r9IO2qWvgoLwAC9Zr+UHx1AzQAbqHpTAMCkkYaXspQowP86jpMsphHAIVD4jT3v8j9AAbVvyOj5P+9qtpP34/e/ufo4gVUfAUC5Rwtj43MAwCW8/wsdBxhAusB/Rcg2DsDHUWFHtT4lwFX5+hUEvdE/cv1B7v8yD8CFzM9B00MOwChkmdHnGQHAMxK7oK3yBEDUoIt96p3MP07zxtI0sx/A9X2MGyLfDkCJMjfeCNAMQMubC2XQQyHAaD56SK9P8D9+MroRCpW5vwkM3p8IFgtAwe1gjvx00z+AYCnjuLEDwH2NsKHUBPE/xqMzZmq3FsAH0GS54hTtP7jVD8BQ2vI//Gl8V0Y0BcCW0BCUM7YJQGCNeXv8OhlAvAnh5uWBFMCF4zg+nA8TQBubzSYuvxLASjlqniy3FMAfC1ljZh+2P0drsPsu19u/2+ITgzOc2b8RLECTrMoEwL/a3PwL3vW/G2zavsUF9L/7ENaxLSWtP52yKdYegfG/m+xVi7be8T9+vE6i77HXP8GYBSz8lgDAT2bv4TO65T/5QKpffEsQwHGdoKX0URvAqECcZY1yFcBINW/oHufxP7d7lbiBmx/AhU1yqCHUJcDo8kz2YgIXwK8XtZQUyhXAc421+0gGHcAYQ/e/U6IGQPEETjOvC/C/hp76azxmEsDLcvKZglkdwEWETlL+cSLASq/T/MeZDcAjbxWCRDgPwNnz3/Q70cY/Nv71TyHC9j+x3sumSN0dwMk4tVu5SSDAGvqNRmDTD8AUS/EqUzTXvz3EpT9N8QHA3/4mlZ2hAcAHts9IDGkNQCWo21V2hiPAfq87U+nj5j9eYSny9EcEQB7WrUxwqBbAH0D7A/vJEMAk0BA6ljoRQLimjHZKySTA6c4PSV7eBsBlWY6UAcoswKbVDjnUXv0/PNf3v4N1FcA4VliE4jYewAidgnibLwnA3bJXqxhL4b8wqp85mUcewASSHoyQaHi/M+8fWwwZBUCB3//sKlspwJv21mLx9RnAWeG4+B741z/e2/6gp6wEwB7z56Zf/wJAA0hM1p3EJMDJQ36ydLvmPyrYkNIxleQ/YMQdDTtt8r+dNvua5NEdwHU7Qq6p1BjAplftWb7bJ0AiuEGlFUjiv6My6pBpLxTA9U6QMhnJ4T8EJMPekKGNv2yhxhQ6zxjAB5YCnajKGcCO9EDHrVQiwBnLVwj+MCRAoTsnEAugFUCUw/FZQ9gBwGnCQggpNcO/h/CIZF50EMBjJwT1DZQCQPEa0nbGdQ9Ar3cWGmwM/b9YNyMbPeocwG1Y1/41VxbAmUYVu/InIsDZ5ZJ+i8UYwJEma8Jy1x3A3SHbysV49z8JdlCZyoMgQNFCWrYLfRjAzqC/8DBlIsCOVhn7GiDqvxldAUTOPRLAgrXgy4ZALsDw37zBnlXxP6kp2jkb1BbAuQ1q286rwz/WMpCj+fMgwLkq7OLJEBRA0QoEfjImAkDKjfiNciktwKSD8kY0NPM/ybFa5gBqE8DKEHtiFaMTwKaqM3F7MB3A2Fxzi5i66L8AnbadDzcaQLwEksBl7BXAo2AhVf8aHMCuAK2MTmn5v3RC22ePrvU/DBlRVFzM0r8PAX5fiRMXwMfMi95P/RpATHGhfB8FHcBwjT2wwE4IwNFURvjI1AjAZNfaQPOQ/b/Zm3QZ9+EQwL3CZT5YHsQ/e6JmLpBtDECr6Zs+/Lixv8mwNlqwLCHAyZJkh6eUJsDhc7DyjbYnwODytT/6gglAIt8Zjre+HcDg+r/M8FEiwNDcQmXrgBPAwI4veDa/LEBxGeBFDYImwNCcByhqSwnAPEF/4uemE8BCvGSn4tkRwNe3vkVpx+O/spIY/u6gE8Ci/U/N2UoYwP+3kbIVjPS/8F+U+ZgLFsBkno3rW7L/PzP5o4WegwTA9sRpdl+Y4T+VBqqatM0VQODVHgRwbBPAHJNtGZTQ5D85IH2Jo0gmwMB9t4m+gti/G7bKRNcWFMC43zSkDKUKwN+DplkNmwLAZI5FBAEnFsCYZIRGHkYUwMkgFMfptwJALGkBbU0NBMBjjnReWhobwH0yQHFNqCXAKkK7G/xVDEDzE29/tbT2P6PxxMssQBnAu94Hb3GpDsDX4A5itITevwmnnAjOmw5AzNGJLTJ4G0AIsQASfsrrv0jgYDR+sRdAnWtns5yXE8BGpzELyKcTQDDT/AMnhew/2weAGCJaxL+hjVEMgqn8P4xl+b+sGSfA5p6lks60C8AZZfm5cXoAQGja8Z6jNO6/OrDIhIqBCMAIJnwI4ZQiwF+J8cKu9f8/d+e6dx1I+r9YVIgcnowYQCyq8mXSQiNAVHv4fB8U5L+DeHcdOKoQwCI5BQu7nuE/LwfjNn9qIMBThRIzk44WwG9C+ass4yTAN3EMerYoA8BZ91V4N8XXv7IQE5DTlRBAk1a239ahHcC1+45IlOIYwBuBlKPhpALAejnBCHPys7+WBs0wT+vxP1/W5N4T4C1A6ny9dIyqHcBuqqMtwI4RwMo0Dzim9PI/UWNWnmfP+L/XBuDq+mERwOdtzjYE1PA/lPQCuS6jGcAVQxZIT37Xv9qXhXg5wgxAS/HmEX7lDUAwp9Z4lMcbQIohV+DDEBZAKdMZ/GtMBsDgNaGEUAINQPVDmpf/6QpAluLmvI8oD8A2lpTfhjkdwL66QWb75AFAu4PwcVBFIcCiClD/CRjkv5R0lGKMCGJ1aWx0aW5zlIwFc2xpY2WUk5RLAEsCSwGHlFKUSwKHlFKUhZRdlCiMGHBhbmRhcy5jb3JlLmluZGV4ZXMuYmFzZZSMCl9uZXdfSW5kZXiUk5RoKYwFSW5kZXiUk5R9lCiMBGRhdGGUaA5oEUsAhZRoE4eUUpQoSwFLAoWUaBiMAk84lImIh5RSlChLA4wBfJROTk5K/////0r/////Sz90lGKJXZQojAVzbG9wZZSMCWludGVyY2VwdJRldJRijARuYW1llE51hpRSlGgrjBlwYW5kYXMuY29yZS5pbmRleGVzLnJhbmdllIwKUmFuZ2VJbmRleJSTlH2UKGg9TowFc3RhcnSUSwCMBHN0b3CUTegDjARzdGVwlEsBdYaUUpRlhpRSlIwEX3R5cJSMCWRhdGFmcmFtZZSMCV9tZXRhZGF0YZRdlIwFYXR0cnOUfZSMBl9mbGFnc5R9lIwXYWxsb3dzX2R1cGxpY2F0ZV9sYWJlbHOUiHN1Yi4=\n",
                "text": "        slope  intercept\n0    0.079948   4.990699\n1    0.089357   0.376534\n2    0.099633  -3.897056\n3    0.095368  -1.784043\n4    0.101629  -6.612154\n..        ...        ...\n995  0.096266  -3.894805\n996  0.101951  -7.306179\n997  0.086624   2.236808\n998  0.106705  -8.635379\n999  0.090075  -0.627934\n\n[1000 rows x 2 columns]\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-8",
            "pill": "Show-Confidence",
            "label": "Show confidence interval for prediction based on the mean jump in the data set",
            "geometry": {
              "x": 90.0,
              "y": 480.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 90.0,
              "y": 630.0,
              "width": 400.0,
              "height": 50.0
            },
            "function_name": "compute_show_confidence",
            "function_result_var": "show_confidence_result",
            "predecessors": [
              "Step-7",
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "confidence_interval is a Tuple[float, float].",
                      "confidence_interval represents the 95% confidence interval for the predicted 'vertical' value of the mean 'triple' jump in the clean_jumps_result dataset."
                    ],
                    "algorithm": [
                      "Calculate the mean value of 'triple' from the clean_jumps_result dataset. This will be the mean_triple.",
                      "Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
                      "Iterate over each row in the bootstrap_regression_result DataFrame:",
                      "  a) For each row, extract the 'slope' and 'intercept' values.",
                      "  b) Use these to calculate the predicted 'vertical' value using the formula:\n     predicted_vertical = (slope * mean_triple) + intercept.",
                      "  c) Append this predicted_vertical to the list of predicted verticals.",
                      "After completing the loop, convert the list of predicted verticals to a NumPy array for easier manipulation.",
                      "Calculate the 95% confidence interval from these predicted verticals using NumPy:\n  a) Use numpy.percentile() to find the 2.5th percentile and 97.5th percentile.\n  b) The result is the lower and upper bounds of the 95% confidence interval.",
                      "Create a tuple called confidence_interval containing the lower and upper bounds.",
                      "Return confidence_interval."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import numpy as np",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "",
                      "def compute_show_confidence(bootstrap_regression_result: pd.DataFrame, clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
                      "    # Step 1: Calculate the mean value of 'triple' from the clean_jumps_result dataset.",
                      "    mean_triple = clean_jumps_result['triple'].mean()",
                      "",
                      "    # Step 2: Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
                      "    predicted_verticals = []",
                      "",
                      "    # Step 3: Iterate over each row in the bootstrap_regression_result DataFrame.",
                      "    for _, row in bootstrap_regression_result.iterrows():",
                      "        slope, intercept = row['slope'], row['intercept']",
                      "        # Step 3b: Calculate the predicted 'vertical' using the formula.",
                      "        predicted_vertical = (slope * mean_triple) + intercept",
                      "        # Step 3c: Append this to the list.",
                      "        predicted_verticals.append(predicted_vertical)",
                      "",
                      "    # Step 4: Convert the list to a NumPy array for further manipulation.",
                      "    predicted_verticals = np.array(predicted_verticals)",
                      "",
                      "    # Step 5: Calculate the 95% confidence interval from the predicted verticals.",
                      "    lower_bound = np.percentile(predicted_verticals, 2.5)",
                      "    upper_bound = np.percentile(predicted_verticals, 97.5)",
                      "    # Step 6: Create a tuple of the confidence interval.",
                      "    confidence_interval = (lower_bound, upper_bound)",
                      "",
                      "    # Step 7: Return confidence_interval.",
                      "    return confidence_interval"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "bootstrap_regression_result",
                "type": {
                  "type": "pd.DataFrame['slope': float, 'intercept': float]"
                }
              },
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "bootstrap_regression_result": [
                "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
                "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
                "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
                "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
              ],
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "confidence_interval is a Tuple[float, float].",
              "confidence_interval represents the 95% confidence interval for the predicted 'vertical' value of the mean 'triple' jump in the clean_jumps_result dataset."
            ],
            "description": "This computation calculates the 95% confidence interval for the predicted 'vertical' value based on the mean of the 'triple' jumps in the clean_jumps_result data. It uses the bootstrap regression results to estimate variability in slope and intercept values. The mean 'triple' value is used to predict 'vertical', and the confidence interval reflects the uncertainty in this prediction.",
            "function_return_type": {
              "type": "Tuple[float, float]"
            },
            "function_computed_value": "The confidence interval for the predicted 'vertical' at the mean 'triple' value.",
            "algorithm": [
              "Calculate the mean value of 'triple' from the clean_jumps_result dataset. This will be the mean_triple.",
              "Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
              "Iterate over each row in the bootstrap_regression_result DataFrame:",
              "  a) For each row, extract the 'slope' and 'intercept' values.",
              "  b) Use these to calculate the predicted 'vertical' value using the formula:\n     predicted_vertical = (slope * mean_triple) + intercept.",
              "  c) Append this predicted_vertical to the list of predicted verticals.",
              "After completing the loop, convert the list of predicted verticals to a NumPy array for easier manipulation.",
              "Calculate the 95% confidence interval from these predicted verticals using NumPy:\n  a) Use numpy.percentile() to find the 2.5th percentile and 97.5th percentile.\n  b) The result is the lower and upper bounds of the 95% confidence interval.",
              "Create a tuple called confidence_interval containing the lower and upper bounds.",
              "Return confidence_interval."
            ],
            "code": [
              "import numpy as np",
              "import pandas as pd",
              "from typing import Tuple",
              "",
              "def compute_show_confidence(bootstrap_regression_result: pd.DataFrame, clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
              "    # Step 1: Calculate the mean value of 'triple' from the clean_jumps_result dataset.",
              "    mean_triple = clean_jumps_result['triple'].mean()",
              "",
              "    # Step 2: Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
              "    predicted_verticals = []",
              "",
              "    # Step 3: Iterate over each row in the bootstrap_regression_result DataFrame.",
              "    for _, row in bootstrap_regression_result.iterrows():",
              "        slope, intercept = row['slope'], row['intercept']",
              "        # Step 3b: Calculate the predicted 'vertical' using the formula.",
              "        predicted_vertical = (slope * mean_triple) + intercept",
              "        # Step 3c: Append this to the list.",
              "        predicted_verticals.append(predicted_vertical)",
              "",
              "    # Step 4: Convert the list to a NumPy array for further manipulation.",
              "    predicted_verticals = np.array(predicted_verticals)",
              "",
              "    # Step 5: Calculate the 95% confidence interval from the predicted verticals.",
              "    lower_bound = np.percentile(predicted_verticals, 2.5)",
              "    upper_bound = np.percentile(predicted_verticals, 97.5)",
              "    # Step 6: Create a tuple of the confidence interval.",
              "    confidence_interval = (lower_bound, upper_bound)",
              "",
              "    # Step 7: Return confidence_interval.",
              "    return confidence_interval"
            ],
            "result": {
              "result": {
                "pickle": "gASVfwAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCGva6QI6uEdAlIaUUpRoAmgIQwi83o9oOZtJQJSGlFKUhpQu\n",
                "text": "(np.float64(47.43927036684621), np.float64(51.212689466713954))\n"
              },
              "output": {
                "output_type": "text",
                "data": "(np.float64(47.43927036684621), np.float64(51.212689466713954))\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          }
        ],
        "edges": [
          {
            "id": "2",
            "src": "Step-1",
            "dst": "Step-2"
          },
          {
            "id": "3",
            "src": "Step-1",
            "dst": "Step-3"
          },
          {
            "id": "4",
            "src": "Step-3",
            "dst": "Step-4"
          },
          {
            "id": "5",
            "src": "Step-3",
            "dst": "Step-5"
          },
          {
            "id": "6",
            "src": "Step-3",
            "dst": "Step-6"
          },
          {
            "id": "7",
            "src": "Step-1",
            "dst": "Step-7"
          },
          {
            "id": "8",
            "src": "Step-7",
            "dst": "Step-8"
          }
        ],
        "image": null
      },
      "tables": {
        "tables": {
          "triple_vertical": {
            "table_name": "triple_vertical",
            "contents": "triple,vertical\n383.00,33.00\n781.00,71.10\n561.62,62.25\n624.52,61.33\n446.24,40.19\n515.30,38.96\n449.22,39.69\n560.91,46.51\n519.12,37.68\n595.38,53.48\n686.42,65.85\n601.67,57.60\n553.23,37.66\n529.22,41.70\n561.16,48.98\n465.88,34.14\n497.30,56.12\n592.71,53.91\n679.95,67.60\n531.92,51.29\n562.83,53.82\n447.53,42.05\n683.56,48.55\n630.60,66.76\n644.69,59.38\n479.34,43.68\n745.95,66.14\n667.12,61.50\n411.63,37.65\n483.32,37.59\n638.67,60.10\n477.62,42.57\n467.60,49.97\n400.31,48.42\n586.62,52.41\n513.26,42.27\n464.71,35.76\n403.22,34.96\n475.63,41.84\n568.04,47.53\n",
            "md5": "c7cc20224b239b2bb69a9501f2c31440"
          }
        }
      },
      "versions": []
    },
    {
      "file_name": "jumps.json",
      "dfg": {
        "description": "",
        "nodes": [
          {
            "id": "Step-1",
            "pill": "Clean-Jumps",
            "label": "Clean Jumps data",
            "geometry": {
              "x": 90.0,
              "y": 70.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 350.0,
              "y": 70.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_clean_jumps",
            "function_result_var": "clean_jumps_result",
            "predecessors": [],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                      "clean_jumps_result contains no missing (NA) values in any column.",
                      "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
                    ],
                    "algorithm": [
                      "Obtain the raw data by calling the global function `triple_vertical_table()`, which returns a DataFrame containing columns 'triple' and 'vertical'.",
                      "Assign the DataFrame obtained from `triple_vertical_table()` to a variable, say `jumps_data`.",
                      "Identify any missing (NA) values in `jumps_data`.",
                      "Remove any rows that contain missing (NA) values in `jumps_data`. This can be done by using available pandas functions to drop missing values.",
                      "Assign the cleaned DataFrame to `clean_jumps_result`.",
                      "Return `clean_jumps_result` as the final output, ensuring it contains no missing values."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "def compute_clean_jumps() -> pd.DataFrame:",
                      "    # Obtain the raw data from the global function",
                      "    jumps_data = triple_vertical_table()",
                      "    ",
                      "    # Remove any rows with missing values",
                      "    cleaned_data = jumps_data.dropna()",
                      "    ",
                      "    return cleaned_data"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [],
            "preconditions": {
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
              "clean_jumps_result contains no missing (NA) values in any column.",
              "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
            ],
            "description": "The 'Clean Jumps' step involves processing the data obtained from `triple_vertical_table()` to ensure it is suitable for further analysis. This function removes any missing values and ensures the data integrity and completeness are maintained, resulting in a cleaned DataFrame. The cleaning process ensures that subsequent computations are working with the most relevant and accurate data possible.",
            "function_return_type": {
              "type": "pd.DataFrame['triple': float, 'vertical': float]"
            },
            "function_computed_value": "A cleaned DataFrame of jump data with no missing values, containing 'triple' and 'vertical' columns.",
            "algorithm": [
              "Obtain the raw data by calling the global function `triple_vertical_table()`, which returns a DataFrame containing columns 'triple' and 'vertical'.",
              "Assign the DataFrame obtained from `triple_vertical_table()` to a variable, say `jumps_data`.",
              "Identify any missing (NA) values in `jumps_data`.",
              "Remove any rows that contain missing (NA) values in `jumps_data`. This can be done by using available pandas functions to drop missing values.",
              "Assign the cleaned DataFrame to `clean_jumps_result`.",
              "Return `clean_jumps_result` as the final output, ensuring it contains no missing values."
            ],
            "code": [
              "import pandas as pd",
              "def compute_clean_jumps() -> pd.DataFrame:",
              "    # Obtain the raw data from the global function",
              "    jumps_data = triple_vertical_table()",
              "    ",
              "    # Remove any rows with missing values",
              "    cleaned_data = jumps_data.dropna()",
              "    ",
              "    return cleaned_data"
            ],
            "result": {
              "result": {
                "pickle": "gASVFwUAAAAAAACMEXBhbmRhcy5jb3JlLmZyYW1llIwJRGF0YUZyYW1llJOUKYGUfZQojARfbWdylIwecGFuZGFzLmNvcmUuaW50ZXJuYWxzLm1hbmFnZXJzlIwMQmxvY2tNYW5hZ2VylJOUjBZwYW5kYXMuX2xpYnMuaW50ZXJuYWxzlIwPX3VucGlja2xlX2Jsb2NrlJOUjBZudW1weS5fY29yZS5tdWx0aWFycmF5lIwMX3JlY29uc3RydWN0lJOUjAVudW1weZSMB25kYXJyYXmUk5RLAIWUQwFilIeUUpQoSwFLAksohpRoD4wFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGKJQoACAAAAAAAAAPB3QAAAAAAAaIhAKVyPwvWMgUBcj8L1KISDQKRwPQrX43tAZmZmZmYagEDsUbgehRN8QOF6FK5Hh4FAKVyPwvU4gEDXo3A9CpuCQI/C9Shcc4VAj8L1KFzNgkCkcD0K10mBQPYoXI/CiYBA4XoUrkeJgUCuR+F6FB59QM3MzMzMFH9ASOF6FK6FgkCamZmZmT+FQI/C9Shcn4BAcT0K16OWgUAUrkfhevh7QBSuR+F6XIVAzczMzMy0g0DsUbgehSWEQD0K16Nw9X1AmpmZmZlPh0ApXI/C9diEQK5H4XoUunlAhetRuB41fkCPwvUoXPWDQFK4HoXr2X1AmpmZmZk5fUApXI/C9QR5QClcj8L1VIJArkfhehQKgECPwvUoXAt9QOxRuB6FM3lArkfhehS6fUC4HoXrUcCBQAAAAAAAgEBAZmZmZmbGUUAAAAAAACBPQArXo3A9qk5AuB6F61EYREB7FK5H4XpDQLgehetR2ENA4XoUrkdBR0DXo3A9CtdCQD0K16NwvUpAZmZmZmZ2UEDNzMzMzMxMQBSuR+F61EJAmpmZmZnZREA9CtejcH1IQFK4HoXrEUFAj8L1KFwPTEAUrkfhevRKQGZmZmZm5lBAhetRuB6lSUApXI/C9ehKQGZmZmZmBkVAZmZmZmZGSEBxPQrXo7BQQHE9CtejsE1A16NwPQrXRUApXI/C9YhQQAAAAAAAwE5AMzMzMzPTQkDsUbgehctCQM3MzMzMDE5AKVyPwvVIRUBcj8L1KPxIQPYoXI/CNUhAFK5H4Xo0SkDD9ShcjyJFQOF6FK5H4UFAexSuR+F6QUDsUbgehetEQKRwPQrXw0dAlHSUYowIYnVpbHRpbnOUjAVzbGljZZSTlEsASwJLAYeUUpRLAoeUUpSFlF2UKIwYcGFuZGFzLmNvcmUuaW5kZXhlcy5iYXNllIwKX25ld19JbmRleJSTlGgpjAVJbmRleJSTlH2UKIwEZGF0YZRoDmgRSwCFlGgTh5RSlChLAUsChZRoGIwCTziUiYiHlFKUKEsDjAF8lE5OTkr/////Sv////9LP3SUYoldlCiMBnRyaXBsZZSMCHZlcnRpY2FslGV0lGKMBG5hbWWUTnWGlFKUaCuMGXBhbmRhcy5jb3JlLmluZGV4ZXMucmFuZ2WUjApSYW5nZUluZGV4lJOUfZQoaD1OjAVzdGFydJRLAIwEc3RvcJRLKIwEc3RlcJRLAXWGlFKUZYaUUpSMBF90eXCUjAlkYXRhZnJhbWWUjAlfbWV0YWRhdGGUXZSMBWF0dHJzlH2UjAZfZmxhZ3OUfZSMF2FsbG93c19kdXBsaWNhdGVfbGFiZWxzlIhzdWIu\n",
                "text": "    triple  vertical\n0   383.00     33.00\n1   781.00     71.10\n2   561.62     62.25\n3   624.52     61.33\n4   446.24     40.19\n5   515.30     38.96\n6   449.22     39.69\n7   560.91     46.51\n8   519.12     37.68\n9   595.38     53.48\n10  686.42     65.85\n11  601.67     57.60\n12  553.23     37.66\n13  529.22     41.70\n14  561.16     48.98\n15  465.88     34.14\n16  497.30     56.12\n17  592.71     53.91\n18  679.95     67.60\n19  531.92     51.29\n20  562.83     53.82\n21  447.53     42.05\n22  683.56     48.55\n23  630.60     66.76\n24  644.69     59.38\n25  479.34     43.68\n26  745.95     66.14\n27  667.12     61.50\n28  411.63     37.65\n29  483.32     37.59\n30  638.67     60.10\n31  477.62     42.57\n32  467.60     49.97\n33  400.31     48.42\n34  586.62     52.41\n35  513.26     42.27\n36  464.71     35.76\n37  403.22     34.96\n38  475.63     41.84\n39  568.04     47.53\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-2",
            "pill": "Computer-Pearson",
            "label": "Computer Pearson Correlation",
            "geometry": {
              "x": 350.0,
              "y": 70.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 540.0,
              "y": 60.0,
              "width": 140.0,
              "height": 80.0
            },
            "function_name": "compute_computer_pearson",
            "function_result_var": "computer_pearson_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "pearson_correlation is a float.",
                      "pearson_correlation represents the Pearson correlation coefficient between 'triple' and 'vertical' columns of clean_jumps_result."
                    ],
                    "algorithm": [
                      "Define a function `compute_pearson_correlation(clean_jumps_result)`.",
                      "Within the function, start by verifying that the input `clean_jumps_result` is a pandas DataFrame with the columns `triple` and `vertical`.",
                      "Ensure that there are no missing (NA) values within `clean_jumps_result`. If there are any, raise an error or warning, as the input precondition is not met.",
                      "Use the pandas DataFrame method `corr()` on `clean_jumps_result` to compute the Pearson correlation matrix.",
                      "Extract the correlation value between the `triple` and `vertical` columns from the matrix. This can often be accessed via `corr().loc['triple', 'vertical']`.",
                      "Assign this correlation value to the variable `pearson_correlation`.",
                      "Return the `pearson_correlation`."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "def compute_computer_pearson(clean_jumps_result: pd.DataFrame) -> float:",
                      "    # Verify the input is a valid DataFrame with correct columns",
                      "    if not isinstance(clean_jumps_result, pd.DataFrame) or 'triple' not in clean_jumps_result.columns or 'vertical' not in clean_jumps_result.columns:",
                      "        raise ValueError(\"Input must be a DataFrame with 'triple' and 'vertical' columns.\")",
                      "    ",
                      "    # Calculate the Pearson correlation",
                      "    correlation_matrix = clean_jumps_result.corr(method='pearson')",
                      "    pearson_correlation = correlation_matrix.loc['triple', 'vertical']",
                      "    ",
                      "    return pearson_correlation"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "pearson_correlation is a float.",
              "pearson_correlation represents the Pearson correlation coefficient between 'triple' and 'vertical' columns of clean_jumps_result."
            ],
            "description": "This computation calculates the Pearson correlation coefficient between the 'triple' and 'vertical' columns of the 'clean_jumps_result' DataFrame. Pearson correlation measures the linear correlation between two sets of data, providing a value between -1 and 1. This step helps in understanding the strength and direction of the linear relationship between the two types of jumps.",
            "function_return_type": {
              "type": "float"
            },
            "function_computed_value": "The computed value is the Pearson correlation coefficient as a float.",
            "algorithm": [
              "Define a function `compute_pearson_correlation(clean_jumps_result)`.",
              "Within the function, start by verifying that the input `clean_jumps_result` is a pandas DataFrame with the columns `triple` and `vertical`.",
              "Ensure that there are no missing (NA) values within `clean_jumps_result`. If there are any, raise an error or warning, as the input precondition is not met.",
              "Use the pandas DataFrame method `corr()` on `clean_jumps_result` to compute the Pearson correlation matrix.",
              "Extract the correlation value between the `triple` and `vertical` columns from the matrix. This can often be accessed via `corr().loc['triple', 'vertical']`.",
              "Assign this correlation value to the variable `pearson_correlation`.",
              "Return the `pearson_correlation`."
            ],
            "code": [
              "import pandas as pd",
              "def compute_computer_pearson(clean_jumps_result: pd.DataFrame) -> float:",
              "    # Verify the input is a valid DataFrame with correct columns",
              "    if not isinstance(clean_jumps_result, pd.DataFrame) or 'triple' not in clean_jumps_result.columns or 'vertical' not in clean_jumps_result.columns:",
              "        raise ValueError(\"Input must be a DataFrame with 'triple' and 'vertical' columns.\")",
              "    ",
              "    # Calculate the Pearson correlation",
              "    correlation_matrix = clean_jumps_result.corr(method='pearson')",
              "    pearson_correlation = correlation_matrix.loc['triple', 'vertical']",
              "    ",
              "    return pearson_correlation"
            ],
            "result": {
              "result": {
                "pickle": "gASVagAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCGVQVA6msuo/lIaUUpQu\n",
                "text": "0.8343076972837592\n"
              },
              "output": {
                "output_type": "text",
                "data": "0.8343076972837592\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-3",
            "pill": "Compute-Slope",
            "label": "Compute slope and intercept of regression line",
            "geometry": {
              "x": 340.0,
              "y": 200.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 600.0,
              "y": 200.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_compute_slope",
            "function_result_var": "compute_slope_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                      "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                      "The slope and intercept are both floats."
                    ],
                    "algorithm": [
                      "Initialize a function to compute the slope and intercept of a regression line using a DataFrame input, clean_jumps_result, with 'triple' as the independent variable and 'vertical' as the dependent variable.",
                      "Access the 'triple' column from clean_jumps_result and set it as the independent variable X.",
                      "Access the 'vertical' column from clean_jumps_result and set it as the dependent variable Y.",
                      "Import the LinearRegression class from the sklearn.linear_model module.",
                      "Create an instance of the LinearRegression class.",
                      "Reshape X into a 2D array compatible with sklearn's requirements.",
                      "Fit the linear regression model to the data by passing X and Y into the fit method of the LinearRegression instance.",
                      "Retrieve the coefficient property of the fitted linear regression model, which represents the slope of the regression line.",
                      "Retrieve the intercept property of the fitted linear regression model, which represents the intercept of the regression line.",
                      "Return a tuple containing the computed slope and intercept as floats."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "from typing import Tuple",
                      "import pandas as pd",
                      "from sklearn.linear_model import LinearRegression",
                      "def compute_compute_slope(clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
                      "    X = clean_jumps_result[['triple']].values  # Reshape to 2D array",
                      "    Y = clean_jumps_result['vertical'].values",
                      "    model = LinearRegression()",
                      "    model.fit(X, Y)",
                      "    slope = float(model.coef_[0])  # Get the slope (coefficient) and convert to float",
                      "    intercept = float(model.intercept_)  # Get the intercept and convert to float",
                      "    return (slope, intercept)"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
              "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
              "The slope and intercept are both floats."
            ],
            "description": "This computation step calculates the slope and intercept of a linear regression line that models the relationship between the 'triple' and 'vertical' columns in the clean_jumps_result DataFrame. It uses simple linear regression methods to determine how changes in 'triple' values predict changes in 'vertical' values. The slope represents the rate of change in 'vertical' for a unit change in 'triple', and the intercept represents the expected value of 'vertical' when 'triple' is zero.",
            "function_return_type": {
              "type": "Tuple[float, float]"
            },
            "function_computed_value": "A tuple containing the float values for the slope and intercept of the regression line.",
            "algorithm": [
              "Initialize a function to compute the slope and intercept of a regression line using a DataFrame input, clean_jumps_result, with 'triple' as the independent variable and 'vertical' as the dependent variable.",
              "Access the 'triple' column from clean_jumps_result and set it as the independent variable X.",
              "Access the 'vertical' column from clean_jumps_result and set it as the dependent variable Y.",
              "Import the LinearRegression class from the sklearn.linear_model module.",
              "Create an instance of the LinearRegression class.",
              "Reshape X into a 2D array compatible with sklearn's requirements.",
              "Fit the linear regression model to the data by passing X and Y into the fit method of the LinearRegression instance.",
              "Retrieve the coefficient property of the fitted linear regression model, which represents the slope of the regression line.",
              "Retrieve the intercept property of the fitted linear regression model, which represents the intercept of the regression line.",
              "Return a tuple containing the computed slope and intercept as floats."
            ],
            "code": [
              "from typing import Tuple",
              "import pandas as pd",
              "from sklearn.linear_model import LinearRegression",
              "def compute_compute_slope(clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
              "    X = clean_jumps_result[['triple']].values  # Reshape to 2D array",
              "    Y = clean_jumps_result['vertical'].values",
              "    model = LinearRegression()",
              "    model.fit(X, Y)",
              "    slope = float(model.coef_[0])  # Get the slope (coefficient) and convert to float",
              "    intercept = float(model.intercept_)  # Get the intercept and convert to float",
              "    return (slope, intercept)"
            ],
            "result": {
              "result": {
                "pickle": "gASVFQAAAAAAAABHP7fMDGRrR45Hv/kQeEu2BMCGlC4=\n",
                "text": "(0.09295728160512182, -1.5665209729634597)\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-4",
            "pill": "Plot-That",
            "label": "Plot that line and the data on a scatter plot",
            "geometry": {
              "x": 640.0,
              "y": 150.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 1090.0,
              "y": 350.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_plot_that",
            "function_result_var": "plot_that_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "Generate a scatter plot of the 'triple' column on the x-axis and 'vertical' column on the y-axis from clean_jumps_result.",
                      "Overlay the regression line using the computed slope and intercept from compute_slope_result.",
                      "Ensure that the plot includes appropriate labels and a legend for clarity."
                    ],
                    "algorithm": [
                      "Load the 'triple' and 'vertical' columns from the 'clean_jumps_result' DataFrame for plotting.",
                      "Create a scatter plot with the 'triple' column on the x-axis and the 'vertical' column on the y-axis using matplotlib.",
                      "Retrieve the slope and intercept from the 'compute_slope_result' tuple.",
                      "Compute the y-values for the regression line using the formula: \\[ \\text{y} = (\\text{slope} \\times \\text{triple}) + \\text{intercept} \\]",
                      "Overlay the regression line on the scatter plot.",
                      "Add labels for the x-axis as 'Triple' and y-axis as 'Vertical'.",
                      "Include a title for the plot, such as 'Scatter Plot with Regression Line'.",
                      "Add a legend to distinguish between data points and the regression line.",
                      "Display the plot."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import matplotlib.pyplot as plt",
                      "import seaborn as sns",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_plot_that(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
                      "    # Extract the slope and intercept from the compute_slope_result",
                      "    slope, intercept = compute_slope_result",
                      "    # Create the scatter plot",
                      "    plt.figure(figsize=(10, 6))",
                      "    sns.scatterplot(x='triple', y='vertical', data=clean_jumps_result, label='Data Points')",
                      "    # Compute the regression line values",
                      "    x_values = clean_jumps_result['triple']",
                      "    y_values = slope * x_values + intercept",
                      "    # Plot the regression line",
                      "    plt.plot(x_values, y_values, color='red', label='Regression Line')",
                      "    # Add labels and title",
                      "    plt.xlabel('Triple')",
                      "    plt.ylabel('Vertical')",
                      "    plt.title('Scatter Plot with Regression Line')",
                      "    plt.legend()",
                      "    # Draw the plot",
                      "    plt.draw()"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "Generate a scatter plot of the 'triple' column on the x-axis and 'vertical' column on the y-axis from clean_jumps_result.",
              "Overlay the regression line using the computed slope and intercept from compute_slope_result.",
              "Ensure that the plot includes appropriate labels and a legend for clarity."
            ],
            "description": "This step generates a visual representation of the linear relationship between the 'triple' and 'vertical' columns in the clean_jumps_result dataset. A scatter plot is created to display the data points, and the computed regression line is overlaid to illustrate the fit. This plot helps to visually assess the correlation and the accuracy of the linear model.",
            "function_return_type": {
              "type": "None"
            },
            "function_computed_value": "None",
            "algorithm": [
              "Load the 'triple' and 'vertical' columns from the 'clean_jumps_result' DataFrame for plotting.",
              "Create a scatter plot with the 'triple' column on the x-axis and the 'vertical' column on the y-axis using matplotlib.",
              "Retrieve the slope and intercept from the 'compute_slope_result' tuple.",
              "Compute the y-values for the regression line using the formula: \\[ \\text{y} = (\\text{slope} \\times \\text{triple}) + \\text{intercept} \\]",
              "Overlay the regression line on the scatter plot.",
              "Add labels for the x-axis as 'Triple' and y-axis as 'Vertical'.",
              "Include a title for the plot, such as 'Scatter Plot with Regression Line'.",
              "Add a legend to distinguish between data points and the regression line.",
              "Display the plot."
            ],
            "code": [
              "import matplotlib.pyplot as plt",
              "import seaborn as sns",
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_plot_that(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
              "    # Extract the slope and intercept from the compute_slope_result",
              "    slope, intercept = compute_slope_result",
              "    # Create the scatter plot",
              "    plt.figure(figsize=(10, 6))",
              "    sns.scatterplot(x='triple', y='vertical', data=clean_jumps_result, label='Data Points')",
              "    # Compute the regression line values",
              "    x_values = clean_jumps_result['triple']",
              "    y_values = slope * x_values + intercept",
              "    # Plot the regression line",
              "    plt.plot(x_values, y_values, color='red', label='Regression Line')",
              "    # Add labels and title",
              "    plt.xlabel('Triple')",
              "    plt.ylabel('Vertical')",
              "    plt.title('Scatter Plot with Regression Line')",
              "    plt.legend()",
              "    # Draw the plot",
              "    plt.draw()"
            ],
            "result": {
              "result": {
                "pickle": "gAROLg==\n",
                "text": "None\n"
              },
              "output": {
                "output_type": "image",
                "data": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA1UAAAIjCAIAAABkkab5AABtIElEQVR4nO3de1xT9f8H8PfhMm5jAxkIKCAiijfU1LyCJl5T0yQttLybF7xrIt28VWBe019mmqmVZnlJLTPzDioqXtGvikgoJipMZTAHDOH8/jg5xzaQy86ur+ejP9hnZ9t7hzVffD6f8/kwLMsSAAAAAFgNG2MXAAAAAAAGhfwHAAAAYF2Q/wAAAACsC/IfAAAAgHVB/gMAAACwLsh/AAAAANYF+Q8AAADAuiD/AQAAAFgX5D8AAAAA64L8BwBGc/v2bYZhNm3aZPiXZhhm/vz5FR8wefJkQ5VjEo4dO8YwzLFjxwz8uvPnz2cYxsAvCmDlkP8ATNqVK1feeuutgIAAR0fHOnXq9OjRY/Xq1TV/2q1bt65cuVK9JSsra/78+ZcuXar5k6vjIgXH3t6+fv36w4cP/+eff6rxVKdOnZo/f35ubq5+K9TLM3NBlmNjY1OrVq0+ffokJSXpr0az17Vr12bNmhm7CgD4D/IfgOk6depUmzZtLl++PG7cuP/7v/8bO3asjY3NV199VfNn1pn/FixYoPf8x5k6deqPP/64bt26vn37/vLLL23bts3Kyqrqk5w6dWrBggX6yn8FBQUff/yxfp85Kirqxx9/3Lhx48SJE0+fPv3aa69duXKlpoUaUHh4eEFBQXh4uIFf9+OPPy4oKDDwiwJYOTtjFwAA5fr888/FYnFycrKbm5uqMTs723gVVeTp06cuLi467woLC3vrrbeIaNSoUQ0bNpw6dermzZtjY2MNW2AZjo6Oen/OV1555d133+V+DgsL69OnzzfffLNmzRq9v1AFp7ombGxs+DgtL2VnZ2dnh3+MAAwK/X8Apis9Pb1p06bq4Y+IvLy81G/+9NNPr776qrOzs7u7e3h4+N9//82179mzp2/fvr6+vg4ODkFBQYsWLSopKeHu6tq16759++7cucONV9arV+/YsWNt27YlolGjRnGNqjl5Z86c6d27t1gsdnZ27tKly8mTJ1UvzU3bunbt2tChQ93d3Tt37lyZN9WtWzciysjI0HnvkSNHwsLCXFxc3NzcBgwYcP36ddVrffDBB0QUGBjIVXj79m2Nx65atcrW1lbVjbds2TKGYWbOnMndLCkpcXV1jYmJ4W6q5v9V/My7d+9u1qyZg4ND06ZN//rrr8q8QU5YWBgRpaenq1pyc3OnT5/u5+fn4ODQoEGDxYsXl5aWqu599OjRe++9JxKJ3NzcRowYcfnyZfXfwsiRI4VCYXp6+uuvv+7q6jps2DAiKi0tXblyZdOmTR0dHWvXrj1+/PgnT56onvDcuXO9evWSSCROTk6BgYGjR49W3bVt27bWrVu7urqKRKLmzZurepS15/9t3769devWTk5OEonk3XffvXfvnuourqR79+4NHDhQKBR6enrOnj1b9RmrEo35f9zMywrO/L1790aPHl27dm3u3u+//74aLwpg5fAnF4DpCggISEpKunr1ankTpxYsWDB//vyOHTsuXLhQIBCcOXPmyJEjPXv2JKJNmzYJhcKZM2cKhcIjR458+umneXl5S5YsIaKPPvpIJpP9+++/K1asICKhUNi4ceOFCxd++umn77//PhdcOnbsSERHjhzp06dP69at582bZ2Njs3Hjxm7duiUmJr766quqGgYPHhwcHPzFF1+wLFuZN8VFIg8PD+27Dh061KdPn/r168+fP7+goGD16tWdOnW6cOFCvXr1Bg0adPPmzZ9//nnFihUSiYSIPD09NR4eFhZWWlp64sSJfv36EVFiYqKNjU1iYiJ378WLF+VyufbgZgXPfOLEiV27dk2aNMnV1XXVqlWRkZGZmZk6K9fGhUh3d3fupkKh6NKly71798aPH+/v73/q1KnY2Nj79+9zo/ClpaX9+/c/e/bsxIkTQ0JC9uzZM2LECI0nfPbsWa9evTp37rx06VJnZ2ciGj9+/KZNm0aNGjV16tSMjIz/+7//u3jx4smTJ+3t7bOzs3v27Onp6Tl37lw3N7fbt2/v2rWLe56DBw9GRUVFREQsXryYiK5fv37y5Mlp06ZpvwXuydu2bRsXF/fw4cOvvvrq5MmTFy9eVP1BUlJS0qtXr3bt2i1duvTQoUPLli0LCgqaOHFiZc5PxSo48w8fPmzfvj2XET09Pffv3z9mzJi8vLzp06fX/HUBrAgLAKbq77//trW1tbW17dChw5w5cw4cOKBUKlX3pqWl2djYvPnmmyUlJarG0tJS7geFQqH+VOPHj3d2di4sLORu9u3bNyAgQP2A5ORkItq4caP6UwUHB/fq1Uv9OQMDA3v06MHdnDdvHhFFRUVV8BaOHj1KRN9//31OTk5WVta+ffvq1avHMExycjLL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"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-5",
            "pill": "Compute-R2",
            "label": "Compute R^2 score",
            "geometry": {
              "x": 510.0,
              "y": 360.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 720.0,
              "y": 500.0,
              "width": 400.0,
              "height": 60.0
            },
            "function_name": "compute_compute_r2",
            "function_result_var": "compute_r2_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "r_squared is a float.",
                      "r_squared represents the coefficient of determination for the linear regression model calculated using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                      "The regression model is defined by the slope and intercept in compute_slope_result."
                    ],
                    "algorithm": [
                      "Extract the slope and intercept from compute_slope_result.",
                      "Define a function to compute the predicted vertical values given a triple value using the equation: predicted_vertical = (slope * triple) + intercept.",
                      "Apply the function across the 'triple' column of clean_jumps_result to calculate predicted values for each row, resulting in a new column called 'predicted_vertical'.",
                      "Compute the total sum of squares (SST) as the sum of squared differences between each actual 'vertical' value in clean_jumps_result and the mean of the 'vertical' column.",
                      "Compute the sum of squares of residuals (SSR) as the sum of squared differences between each predicted 'predicted_vertical' value and the actual 'vertical' values in clean_jumps_result.",
                      "Calculate the R^2 score using the formula: r_squared = 1 - (SSR/SST).",
                      "Return r_squared."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_compute_r2(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> float:",
                      "    # Extract slope and intercept",
                      "    slope, intercept = compute_slope_result",
                      "",
                      "    # Calculate predicted vertical values",
                      "    clean_jumps_result['predicted_vertical'] = clean_jumps_result['triple'].apply(lambda x: slope * x + intercept)",
                      "",
                      "    # Compute total sum of squares (SST)",
                      "    vertical_mean = clean_jumps_result['vertical'].mean()",
                      "    sst = ((clean_jumps_result['vertical'] - vertical_mean) ** 2).sum()",
                      "",
                      "    # Compute sum of squares of residuals (SSR)",
                      "    ssr = ((clean_jumps_result['vertical'] - clean_jumps_result['predicted_vertical']) ** 2).sum()",
                      "",
                      "    # Calculate R^2 score",
                      "    r_squared = 1 - (ssr / sst)",
                      "",
                      "    return r_squared"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "r_squared is a float.",
              "r_squared represents the coefficient of determination for the linear regression model calculated using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
              "The regression model is defined by the slope and intercept in compute_slope_result."
            ],
            "description": "This computation step calculates the R^2 score (coefficient of determination) for the linear regression model determined by the given slope and intercept. The score provides a measure of how well the independent variable 'triple' predicts the dependent variable 'vertical'. The R^2 score is a value between 0 and 1, where a higher value indicates a better fit of the regression model to the data.",
            "function_return_type": {
              "type": "float"
            },
            "function_computed_value": "The R^2 score of the regression model.",
            "algorithm": [
              "Extract the slope and intercept from compute_slope_result.",
              "Define a function to compute the predicted vertical values given a triple value using the equation: predicted_vertical = (slope * triple) + intercept.",
              "Apply the function across the 'triple' column of clean_jumps_result to calculate predicted values for each row, resulting in a new column called 'predicted_vertical'.",
              "Compute the total sum of squares (SST) as the sum of squared differences between each actual 'vertical' value in clean_jumps_result and the mean of the 'vertical' column.",
              "Compute the sum of squares of residuals (SSR) as the sum of squared differences between each predicted 'predicted_vertical' value and the actual 'vertical' values in clean_jumps_result.",
              "Calculate the R^2 score using the formula: r_squared = 1 - (SSR/SST).",
              "Return r_squared."
            ],
            "code": [
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_compute_r2(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> float:",
              "    # Extract slope and intercept",
              "    slope, intercept = compute_slope_result",
              "",
              "    # Calculate predicted vertical values",
              "    clean_jumps_result['predicted_vertical'] = clean_jumps_result['triple'].apply(lambda x: slope * x + intercept)",
              "",
              "    # Compute total sum of squares (SST)",
              "    vertical_mean = clean_jumps_result['vertical'].mean()",
              "    sst = ((clean_jumps_result['vertical'] - vertical_mean) ** 2).sum()",
              "",
              "    # Compute sum of squares of residuals (SSR)",
              "    ssr = ((clean_jumps_result['vertical'] - clean_jumps_result['predicted_vertical']) ** 2).sum()",
              "",
              "    # Calculate R^2 score",
              "    r_squared = 1 - (ssr / sst)",
              "",
              "    return r_squared"
            ],
            "result": {
              "result": {
                "pickle": "gASVagAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCFohBjIzRuY/lIaUUpQu\n",
                "text": "0.6960693337469295\n"
              },
              "output": {
                "output_type": "text",
                "data": "0.6960693337469295\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-6",
            "pill": "Plot-Residuals",
            "label": "Plot Residuals",
            "geometry": {
              "x": 440.0,
              "y": 500.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 550.0,
              "y": 670.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_plot_residuals",
            "function_result_var": "plot_residuals_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "Residuals are computed as the difference between the actual values in the 'vertical' column and the predicted values based on the regression line from compute_slope_result.",
                      "A scatter plot of the residuals versus the 'triple' values from clean_jumps_result is generated.",
                      "The plot includes labels for the axes with 'Triple' on the x-axis and 'Residuals' on the y-axis."
                    ],
                    "algorithm": [
                      "Extract the slope and intercept from compute_slope_result.",
                      "Compute predicted vertical values using the formula: predicted_vertical = slope * triple + intercept for each row in clean_jumps_result.",
                      "Compute residuals as the difference between actual vertical values and predicted vertical values for each row.",
                      "Initialize a scatter plot.",
                      "Plot triple values on the x-axis and calculated residuals on the y-axis.",
                      "Label the x-axis as 'Triple' and the y-axis as 'Residuals'.",
                      "Display the plot."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import matplotlib.pyplot as plt",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_plot_residuals(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
                      "    slope, intercept = compute_slope_result",
                      "    # Calculate predicted vertical values",
                      "    predicted_vertical = slope * clean_jumps_result['triple'] + intercept",
                      "    # Calculate residuals",
                      "    residuals = clean_jumps_result['vertical'] - predicted_vertical",
                      "    # Create the scatter plot",
                      "    plt.figure()",
                      "    plt.scatter(clean_jumps_result['triple'], residuals)",
                      "    plt.xlabel('Triple')",
                      "    plt.ylabel('Residuals')",
                      "    plt.draw()",
                      "    return None"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "Residuals are computed as the difference between the actual values in the 'vertical' column and the predicted values based on the regression line from compute_slope_result.",
              "A scatter plot of the residuals versus the 'triple' values from clean_jumps_result is generated.",
              "The plot includes labels for the axes with 'Triple' on the x-axis and 'Residuals' on the y-axis."
            ],
            "description": "This step involves calculating the residuals based on the linear regression model obtained from the previous computation. The residuals are the differences between the actual 'vertical' values and the predicted values obtained using the slope and intercept from compute_slope_result. These residuals are then plotted in a scatter plot with 'triple' values on the x-axis, helping visualize any patterns or randomness in the residuals.",
            "function_return_type": {
              "type": "None"
            },
            "function_computed_value": "None",
            "algorithm": [
              "Extract the slope and intercept from compute_slope_result.",
              "Compute predicted vertical values using the formula: predicted_vertical = slope * triple + intercept for each row in clean_jumps_result.",
              "Compute residuals as the difference between actual vertical values and predicted vertical values for each row.",
              "Initialize a scatter plot.",
              "Plot triple values on the x-axis and calculated residuals on the y-axis.",
              "Label the x-axis as 'Triple' and the y-axis as 'Residuals'.",
              "Display the plot."
            ],
            "code": [
              "import matplotlib.pyplot as plt",
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_plot_residuals(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
              "    slope, intercept = compute_slope_result",
              "    # Calculate predicted vertical values",
              "    predicted_vertical = slope * clean_jumps_result['triple'] + intercept",
              "    # Calculate residuals",
              "    residuals = clean_jumps_result['vertical'] - predicted_vertical",
              "    # Create the scatter plot",
              "    plt.figure()",
              "    plt.scatter(clean_jumps_result['triple'], residuals)",
              "    plt.xlabel('Triple')",
              "    plt.ylabel('Residuals')",
              "    plt.draw()",
              "    return None"
            ],
            "result": {
              "result": {
                "pickle": "gAROLg==\n",
                "text": "None\n"
              },
              "output": {
                "output_type": "image",
                "data": "data:image/png;base64,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"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-7",
            "pill": "Bootstrap-Regression",
            "label": "Bootstrap regression line for resamples of data",
            "geometry": {
              "x": 90.0,
              "y": 290.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 350.0,
              "y": 290.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_bootstrap_regression",
            "function_result_var": "bootstrap_regression_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
                      "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
                      "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
                      "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
                    ],
                    "algorithm": [
                      "Define a function `bootstrap_regression` that takes `clean_jumps_result` as input.",
                      "Initialize an empty list `bootstrap_results` to store slope and intercept of each bootstrap sample.",
                      "Set the number of bootstrap samples, `n_bootstrap_samples`, to at least 1000 to ensure reliable estimates.",
                      "For each in the range from 0 to `n_bootstrap_samples`:",
                      ".1. Create a bootstrap sample by drawing with replacement from `clean_jumps_result`. This creates two arrays—`x_sample` from 'triple' and `y_sample` from 'vertical'.",
                      ".2. Perform linear regression on the bootstrap sample `x_sample`, `y_sample`. Use a suitable linear regression method (e.g., using numpy's `polyfit`) to compute the slope and intercept of the regression.",
                      ".3. Store the computed slope and intercept as a tuple in the `bootstrap_results` list.",
                      "After completing all bootstrap samples, convert the `bootstrap_results` list into a pandas DataFrame with column names 'slope' and 'intercept'.",
                      "Return the DataFrame containing the slopes and intercepts for all bootstrap samples."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import numpy as np",
                      "import pandas as pd",
                      "",
                      "def compute_bootstrap_regression(clean_jumps_result: pd.DataFrame) -> pd.DataFrame:",
                      "    bootstrap_results = []",
                      "    n_bootstrap_samples = 1000 # Number of resamples for bootstrap analysis",
                      "    ",
                      "    for _ in range(n_bootstrap_samples):",
                      "        # Create a bootstrap sample by sampling with replacement",
                      "        bootstrap_sample = clean_jumps_result.sample(n=len(clean_jumps_result), replace=True)",
                      "        x_sample = bootstrap_sample['triple']",
                      "        y_sample = bootstrap_sample['vertical']",
                      "        ",
                      "        # Calculate the slope and intercept using numpy polyfit for linear regression",
                      "        slope, intercept = np.polyfit(x_sample, y_sample, 1)",
                      "        ",
                      "        # Store results",
                      "        bootstrap_results.append((slope, intercept))",
                      "    ",
                      "    # Convert the bootstrap results to a DataFrame",
                      "    bootstrap_regression_result = pd.DataFrame(bootstrap_results, columns=['slope', 'intercept'])",
                      "    ",
                      "    return bootstrap_regression_result"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
              "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
              "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
              "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
            ],
            "description": "This computation step performs a bootstrap analysis of the regression line based on the 'clean_jumps_result' DataFrame. By taking many resamples (with replacement), the slope and intercept of a linear regression are calculated for each resample. This approach allows for estimation of the variability in the regression line's parameters.",
            "function_return_type": {
              "type": "pd.DataFrame['slope': float, 'intercept': float]"
            },
            "function_computed_value": "A DataFrame containing calculated slope and intercept values for each bootstrap resample of the data.",
            "algorithm": [
              "Define a function `bootstrap_regression` that takes `clean_jumps_result` as input.",
              "Initialize an empty list `bootstrap_results` to store slope and intercept of each bootstrap sample.",
              "Set the number of bootstrap samples, `n_bootstrap_samples`, to at least 1000 to ensure reliable estimates.",
              "For each in the range from 0 to `n_bootstrap_samples`:",
              ".1. Create a bootstrap sample by drawing with replacement from `clean_jumps_result`. This creates two arrays—`x_sample` from 'triple' and `y_sample` from 'vertical'.",
              ".2. Perform linear regression on the bootstrap sample `x_sample`, `y_sample`. Use a suitable linear regression method (e.g., using numpy's `polyfit`) to compute the slope and intercept of the regression.",
              ".3. Store the computed slope and intercept as a tuple in the `bootstrap_results` list.",
              "After completing all bootstrap samples, convert the `bootstrap_results` list into a pandas DataFrame with column names 'slope' and 'intercept'.",
              "Return the DataFrame containing the slopes and intercepts for all bootstrap samples."
            ],
            "code": [
              "import numpy as np",
              "import pandas as pd",
              "",
              "def compute_bootstrap_regression(clean_jumps_result: pd.DataFrame) -> pd.DataFrame:",
              "    bootstrap_results = []",
              "    n_bootstrap_samples = 1000 # Number of resamples for bootstrap analysis",
              "    ",
              "    for _ in range(n_bootstrap_samples):",
              "        # Create a bootstrap sample by sampling with replacement",
              "        bootstrap_sample = clean_jumps_result.sample(n=len(clean_jumps_result), replace=True)",
              "        x_sample = bootstrap_sample['triple']",
              "        y_sample = bootstrap_sample['vertical']",
              "        ",
              "        # Calculate the slope and intercept using numpy polyfit for linear regression",
              "        slope, intercept = np.polyfit(x_sample, y_sample, 1)",
              "        ",
              "        # Store results",
              "        bootstrap_results.append((slope, intercept))",
              "    ",
              "    # Convert the bootstrap results to a DataFrame",
              "    bootstrap_regression_result = pd.DataFrame(bootstrap_results, columns=['slope', 'intercept'])",
              "    ",
              "    return bootstrap_regression_result"
            ],
            "result": {
              "result": {
                "pickle": "gASVGUEAAAAAAACMEXBhbmRhcy5jb3JlLmZyYW1llIwJRGF0YUZyYW1llJOUKYGUfZQojARfbWdylIwecGFuZGFzLmNvcmUuaW50ZXJuYWxzLm1hbmFnZXJzlIwMQmxvY2tNYW5hZ2VylJOUjBZwYW5kYXMuX2xpYnMuaW50ZXJuYWxzlIwPX3VucGlja2xlX2Jsb2NrlJOUjBZudW1weS5fY29yZS5tdWx0aWFycmF5lIwMX3JlY29uc3RydWN0lJOUjAVudW1weZSMB25kYXJyYXmUk5RLAIWUQwFilIeUUpQoSwFLAk3oA4aUaA+MBWR0eXBllJOUjAJmOJSJiIeUUpQoSwOMATyUTk5OSv////9K/////0sAdJRiiUKAPgAAoTIvb3x3tD8CZHfWF+C2P5FbFdqMgbk/DAA7mwJquD/53veuXwS6P5vbbEI49bk/XQURqdwFtz/3DOBYVsu8P4/T48zVFLU/V64cZA7FuT+B2cQ2nIWxPwX7vRwP7bY/VfkW+kzGtD+aa6GSFmW4P9MY9BJWF7w/rXKdUctBtj+j8ctyFpq6PxnYta4/obA/ELK0c4pHuT8zaMxgZ8iyP19hatDCFbg/WR2pv1w1tT8amOV+Q1G6P6dM3ObkArQ/tJFpxxdQuT88iOhO6GG1P2lE4HffCbk/tPpQ8hiHuD+2OqEnMva6P1mpDEkeNbM/2d+7QfiytD958EoY9XawPwLbufS8zbo/nmA01UiVtz+Sj67IwP+zP+iByCUK7bU/MgrpqLV7tz/mr1cJOJK0P4OYq3AbGbk/zc2ujpYktj9bhlzf1Na1P+jmTLA7fLk/ZKJFPBy9tj+WneKL++a3Py/PwtFcjLc/ZYa+AMXKuT8DffBnAHW5PyvJcIFKpbY/LU/n9lp3sz9kHmhrtHC3PxSVhRMGg7c/Ou7EsGX7tz8IcN+W0w+3P42WJNC1nbc/n9OdR9vOsz8YfjvNGB+8PwC2NQqNG7s/YmGrkxbqtD/tewJ0ly+0P6fSMLga9LY/gIAgbFd0tz9yux8UVEW2PwBLX3GHD7c/bNVc8ZLAtj8NVMbRlDC3P7kMApKgGrk/QLiNZGtzuD+8NFba5bi3P74UpS3ggLo/ZeBx3fygtj8SeclNDyi0P9OYoeNGubg/nKfGw40TvD+LI55pfjW5P2ItJaKVHbc/zrF6HEsJuD/qNfdx0bmxP9bvM8JIW7c/z4wNRXxquz/6HvQy0TC2P0hMqcmH2bM/m7M6JYHiuT/qChtAV3K2P3sLIPtX3bY/Q0OXgOJjtz/MHLJwRCa4Pyl4WKgFFrk/+Zu8Y8mNtT/NwY0DNM22PwQxVl9+E7M/Rf6v1fnCtT88oXw7LTq7P4v1KYBz6bQ/aYOrwUDRtz9Ob+Z34jG1P8q+1i6lQ7k/Oq5lS0ySuj/jnpuG4ii6P4j43nG4qLk/Z8AnTa1guj90vWyxoA+4P0Vc01t3rrY/ABfpWzdgtj/LgKI8zLu6P5ZGq3tCBbs/CZeUgHYVuD8HtK7Qp/O3P5P3ZNO5m7c/sjYHyhjmuD89EZBSC8K9P08byQbNZ7U/qmPY/iwtuD+zyd67sgi3P3Sqg+WX3LY/DCEZwX5QuD/8fAF6MHS3PyW6H0pztLY/SrgCR7OGtz+Xat1P4UG1P2ab+8zg5Lc/dsR8yy0Auj8X/o47Wqa5P1m2UbjQdrg/v3xJpf7xuz9wVje6PC23P5Fyu8dbH7o/Gc4YnTIptz8QD3QCyG68P7eMMAyAGrY/BCN+VYYOuD8Py/kOyXa2P4UHnqToerk/UaQGVKo9tD/5U4zngAC7P+ZbT9LaPbQ/9b2n/gzOuT8fDF8AZoO3P1rorAbonbM/EH0SkBQnuT9DmQBYDnq3P+oSoy2dm7Y/Vf6cEucdtz/Sz3wiOQm0PxKsreuNB7g/hqgIXhmYsz+aEnSHvWi4PwNoxPBN6LY/o94QJu21tT8iqceaJLa4P9hO4du017Y/uo5LAv/Wtj+aR2Mpgxe2P3SgbE0Bz7Q/kiL/GSp7uj/sfqZxYZG4PxlG+LJCY7s/uMMy3CM3uD8dqPLB26W5PyYruEG2ULo/M2WR5x3ctD+JQjto2Tq5P8cAb9lhyrM/FNZuE3FNtz+tABQIeKS4P/Xjg6WEHLc/cXmdwGkatz+Ig7vHTya4P2m9iJe7b7M/sXOJIQSStT+I0HFboGq5P0rzgZa5Pbc/Xe3CwYXutz8or8x51Dq7P3X0CeeYjbc/trT7eRG0tz+foqmnPSq4P7Ed1UbMH7I/nW5+nFS9tz94hkb2iP64P8glUHR3c7U/eUEacM9fuD9VzZ/nD9S2Px1iaV2zWbU/+Pzr7KLFuT/kX85Aife5P/CzuZfa4Lg/1Cxbwtl0uT/YTIbWyEG5P4gn/PEhQLk/I4ZCso9euT8OmvSIGzW0P9ffuCsGcLY/vFS9GYSTtj/s4ER4Jx64P03NhKwMXrc/HXcnaO9auD+N3kLf/uC2PyZ8VuC2y7g/rfnz7dzAsj/9KlnjViu9P+J5T/nnz7M/cLL99cPEuj/EBro4ynW2P8ZUkBIXQbo/2WK175qNtz+5nRghq2q3P0C8L2uBb7Q/AftsliY8uD9DgtwA9q+2P/+zLGxvmLg/XHOSmNtruj/ckFuM4Cq4P8dIWLG9mLU/OLRf+EHZuj9mAcI4pGi4Pyyi/0sHULc/YipeEBVDuz8T/MuhAFeyP+X+WkUKnbU/M2MhpnANuj9MFSyiR7y2P0wVG/XJIbU/c65NkUpAuD/T+DkeRlu6P3V6IRY69Lc/GImuzVbIuT/kITTXCpS4P6mvqL6UrLQ/pRp3+J6Quj/3btYEI4e4PzPH3wJChrY/2T7vP911sz/oX/NTuGi2PxCxBCmG+LU/dWuqBVpYtz/Sf1HYZj+5P6YbVj+13bY/tV8uAjO5tT9tkHpG0ZS1Py2SyGYzr7g/Yx2sswxGuj8Ju0jRGE+4P6SvF2QAbLY/v057jJE1vj/g9iMD5DG2P/3pNbh9MLo/6smTZD51uD8AweTT3FyyP/JthRGJx7k/q7nF/vcGtj9DVJmKMSK6P4CDO9yAqbc/2HeZYhKdvT/4lhSuMJS3P24NO5jcq7k/FBR5W6yxuD/XwZ2CtmC7PyF59Yz+YLo/XSn3P10ruD+dkXzl9ti3P0QI24uRAbg/jemUUesOtj/n0Uavw7i1P5SHQLZp27Q/E09Ai06jtj+BsOfFiKu7P76MjYNDYLc/YHfKSQRAtj/5Vt7Pjae6PwzuU8VP07Y/EnKxxhhGtj+cnfqOtU+0P0s5hK3E97o/316sQ43kuj+FIGljUEm4PyQH3M8v/bU/9tg/QGYktz/83aBtg322P1gSmcPyG7g/WYdJV08VuD9OzKKoq8e3P01bCvhRIbc/hfd+ILHdtT+NgPySVRO3P9Rigc1f3LQ/6Jp1j1QyuD8qXdUJTIC1P+HG8Rv+ELk/wZ5n1bZ9uj86leDka0a6P5XphAVAxLg/fFFMLV72uT+pJeqJd4W2Pw5GrVjFTbk/c5FbQeqmuT+haCBRw+a1P0jkajHQxLc/oo8pgDVBuD/CJCUAQi63PxmRpDxeQbc/05ngOkSOtT9KtH9oAjG5P3ao35+WyL0/oOa6NF1isz8Ehte21xu3P4o9r6xdALo/Tf02LZVCtT+tAnxfUqy6Px9p0HwoTLg/gPb/CbrUtT8MpQ2Fw8azP0b0ZySZ2bc/Y8CrLxzEuz/tTRv0bJe2P22fAeuE3rY/BbkOVnWRuD+cB/3b67yxPz6OIDB27ro/hLnX1mHguT9Q1dsCLQe3P1aTn/HiWrc/iUVGFyUOtz9QxWWdKMK5P8c1Y0T6rLI/7t8naLm7tD9gEa1LgNS4P8JsKKS8Abk/XL6jdOxWsj8jw+IK4OS2P6OgUF0/e7o/wP9fBIWQuT8yiob/Ype2P9jX3A4vrrY/eeGBBj4Ztj/UvBpQt726P3k3niMprrY/LLpJBmLjuT+Ihep6H3C2P/RoDIs24Lg/5DuBkMMVuz99A/nLQVm5P+K1TQ7rerU/PXoKLlV/uj/oSCeA3Nu0P35sQokTTLU/ybCT1OmDtz9xE8GDAG26P8AmSHzg7bY/49jpSuQFuD8pm37osoK7P73Om0VvDbo/MFXCf9G8uT/HaABTQQy6P9dsVBRf4rM/RkKLfOBauz8+RQ/9Uz+1Pyx/HMRfxrc/YvbKFqY4vD+4ahLx7uK6PyKhy7o4i7Y/qCf6XiDptj8Ro9Bvcsa4P32Z8LKAnro/eiiJoB/JuD94X4hYfV+3P23ngFttq7U/KUji9BMZtT+20pvL0PW5P8TdcSDHsbc/NDjnXqzUtz8rdt1Hlca4P3hmxz6x6Lg//fUNKuastz8lCHvDhH28P1QEcKlfZrg/Y4tURyBauD8lxTDxf6i4P0u1KTld/LY/RldaGdL4uD9Dzc2quha4P/ZOgyjI07Y/FKOHnLR6uD+CV0aTvCi6Py8d+Sn2V7o/BLv7AEI0tz93SwKDwYS3Pymgc5Da27k//KOpN0x+uD8I36FMWpO1P/6oFutBaL4/x4sKyz6DuD/jtj9ClEGzP6fRBzWnobg/84eJaK7kuT8CVjNlMzy6Pw4Dz7y4j7c/Y3XRD49RtT8a2JtQINi3P+O+VGAN2LY/nM/ogWQ2tT8UfODejFu0P4j/oYx10rU/wCM5yoUwuT8i5Gtd8Ym4P+htqMBW9bU/NIC9G5ZPsz/NIVp+8Qu6P7fBv148jrk/kz/dNB58uj8T0SRMhsi1P6kY9zVLqbk/WHWK4hHiuT9S6jDQzVO7P7hiVp/fbLo/FMt8JBgvuT+DEvBge9K4PwfPbzoxPLc/C4shKpvFuz+48fJjtPi8PxGWvPhHLrw/+eJvWemSuD9OZ02Fqza1Pzszz7DKrrc/se/qRIk/uD9LKzF91Z20PwSLLJHIGbg/nQnvZ+hwuD92svXyv2i7P/Pc+hI4sbg/45uFtErquj//kzNl2M23P/ftDpI3CLc/aOcrNDPiuD8FHaaeYSG5P/L+EOWD6bY/0C3rR8e/tj+stRBP/3y3P431Q8Q0brY/hbjkPLK4tD+GgLOhPUi3Pz0ra+3MkrQ/YoqZUDGIuz//XGegYUm9P+t3w6uIQbo/dPfIxpM7uT9itpl0clC0P1t37ZI7xbo/J8WiQ6hhuD9/6sqOdLizPxDp+MMiPbg/wETbk+e3uT+cjl+KGW62P7lrWeJyxLY/Bj+CRfaYrj9fRP5H1+22PysrS79Rlrg/twGi3W8utz+FHSyk+ES4P1YJ6nRqXbw///tGm/UIuz+ozlOa18CzP9PN52+qX7c/nyuxhYT4tj+2jO/Giyi1PwEE5xOAIbU/eTHmN4WUsz/4Z9v5wye2P4POIXkQaLc/vnhTGFvrtT+9EcQjk1+zP95n9vf1QbY/Nb0NFsOgtz9bMZ63OZm3P9mzN4I+ubo/xmnIJTPJtT/3eoLkyHi9P0MblK5hvrU/TS/4oF9ntT+VH6MXDL61Pw2HEZMY37U/sMgITzGkuD+prxLpSXy2Px2wf1CmMbo/a1yhgE0Ztj/7hT7g0IO5Py4mn9GSdrs/kk4O+QCpuD/KT94OZHO6P+BfN8wum7o/RvnLLCoWuT88FvUsGAW8Pxks6u6SN7c/TUsK2GNJuj/S4ybJflW1P8hb+nraDbc/ww+/FofCuT+6+JF2qo61PwBmh4byK78/rVLJBz47tj+pcH9k0UO8P6JlFj7etLU/1lNDMhoPtj/c8Yc8zrq7Px53KcPvjrk/NEkRJN1ouT+V0gwlnP22P+XX/74kE7k/4kvjGg9qtz9535AC5YK1P3Qd9muJC7Y/doezUCb3uz84ERCYDS66P2HeTtbs57c/B/5fvltruT9ZEZR1alC6P3wqZH7hX7g/drqQmvDouT+VRwJc2Ji1P1s+k7Hvx7Y/gf1xPtkDuT9Z3/SLrvC0PxJHtGJ4yb4/Ew4TyjSEuD/O7ILj8a26PzGdFP/607c/T4QLIwvmtj+wRKu5Moq2Px0nlLXhGbg/38nKy8YvtT+Tza6ejxK7P3xoXhfHe7U/tWvmf6z0uT+Nyapqxje4P77MeLX8l7Q/GHezTbuUtz8xWkZA/xm7P21zkv1ayLc/REsYiw04sz+yikJUDg+3PzuYkO+TTLg/gpQy7kHTuT+F62j4OPy5P8goXc1js7c/hy2nbfYKuj/ohpgS7Lu5P+XCOhLNxbo/QDCqqRICuz9lUrJvjSu8PyB1bCnIiLk/ZXs7/FdKtj9X+qAoJ/y3P3ezj2WNd7c/p4qBXsWjtD+KrFcpeTW2P4/PJaixKbk/ndsWQ/tVuT+PUyPdtHy4P/vIacZgTLY//ZNISl7juj/lgPZbGcW6PxzPMwyAdbk/ecDerYS/uD/2JhztqxO5P+lbPmUck7c/qSp4v/Nitj8pitWpSuW6P/gX6A9pFbc/bO0gSYY2vD8auc9wC3i9P1lrsu5Xsrk/uuQRGyBttj/deC/83zW5P97rO5GWE7Y/J+yppyD0tj+dXmSPQqq1Pzu38omUP7Y/O0ISiCk+tj9cf9NSrZu0P+tI8lGgSbo/L6awl4QfuD+Mxxevw2u2Pxu94lnulbk/8sbjibpntD+fmeQjYk24P6+oZmuqTbY//EIOuFRttj+5T+RoH6a8Px6hiVGgnbY/b9ujAiJRtD9ybyBYLc27P+c1WtpWtLQ/lfuYY1rCtD+E/0FNMpa2Px5p1DYS1LU/4Y4idldxuD8GGwcyBx24PxaLEkcifr0/rcFaF8dQuT9OJSVVHpW3P7yym7ZSlLU/hroxHm61tD8R/HQ99hKzPxd3U1OA/bo/qs3rUd38uz8hEH7bC0a4PxSS+uRTsLg/DT4+ZPdEtz+6NeJu29u6P6vm8/e7Qbo/CdWBl9tUtj+rWtIeGga5P8SDnfnv5bY/2b7dscSfuT8fX2AmyHi5P7TzcNrnfro/50PG7e0Gtz/NMOxan3W3P41Os0SwhrA/T8lB+ijFuT/thKA7qUeyP826MeLI0Lo/350zGoPpuz+GdLZPlNe3P6aKvQfqe7g/RA6rLcVQuj8Cxm9S8Mi6P5Kc7AXkRsA/n+ug59wjuj/eM0PKe7W1PydOfQU/Ark/hdmVN1w4tj/yVOlYeEWyPzF2Lq7JqrI/aPEKsCnBuj+lTSDC8Zq3P2to7nL8vLc/3rRrwbk6tz9pnTDidsK2Pw2PiTYXY7k/OC314eQptz9F1VSdZ+m3P5z0F20hWbM/VR1K12mduj+DbJmaxYq5P+VEkNdWQb4/pvNrWINiuj+Xy5bQ0hq2P1zKABvgwbc/zGs+fJJCuT9KydkgvKa3P2G1Q+jql7M/50tir2+1uD95Crx3rhu6P+Wjk1VAdbU/coNSSk5ctz/1FmfVfFO6P0Riq2t+4bg/P3MHYrqjtT9ED3jUGfe4P14jHM4IKrg/wKN8fJe6tD/ylmrOlMK2Pzij8SIpG7Y/vObmxkiBtz/x6qfHqIyzP8bgJxQGn7k/G6gxn0aTtT+xm9lpm363PzN1ayih1Lo/SQrbacEBuD8bVnj8Fj25P3cYrP15w7o/cQqjfMuFtj/EHZomdfW2PyK5X46R4bk/er97JEL3tT8P1b9h6UK4P8UQinwke7o/tV5zhb6VtD85/uiU6fG4P+RpHsZpQLc/OF+CStdHtz/1l0vwB0q0P2LkiH9Yz7M/d9ydWGQ2uj9pbY59biq3P1arKTYAHbM/8CGIb+34tz+yn6cgv8u2PykoDTGTobY/VhEgFEhEtz/m0Z0wD0S3P1/UHOOrn7g/sJjc7BTKtD/XiAsxDAm0P2OA3yVc77c/erbGBkZNuD86sO7Y/bO3P0wp2IvbcLQ/ClF1YeaBtz/Kr1iKflS4P8pFUyf4Kbo/ivBybp12uT9IlKULosm2P4WxXvIrI7U/3N5z9P+itz93YWtxI+C3P55SFpkpyLg/DHRR6O1euT9TTWheEKu1P4hhGPBeurg/HdkbAH3nuj/IyKnNkLG4P2AR6rQk47U/82a+MdJitz9plgVQv223P5K4CR0Febg/UkzhH8x+tD9wQ5fpyVC5P3RY9vetOLY/kFzd4j2euT97E9xTS9+yP6EZmsJ71Lg/4C2AqxpbuD+U6LJJRoS3P20zbI3lN7c/WIiZmzSAtz9GPbWB8MW6P2e6D0CY17Q/rIjkAO2jtT83l5ddPWK0P6VPwPW2WL0/oZsjeLkKuj9Ss85CVrq2P/GVMXouXbY/V2n4iXm/tT91b8jwC2S3P5pAcIjeQ7k/yFqalf/xtj/mno7tChS4P3aObceHt7Y/p8nuGT8suj/1ybI0lM63P11Awah3yLc/VQnN0feltz+XonlUQT64PwmxOZk76Lc/amZ1TtjSuD9u6C0aPo2zP3BKFE7Ih7g/edSOyqSgvD+c1s2tOQe5PzDuFQh1CLY/gO0FFIrPtT9taIFFDQW4P6nmwSJGdLY/qAqmxSIHuD9SnkW53ky0P5bOGPawKbg/wDrkBLvOuz8QtF4M3/m2P+jxEiP2uLg/hXs3pSaxuD+kzphqNqu3PzPVHtDs6bU/8hnc2Qmhtj/YMN7+D4e6P/Ugz6KCbrU/gghaUsEGtT+9zi8ufzO7P530013/YbY/+OxmoH1Ltj+ZG0Vgag21P/+UlAQ3/rY/dt/oVSL7uD+W+vdR+bG2P33PWQ21Fbk/YDcdVam9tj/DzOAU6cG2Pzxqq9aIrrc/g+Fy5zmYtT/fFdUs/eKzP+Lo+3QXiLk/4zuyfISqtD8DIBhD0yC5PyBhPw+HELo/n0uw8WqBtz9hUNiNIuu2P5AhQwUlfrc/LZMR3NM0uD9QsJoMHPa3P5qm0sQdELg/jC4XogSLtj+yCkgNnK23P/aqafqb97Y/n3wi/nP7tz/WjWUpTeW3PwvBHzzU27Y/W4zvBV/6uD+L1hvemlS6P6s+tG68drk/xmN+M+Sctj9MolQcgeW5P5wFBbGDdrw/WxuwNDmEuT8nCmkZUPG5P0NndSqmUbo/pw93Y1tatT+Stb4olNm3P7/bQAqkqrg/ky/2NCBPuj9/1Op5b5+6PzNwZz50LLk/uW1WWRmQuD8/06aoQT23PwegScfY9LU/aQdCNPbBuj+XkbP3oQa6PyU+ST5ncrk/2/MRgFIotz9XISnqIgy4P3GnFCuECLg/a735+gaytT8NH+7Dao+7P38njsyFA7c/33xeWIb9tT8qpSTvPIC5P+adAbnBcLk/wG8YGiMJtj+vsiYKqQq8P65Ud0BP87c/5o8ekMH7vD+IsDSHA5+2PxI6elWtXLk/6SH+AqiWuj/CI1mmUg+5Pw6Lnz8Ftbc/EudyuQnWuj+VMLnodAe2P5vxIMlfULY/7VXumKwPvD9LIZ62ohK6PyAtl+zWOrY/ugLWuHhXtz9dweDO3w62P9X7enAWv7s/vgHitslhtj/oTfHYUNm2Py6OPT0LLrg/AO53tBEkuj/NSZkS+mG6PysG1p2b87E/AyORFd0Ytz9xxHXecvi4PwwfMrJ5e7Y/1KEYqlQJtz8d8Vf6f1+5P0TQao5Pero/kCUqLp/vuj/xEYpxIreyPwFpN808E7M/OxiOySQnuD+2O7JW7k63P0xomgpENLo/hlTqaB9ytj8h8ye5yBG0PzO4r7KlpLc/eypNiXITuj8B5o2XMCi5PyvRSnPUeLo/iRMRKSWZuT+x7gIsb+26Pxd8mK8EorY/i1PszQtEsz/07bSvF0C6P3GUx8iJ8rs/sgb2/7dYtz90Z10PuNW5Py+uMKdn1L0/JYE3lf6Etj+quTUqEO+5P+3SxQNMRLc/CtfMd4R/uz/6Wa2urN20PxjRSVaM4LU/iiVArWwCvj+W6/i11pC2P+eCTdHwurk/FuKjF0U1uj+snae0El26P4W47TWPdLY/J2Lr8fOgsz9YMjDMDxa5PxIPzyTwK7o/AlOXBY2dtj/iA9R6Cp22P0rb7SAVRLc/cKx8D6fbuT8SUpNafWi0PyZ/lOEWsbo/PoJGDR+6uD/JqAaWZOW3P2cPZ4lXIbg/MpBSK6l5uD/jup2e2BS3P9avSFc1wbU/yANDgM5mtz9lwxYEacq6PwjLlOOV0rs/Mog6fdWKvD+LH5FewN61P4iNDdiSd7o/2IsvkoTTuj8GsKck68O5P4Frb4Ggs68/+bHL1Vm2uz8aHBC/iWS4P7w3Gml9eLk/d0PVwR6LuD9+6XR8PR23P31L/G9Qabk/Hj8qcUi3uT9bxMVEWWm3P42n89OC0Lk/OdRniuWltj9zqKQKeyi4P5IkucDFNbc/1ekF3ERztT/lItBsPly5P8BbLtL1ibY/k1aKpnVXvD9pSCSp6Wi3P8aCzSKjerk/6do8OtoTuT/khhhAAEa4P9eoOj6zkbk/ys0NzQ1ruT8o8hTZVne2P/Z8RsUdvrc/oCjtAYCZuj9WZBqMeYy7Pye9IxWxTbU/n6MG1W+0tj9EdBNeQcO5P2CwKO7sRbg/0rcib9C5tj+0M4DKo5W1PxA3vTRhcbQ/lv4P4wFZtz+WCcWX4zi0P5IfN/uURbk/NelQM5bKtD+Y4rLXaIy2P0KSSlCG0rY/McAmnR8+tj9thvOjjlK8PzYOyiyDn7g/IlxhPlKjtj/a4Sl8FZO3P1SSb3Rr/bg/Tad3hfEjuz+XB4UjFYy2P8SjWn3XU7g/NG+Qop0ktD+C4ASnPDqyP2x37dJYtLc/44adlazouD+yFl0KvJW2PwRC0Gd8mbo/qtT1iaCYuT9+U+G0iaa7Pwdq3tbyqbg/4OiDF9Q7tz9UjwTrNm+0P1bD4IvlKrs/yuyvlm2Ruj+s54Wb+UC5P/H7klIJdbY/uyPfkOautj+p0vntNIWuP7OQQlMkebo/Z/Ta+BqHuD8PrYnQAnC2P9/OVA1yorc/Uw/CY/youD8WzBA+Wey2PzyN65Xcrrk/YsNiyrY6tz855SS0WHu1PwJ2cgJKqbU/Epcz9acPsz/UxWisTKS1P5LCC1X347c/k+7uzsGrtT8w2zigJa60P7RJQqHbpLg/V7X6ym4Zuj8hHkcc+yy2PxqDfW79ULs/w0/x6yEPtz/Yj6DmefYTQPqU8qIjGdg/85FIsystD8DNonSqcIv8vweGBXTYchrAWvKgU44wGsBZd25qjaD8P+J7jRZW2ibAtpZ2p347FUDPrANLHToawFt7Y7/OdiZAKuX4NqyAA0CSf2lqsIIQQB+P1RBjBRHAz+YVVD/fIsCZftU7v+H5Pys7EuVJ7BvA7DgyU98LK0CAVG738esVwPB24oNxCSRAnJJLjoUXC8AFqaEj2UgWQGGABVv73xrA8mcasttSGkAbwiI+n3QEwOu+4UQf5AZAZjinNt8/FMDtDG5sivwEwJz3wIG1NiTAF8C9XsfDIEAH5If0uzESQHBiT00LtC1ABpGhRVSdIMDewmhMHyXmv3xDflfXSxpA/jVwTYphEUAlNcu0Hr/hv3bLZQ6v6hZAwkaB1ldVDsAwAB0i2iYCQEprhuH0lfQ/Y+rPKAuxEsBIQxmoPLP7P/Zv2EiE7um/yspAKN1+778f1jSVN/UWwD7O4/95ThHAIdbDqA9+BECwusLFtl8XQDoTgOpSxvO/N7i2EtEG+r87uK/CyqX2v9QBTGKMH8E/fHC7HHqF8r9FSj2VlvUbQCKx0mSZoybAleHOQAyjI8D45P3ciJIRQDOwhOF0ihlAo0DWOyHZ7j/4NAZJM/LQv3qTb0xaoQBA+xHVeGam+L8BMgGva7Xav/bTCJOwFdu/ccTC45OsEcCaNGkKw7gCwAQDLGX9AfO/W4cuT59uIcD9HjYlEyDzP7FrbedHhxpAY7HKwqvtCMASjvBpX0YmwEoe9Y5Nkw3AwPcwM06P4T/ua+ObMoHmvyHYHja1hCFANN14Wr7G0L9TtvDsOqAhwFZbDOjdw/g/mKJZypQcIEBsg/BbS7QewAsfROwjIfA/HyE3zXAE7z8NcvDnL4DpP66pyAjBSATARWXOl+4vCsCadIfCVVsMQLElyIB9ENs/69ZoF87DIEC7x/rl9fQEQG1CPT4kzB/AwoC/3x3pEEAl6/XoDuHwv2qf5v/GIRFAYjNJxmDUGMArclZo8BkawIIq/Pk0qxvAhpJNKm+BGsBRIy9/UZQawOf2WGkIlgLAD4JU5OT3or9GJ49HudrTP5Kc36ciniDApJe9glERIMARysSFVDDzv4wADDRgQADAN3iU8FWC7r8UMlPGTSIMwPpMC9a6ZCrABKD40S5aEUBRnEUB0TMDwLX3/96Im8y/5EraJ/JVxL++cvgArp4MwN5Bl0o2ofa/UPjAAdqo6z/8+U4g/2rNvyr9FjviKQ5AffHzsxsK9r/ZF9iUBUkXwDMcb1A1kBXAJEh308IOAsAOjmdU1SIlwBov7ruIo9M/WGLJc7SrE8C/JV1HJD7Yv0hCBiAPhCbAQDl5hxaL8T8dSQcVYn76v112voRcgvw/eMSsPNj/GMCEg2pMOxgXQLXrS8WjwB3Aw/mxgXhSF0AfXPAWVIwYwBeACaL7Zfm/HeLFXJ3hHkCRz1yLmHMQwKGyX/fNG+O/fi2brM8gDEAPBBGtvob4P6gLyq113RdAatJgmaUeA8ANNqiuA2YbQOxl/OOTjwnAlC03UUV047+trEw/vosAQGbeleG5BQDAZJxd5QgS5b9hGPlLFQPWP7eHYKIUieE/G2UNr84mFkBuJhRs5hAgwHcargTLGQTAbPApWePvJcB34V8dSOXyv2SxXCDWwxbAIWWfA8bpGcBUwRmD12MLQBJSi1reGhPAaJaKr9T9HUC36cO4SBIAwDSh65IOewHAWa4PVm9o6j+qOeH5M07WPyutRBQVzxHA3lx/hpZoIkBaySYq3NIRQHTXJVzzxRXAwTZ0ABmv9r+DS8IOWdMNwHPfklNi7yLA8vXvcP6M87+IVumjYWXkv9CJZ1847f6/CajIbBGnIUC0ewVIv/X1vyyF1B0BhhbAtviAUlPOCECAh99QRt0HwGgXYUzwnOG/5ThzUJEoBUB64NI74lwcwAj2CB99tBnAe0kr8t3sFcBuKvCaqtYWwDVaWYYrXRHAU8FmsUssGcDH9Cf3OhsWwAlpRXqmzxZAUN8R2d7W4D+E4Zud/SzyPz6E6IYveQTALDwcDT3R5L/r1dbetEoHwL8feeEwz/E/HlyWo9obEcAcGxwUGOkkQAVEtCHV/yrAhg1AbHUIG0B8BosYI+wewByYB7BWlfo/oBfPmGv5IMCvE9eCAd3kv7pfHLGv3fK/MBt65AsdGUDq+56RiCYFwGKD32aTzLi/aiTHKY2AEsBF7Yak9UMbwBTsVBdfdALAUt3Q+eh1EkAXf2TCcNMiwEljneIRJAXAw14OQsMm/7+PcDXtjwgdwC34RDiARSFAhEgCcPUvAEBbw+Fk/tAWwGqKlICtcPc/7C0Kr9IpFUBhnCdKAnwEwI8qolmwQhXAHB74ts/x3b8M1Zwc/IIVwHQoaLzFXwTA7V8fOKDhFUBRvSoQ0asgwApV1b5vkhPAyNJG5KI267+iuAEDfd4fQPTfq5/MQ/M/YzT54Cx6AUBt5QRULMb5v0yRKv35GhTAkyA23Rd53r868sMhKgf5P9+c+V/7QAtAgPWg9yyjEcBtpesWolkawF2IXbRRyA3ASfzlN4yXEEBZyH2h/oswwM63N/qU5fI/fSPuXNvTHMAtlXj4NooEwEqkJ+nHQSBAo+UkoVf3HcDpMfWw8SIFQNp36JsXwh/A382sZJrL6L8C+8SUIskrwL8UcM6ONfO/is+4Bgg6EsD4y2meCzgPwNEzMQGhPiPAQClXtfxFGMC8Vhso4t7Dv+JE7ivVYfO/YmyIjkst9L+zHBYdfmsQQOMHJOd7nApAQLyrMycrEkAtVRXUnifxPxDYks2jKCHAd3oDVw6+rL9iDQdMLl4FQLNSoQYwDBrApaQEvxfS3D9cN1QG1nACQFHGL230Gx1AxmDLXxCkIsCdBIr2M2MdwEaL4s1aWArAlg64pqaeB0BddAU4+QK0P2pPmq485+o/qETNjHclDsA+0m4FQ+jtv49M8byqdwTAEyb50bO2n7+04MsKwoISQOnV8YXX9tU/MrNLiytXE0BAEloqO0sNwAXCeDzbYAdAOREU03IxE8B1aMcYu+sdwJ8bUx/y/xPAM4KwxTPuAsBzt/4ZBpYZwMkO/c3vK/c/JMJ24utiDcAunsSGbTcdwAtCQFGFcgpA8l7owQjC9b/2vw8zW7MBwByvgG8/ada/7gbbPa+ozj/As2ICMlASQHF3GpsNmxfAFBe00CsBL8BN6N3s7D0hQLRZuAqMROC/COUJNzqjGsAlBv6LL5MKQE/TywTVQyHANFIYyxOQ+7+bFzPjPTsVQBlc6pK+ehxA+mRz1Nph/b9jU96giYQmwOSqIQFXseI/qmd3VUR35L87sr65uukPwLgENyqmviRAzbHzVzO6IcC6/vChIZ0SwPD0EknwleE/iFELyeY+9r8vEqQBhcLkv5mt3OvvjhrAAEy473usJEAAGo2NzTAaQJWp5TZiFgzAEwygOXQ0C8BW/WDIGJYjQDFPAeMo+fO/YVpjsAU9FsBW5D8r6OoXwAEfG420It2/JO1T+Qad+D8swFGzaHQMQBGYt89P5BnANFF3TjHx/D92aRSP/NEZwFfdS9upNPs/xu6pSupPDcBfF1/7zdUhwEjz7/jrHRbAvWnmo4thEUBULf6qL9QUwBvDxs0JYAhAuSuJlvNDD0DEu+eg8q3vv3isVzo5nB/A0R647+745L9vbqbyAnHAP1fqdEqtQCDAEjnAVR4dGsCwxbH7i/UTwFfTNaRalhbAuugch5w7GEAIF/K2UkQkwPsElaPo6g9A3zhcYvMgAMCALGetchInwDk7vuh79B7AS3ViRHK9x78Tcye7inH0P9Nso90k4wbAdaaZfkx+HMAHvHRLHlcVwKav4Nw4GPe/WWrOqtuYBEDGU8jfnkAOQAIFMz3TeRzAujRV4vu697+i5dQInzzdvzKXYJSqcgzASUC9Wzo7EcB/UPkRPj/RP7xYCYJIBinAocj0W6KRDcAdH68rIG8LwOhTF/3LfgbAoT37nGlu9b/GDN8GKIgOwGgOns9RUsw/Rjg3iqaX/T9RNDB59cUCwC/+pVSuXxbAZ+1sroOyGcDRIyQ9jaPsv91fPiQ/tPw/MRgaFTRZHMAiDSBNMp0NwJk0WVjTdf8/boEVeCswMMCrDlZ2tjcHwJDflaKsCh1AgN5Ic6+oDsAalaCjdrsUwDmW1PUU9hjAhBW62rBt+r9+7n+kydsRQFJ89SaGfvG/o0qZQlOM4L+S8C9Z2lwSQMaOtlXNYRJApAhP8prx/D+UHpdz1LYTwAQPbNV3sg7AYih+rtlKBEDDQ1JWXTwhQD+xOcMydyHArCirbnFjEcCDY5bNK9QgwHKwx9yzRQhAnMsxvAmOFsClknPc2ysYwHbuw8jnISHA1KY8SdBNHMDxXufKCqEUwEAZZYklPhLAef+RPAYk478jukt5IlcjwGfEkLXvlirAoiCFe4NiI8D3P+Q+fIQDwOnTncssfgJANKMVBLc4/79UwHhvEP4AwGg4r33hQBdA9dOYr2thEsCrW8hyBRr9v5VOCp6p/CLAt5P6tGj0CMAMShdM94EhwI0cJq63hfm/cwlq9L/55z9IHno+zPUQwLtJ7WpukRPAntvBvkV0BEB6uKPDFErnP95V06G6kPW/ANnwpLXp9z/MrjQQaC0VQA75hF3fzUY/jDJyM1L0FEAq5akTTboiwGu6kGvM1yvAUT8raTDvF8BQ+/5dHaUOwA85T9o5+BZAxEI3PrjVH8Ap2Uae3z8MwKc7NqMhVxlAhDjSs3vOA8Dd+JbS/nQYwBmPWz4zHQ1AgGIV22F2vj9bKAYqNWcwQL5IWAey+M6/8knkSCEiCMA7CePTTsvfPzgLH0OKkgDAdW0ouF/HJcD9Yw+MyoMiwKKILsaIsBtAHzvNGA6b6b9QZ3Y65v3ov2N7/gneQxJAjjje6uhZFUAHZNK+hZIhQDW1p7ZjXPM/VrfFlTF48L8woNosD+8NQJVfvk1c6iJAK6hvUYFpB0C49hdAD2fKv22o8s1fcfm/AiviOpReIMBbiB9kiO0QQN1xQunNdCrA/s5z+OLFEECKyCd5dBf6P0eEFzuR0ANAkiVavA1CAUDUTjtzrfIDwHkYMusK5v8/BtmopDgzGcBr2jEaeMYBQJULqr4buxfArhAXniamIMBr2zgkHRMAwDv3mfpkDSLAZhgEw1rrIMBvTMm2YyQRwET6BP9b/SXAirZiz0Pj2r9I8+4qXxsgwH5lde1I3AtA2Hj0dr3I5r+SjyGp7FAXwL4dI36jbwxAo2v6eI49McCeywtGVT3xP0RyBRIkYynAxD0L4DSXAkCOUeBV5bgJQNDg/adEpCbAdCHPwzN4GcD8Y/7GiP8RwK8CZ0GSScY/ssZXBbs4C8ALYuUICJb3v+yCBrn1QgtA50po/rNwAEB7GMcNttwjwL8vOsOfvhvA4m8B7XvM778YjAo5n08QwOq4tF4OmhrAclezfARJCcBwvHp1KUYZwPPOwpQZaQtALnJ2Q8Kw6T8UMN/cQGYKwLcYY52SsQhAhgCyP5WuLcCSrDjbwT77v8S2fLfB2CPArYjBllNg+r+JfIim+erqv2culufiYP0/kz/YWujcAMDwudvsSukGQJogdqfNAyPA4yMQtW8jD0Drrnj5vn4YwBuyl7vW+wDAmwRRiDhqFEDqLkADFmHvvyqcjCuohxzAfMocNAzr4r8tCmtncuQgQK71LcacWPm/rone7UolC8D1b6zBEikRwBTuHwIpUyDA7ZttExG//b+BnP96eLAWwOwIaCRXohPAN/yDx9hUIMBS3xoXKZcjwHiNDR81qyXA1lMLjCSjFsDCV/j8+RIBQLkaDYJioA7ACx8a9BGs2D/ZLgqHtLUUQCFSJCqI5/U/lfnCEA7pDcCGCLbpvzAWwDZgM6BxzgvAeUIBCzl11j/NLB6K4iQgwPRW1WZEDRvAv67MrShSC8CrqXjZVLoHwLcCYA+RVhLA7wwItB8u+L+6Tc/0vEfxP13uQgdgiB/AismhhxPu0r+r1jQrcqwjwILDXfteVirAr11dHnzjD8BmtXGFOksAQFs9qhE2GQnALdGwwgNf6j+xyDrAcR71P9rzB1ygLxNAA2SVFrSAA0CZaXOYw/rdP6ZQUECUAxNA5zjTGCV3GcA0TdDzrjYCwL+53S3FNwJAwIDn+QFwFcAuI2kMYyoRQPPtHsYDOQrAKgac3trY+j+YfoAxqYHCv5n35DnuYijA+nO9dhOi6z8XuJePXOUfQJW5G3W6DyPA9/SeOu5eB0A3CupkMDATQHJbBeuBmQNAbA9heMwEEUDwgmGsELPvv9R4Iz+09/+/92gJDzIWK8DWJRzN+MEWwNDCoOH3iI6/VrILvoKLEUBhgdX42AAWQOjwArm4qRxANxrPUKuAIMDUL7wJB3IkwPO70+DZoeS/KpichydxEMDlFs6VGk/TP0JHDp6ZpRrABgGRqSULGMAII9dNERwHQJehe5Z6pRDAHbIHh4tT/b8bmA+SIjAWwAnVl2RV3xTAyz6h6aYLG8C3tC7jgCWuP8oNAV16ZPK/bH9dQfI8MECsMICC/roTwDP7dV2YayBASmErPYn/HMCV8FgMvGQkwINH/RmGbAnAmFeO0oUoAMAVhFDLCHAfwKq2uHf49iDA0aqh/KaONsDLj+dvkMUZwNNAo0T7/hBAK/huwZMNBMAe+rEoGjoBQOZOgOou6yRAgUfyxmgRIkCMiPB0gaUbwEPxZlWmre2/GiE/+kpb/r/q/cctmLDzvz6AsAJTGPk/13RWiqoVD8ABaZ7pJSb3P8gKOEMomwDAyq9CCj4QIEAACFmgO5MhwCHgrkDi8RrAVTjjxM+PL8B9G+yN5UAZwPjriuo2aQ1AZ4Y3uXip/r/4Yi2srDEQwD3FWdo6m/G/t1mSu7sGHUBjCudRqzYSwDtRiex1QBrARZrReixNA0C4+0pWxRv5v+obMtY6FSLAnmoTRxV0EMDlGT4JsTEGQGpOSONG0wrAAtbNibpzDMDsTk9N4WgXQH1cvOWwtuK/Sp+OO+8I7z+6zv2tx2gEwGc+mdIf6R1AzuvV0+jOGMAdBtUNypEFQIrBlWJD3wDATsHSFVulIcBZYFJ+BsgCwOhYrgZEHRbATlFkJRJnHMDRPXCJ/Ln2P1jcb8c8POy/vrOutYwGIMATJlF7mk8JQBjhZhuvG/m/o2QJm4T8GsCxCehLc+kWQNMtXLixCxLAjOyiKWxnyD8CYfwuJfbjv46qPcQARhdAys/SM9lsF0BBrR9VQvIZwMZSWqYN4f6/vxW+cuU0IEBOSxSQ/wz2vyuWz2onuO0/isWkA6Fe3T8RFRYyGK/jv+3aPQlnx/i/Hxy/lpwKEMCPWUrhpNoVQIi9916smhdA8z4FD9Y62b9jtAty1CILwJItfbomi/O/efqKfcf7FkDnCaLoO7Lnv3CzE1xkBQXAwik8Fz6CIMAbccN1ubwQwAtugY6rnQBAHjP5bBpiEEAp3J5QUNIAwNuwhKW3XwHAxfxdgo9bA8Cf0iPocY4ZwGacXie5YwVAzAwttC8AAMBtMTWVEbsjwKc0kbOu2w3AteX8sP64AEBazUwxqLX7v8WybI/i5Oy/THLg9kezA8Ay29TsPCwRQFi20vnxtRPA4cSaQmmmBkDQMt7JdRcUwM7n7CpxkB5ADI0wJ9F+EMDHCl/y9UQIwJsrwK51reC/Moi+8PzHpb9snLGX5FjmP1oDsN3KeyDA2r3xdc0AE0Asa8KrQin7P+wovVj7WxpAdgL5gfcmKsCFsGdMDiAawL7eK2EjPvI/EZ9K7JJJ7j/625UwmRMTQPSn7nDfD+K/zCiAQj7cEcC6hn3+DL/4P2TZwNBzcRHAlrAr4Qj34D/rdNXhrHkbwGSvfT/0GBDAfJrZyiDI6L+C4ziDD9IHwDK/eNgoQAbAOQAQsjkV8r9IO2qWvgoLwAC9Zr+UHx1AzQAbqHpTAMCkkYaXspQowP86jpMsphHAIVD4jT3v8j9AAbVvyOj5P+9qtpP34/e/ufo4gVUfAUC5Rwtj43MAwCW8/wsdBxhAusB/Rcg2DsDHUWFHtT4lwFX5+hUEvdE/cv1B7v8yD8CFzM9B00MOwChkmdHnGQHAMxK7oK3yBEDUoIt96p3MP07zxtI0sx/A9X2MGyLfDkCJMjfeCNAMQMubC2XQQyHAaD56SK9P8D9+MroRCpW5vwkM3p8IFgtAwe1gjvx00z+AYCnjuLEDwH2NsKHUBPE/xqMzZmq3FsAH0GS54hTtP7jVD8BQ2vI//Gl8V0Y0BcCW0BCUM7YJQGCNeXv8OhlAvAnh5uWBFMCF4zg+nA8TQBubzSYuvxLASjlqniy3FMAfC1ljZh+2P0drsPsu19u/2+ITgzOc2b8RLECTrMoEwL/a3PwL3vW/G2zavsUF9L/7ENaxLSWtP52yKdYegfG/m+xVi7be8T9+vE6i77HXP8GYBSz8lgDAT2bv4TO65T/5QKpffEsQwHGdoKX0URvAqECcZY1yFcBINW/oHufxP7d7lbiBmx/AhU1yqCHUJcDo8kz2YgIXwK8XtZQUyhXAc421+0gGHcAYQ/e/U6IGQPEETjOvC/C/hp76azxmEsDLcvKZglkdwEWETlL+cSLASq/T/MeZDcAjbxWCRDgPwNnz3/Q70cY/Nv71TyHC9j+x3sumSN0dwMk4tVu5SSDAGvqNRmDTD8AUS/EqUzTXvz3EpT9N8QHA3/4mlZ2hAcAHts9IDGkNQCWo21V2hiPAfq87U+nj5j9eYSny9EcEQB7WrUxwqBbAH0D7A/vJEMAk0BA6ljoRQLimjHZKySTA6c4PSV7eBsBlWY6UAcoswKbVDjnUXv0/PNf3v4N1FcA4VliE4jYewAidgnibLwnA3bJXqxhL4b8wqp85mUcewASSHoyQaHi/M+8fWwwZBUCB3//sKlspwJv21mLx9RnAWeG4+B741z/e2/6gp6wEwB7z56Zf/wJAA0hM1p3EJMDJQ36ydLvmPyrYkNIxleQ/YMQdDTtt8r+dNvua5NEdwHU7Qq6p1BjAplftWb7bJ0AiuEGlFUjiv6My6pBpLxTA9U6QMhnJ4T8EJMPekKGNv2yhxhQ6zxjAB5YCnajKGcCO9EDHrVQiwBnLVwj+MCRAoTsnEAugFUCUw/FZQ9gBwGnCQggpNcO/h/CIZF50EMBjJwT1DZQCQPEa0nbGdQ9Ar3cWGmwM/b9YNyMbPeocwG1Y1/41VxbAmUYVu/InIsDZ5ZJ+i8UYwJEma8Jy1x3A3SHbysV49z8JdlCZyoMgQNFCWrYLfRjAzqC/8DBlIsCOVhn7GiDqvxldAUTOPRLAgrXgy4ZALsDw37zBnlXxP6kp2jkb1BbAuQ1q286rwz/WMpCj+fMgwLkq7OLJEBRA0QoEfjImAkDKjfiNciktwKSD8kY0NPM/ybFa5gBqE8DKEHtiFaMTwKaqM3F7MB3A2Fxzi5i66L8AnbadDzcaQLwEksBl7BXAo2AhVf8aHMCuAK2MTmn5v3RC22ePrvU/DBlRVFzM0r8PAX5fiRMXwMfMi95P/RpATHGhfB8FHcBwjT2wwE4IwNFURvjI1AjAZNfaQPOQ/b/Zm3QZ9+EQwL3CZT5YHsQ/e6JmLpBtDECr6Zs+/Lixv8mwNlqwLCHAyZJkh6eUJsDhc7DyjbYnwODytT/6gglAIt8Zjre+HcDg+r/M8FEiwNDcQmXrgBPAwI4veDa/LEBxGeBFDYImwNCcByhqSwnAPEF/4uemE8BCvGSn4tkRwNe3vkVpx+O/spIY/u6gE8Ci/U/N2UoYwP+3kbIVjPS/8F+U+ZgLFsBkno3rW7L/PzP5o4WegwTA9sRpdl+Y4T+VBqqatM0VQODVHgRwbBPAHJNtGZTQ5D85IH2Jo0gmwMB9t4m+gti/G7bKRNcWFMC43zSkDKUKwN+DplkNmwLAZI5FBAEnFsCYZIRGHkYUwMkgFMfptwJALGkBbU0NBMBjjnReWhobwH0yQHFNqCXAKkK7G/xVDEDzE29/tbT2P6PxxMssQBnAu94Hb3GpDsDX4A5itITevwmnnAjOmw5AzNGJLTJ4G0AIsQASfsrrv0jgYDR+sRdAnWtns5yXE8BGpzELyKcTQDDT/AMnhew/2weAGCJaxL+hjVEMgqn8P4xl+b+sGSfA5p6lks60C8AZZfm5cXoAQGja8Z6jNO6/OrDIhIqBCMAIJnwI4ZQiwF+J8cKu9f8/d+e6dx1I+r9YVIgcnowYQCyq8mXSQiNAVHv4fB8U5L+DeHcdOKoQwCI5BQu7nuE/LwfjNn9qIMBThRIzk44WwG9C+ass4yTAN3EMerYoA8BZ91V4N8XXv7IQE5DTlRBAk1a239ahHcC1+45IlOIYwBuBlKPhpALAejnBCHPys7+WBs0wT+vxP1/W5N4T4C1A6ny9dIyqHcBuqqMtwI4RwMo0Dzim9PI/UWNWnmfP+L/XBuDq+mERwOdtzjYE1PA/lPQCuS6jGcAVQxZIT37Xv9qXhXg5wgxAS/HmEX7lDUAwp9Z4lMcbQIohV+DDEBZAKdMZ/GtMBsDgNaGEUAINQPVDmpf/6QpAluLmvI8oD8A2lpTfhjkdwL66QWb75AFAu4PwcVBFIcCiClD/CRjkv5R0lGKMCGJ1aWx0aW5zlIwFc2xpY2WUk5RLAEsCSwGHlFKUSwKHlFKUhZRdlCiMGHBhbmRhcy5jb3JlLmluZGV4ZXMuYmFzZZSMCl9uZXdfSW5kZXiUk5RoKYwFSW5kZXiUk5R9lCiMBGRhdGGUaA5oEUsAhZRoE4eUUpQoSwFLAoWUaBiMAk84lImIh5RSlChLA4wBfJROTk5K/////0r/////Sz90lGKJXZQojAVzbG9wZZSMCWludGVyY2VwdJRldJRijARuYW1llE51hpRSlGgrjBlwYW5kYXMuY29yZS5pbmRleGVzLnJhbmdllIwKUmFuZ2VJbmRleJSTlH2UKGg9TowFc3RhcnSUSwCMBHN0b3CUTegDjARzdGVwlEsBdYaUUpRlhpRSlIwEX3R5cJSMCWRhdGFmcmFtZZSMCV9tZXRhZGF0YZRdlIwFYXR0cnOUfZSMBl9mbGFnc5R9lIwXYWxsb3dzX2R1cGxpY2F0ZV9sYWJlbHOUiHN1Yi4=\n",
                "text": "        slope  intercept\n0    0.079948   4.990699\n1    0.089357   0.376534\n2    0.099633  -3.897056\n3    0.095368  -1.784043\n4    0.101629  -6.612154\n..        ...        ...\n995  0.096266  -3.894805\n996  0.101951  -7.306179\n997  0.086624   2.236808\n998  0.106705  -8.635379\n999  0.090075  -0.627934\n\n[1000 rows x 2 columns]\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-8",
            "pill": "Show-Confidence",
            "label": "Show confidence interval for prediction based on the mean jump in the data set",
            "geometry": {
              "x": 90.0,
              "y": 480.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 90.0,
              "y": 630.0,
              "width": 400.0,
              "height": 50.0
            },
            "function_name": "compute_show_confidence",
            "function_result_var": "show_confidence_result",
            "predecessors": [
              "Step-7",
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "confidence_interval is a Tuple[float, float].",
                      "confidence_interval represents the 95% confidence interval for the predicted 'vertical' value of the mean 'triple' jump in the clean_jumps_result dataset."
                    ],
                    "algorithm": [
                      "Calculate the mean value of 'triple' from the clean_jumps_result dataset. This will be the mean_triple.",
                      "Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
                      "Iterate over each row in the bootstrap_regression_result DataFrame:",
                      "  a) For each row, extract the 'slope' and 'intercept' values.",
                      "  b) Use these to calculate the predicted 'vertical' value using the formula:\n     predicted_vertical = (slope * mean_triple) + intercept.",
                      "  c) Append this predicted_vertical to the list of predicted verticals.",
                      "After completing the loop, convert the list of predicted verticals to a NumPy array for easier manipulation.",
                      "Calculate the 95% confidence interval from these predicted verticals using NumPy:\n  a) Use numpy.percentile() to find the 2.5th percentile and 97.5th percentile.\n  b) The result is the lower and upper bounds of the 95% confidence interval.",
                      "Create a tuple called confidence_interval containing the lower and upper bounds.",
                      "Return confidence_interval."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import numpy as np",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "",
                      "def compute_show_confidence(bootstrap_regression_result: pd.DataFrame, clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
                      "    # Step 1: Calculate the mean value of 'triple' from the clean_jumps_result dataset.",
                      "    mean_triple = clean_jumps_result['triple'].mean()",
                      "",
                      "    # Step 2: Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
                      "    predicted_verticals = []",
                      "",
                      "    # Step 3: Iterate over each row in the bootstrap_regression_result DataFrame.",
                      "    for _, row in bootstrap_regression_result.iterrows():",
                      "        slope, intercept = row['slope'], row['intercept']",
                      "        # Step 3b: Calculate the predicted 'vertical' using the formula.",
                      "        predicted_vertical = (slope * mean_triple) + intercept",
                      "        # Step 3c: Append this to the list.",
                      "        predicted_verticals.append(predicted_vertical)",
                      "",
                      "    # Step 4: Convert the list to a NumPy array for further manipulation.",
                      "    predicted_verticals = np.array(predicted_verticals)",
                      "",
                      "    # Step 5: Calculate the 95% confidence interval from the predicted verticals.",
                      "    lower_bound = np.percentile(predicted_verticals, 2.5)",
                      "    upper_bound = np.percentile(predicted_verticals, 97.5)",
                      "    # Step 6: Create a tuple of the confidence interval.",
                      "    confidence_interval = (lower_bound, upper_bound)",
                      "",
                      "    # Step 7: Return confidence_interval.",
                      "    return confidence_interval"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "bootstrap_regression_result",
                "type": {
                  "type": "pd.DataFrame['slope': float, 'intercept': float]"
                }
              },
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "bootstrap_regression_result": [
                "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
                "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
                "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
                "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
              ],
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "confidence_interval is a Tuple[float, float].",
              "confidence_interval represents the 95% confidence interval for the predicted 'vertical' value of the mean 'triple' jump in the clean_jumps_result dataset."
            ],
            "description": "This computation calculates the 95% confidence interval for the predicted 'vertical' value based on the mean of the 'triple' jumps in the clean_jumps_result data. It uses the bootstrap regression results to estimate variability in slope and intercept values. The mean 'triple' value is used to predict 'vertical', and the confidence interval reflects the uncertainty in this prediction.",
            "function_return_type": {
              "type": "Tuple[float, float]"
            },
            "function_computed_value": "The confidence interval for the predicted 'vertical' at the mean 'triple' value.",
            "algorithm": [
              "Calculate the mean value of 'triple' from the clean_jumps_result dataset. This will be the mean_triple.",
              "Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
              "Iterate over each row in the bootstrap_regression_result DataFrame:",
              "  a) For each row, extract the 'slope' and 'intercept' values.",
              "  b) Use these to calculate the predicted 'vertical' value using the formula:\n     predicted_vertical = (slope * mean_triple) + intercept.",
              "  c) Append this predicted_vertical to the list of predicted verticals.",
              "After completing the loop, convert the list of predicted verticals to a NumPy array for easier manipulation.",
              "Calculate the 95% confidence interval from these predicted verticals using NumPy:\n  a) Use numpy.percentile() to find the 2.5th percentile and 97.5th percentile.\n  b) The result is the lower and upper bounds of the 95% confidence interval.",
              "Create a tuple called confidence_interval containing the lower and upper bounds.",
              "Return confidence_interval."
            ],
            "code": [
              "import numpy as np",
              "import pandas as pd",
              "from typing import Tuple",
              "",
              "def compute_show_confidence(bootstrap_regression_result: pd.DataFrame, clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
              "    # Step 1: Calculate the mean value of 'triple' from the clean_jumps_result dataset.",
              "    mean_triple = clean_jumps_result['triple'].mean()",
              "",
              "    # Step 2: Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
              "    predicted_verticals = []",
              "",
              "    # Step 3: Iterate over each row in the bootstrap_regression_result DataFrame.",
              "    for _, row in bootstrap_regression_result.iterrows():",
              "        slope, intercept = row['slope'], row['intercept']",
              "        # Step 3b: Calculate the predicted 'vertical' using the formula.",
              "        predicted_vertical = (slope * mean_triple) + intercept",
              "        # Step 3c: Append this to the list.",
              "        predicted_verticals.append(predicted_vertical)",
              "",
              "    # Step 4: Convert the list to a NumPy array for further manipulation.",
              "    predicted_verticals = np.array(predicted_verticals)",
              "",
              "    # Step 5: Calculate the 95% confidence interval from the predicted verticals.",
              "    lower_bound = np.percentile(predicted_verticals, 2.5)",
              "    upper_bound = np.percentile(predicted_verticals, 97.5)",
              "    # Step 6: Create a tuple of the confidence interval.",
              "    confidence_interval = (lower_bound, upper_bound)",
              "",
              "    # Step 7: Return confidence_interval.",
              "    return confidence_interval"
            ],
            "result": {
              "result": {
                "pickle": "gASVfwAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCGva6QI6uEdAlIaUUpRoAmgIQwi83o9oOZtJQJSGlFKUhpQu\n",
                "text": "(np.float64(47.43927036684621), np.float64(51.212689466713954))\n"
              },
              "output": {
                "output_type": "text",
                "data": "(np.float64(47.43927036684621), np.float64(51.212689466713954))\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          }
        ],
        "edges": [
          {
            "id": "2",
            "src": "Step-1",
            "dst": "Step-2"
          },
          {
            "id": "3",
            "src": "Step-1",
            "dst": "Step-3"
          },
          {
            "id": "4",
            "src": "Step-3",
            "dst": "Step-4"
          },
          {
            "id": "5",
            "src": "Step-3",
            "dst": "Step-5"
          },
          {
            "id": "6",
            "src": "Step-3",
            "dst": "Step-6"
          },
          {
            "id": "7",
            "src": "Step-1",
            "dst": "Step-7"
          },
          {
            "id": "8",
            "src": "Step-7",
            "dst": "Step-8"
          }
        ],
        "image": null
      },
      "tables": {
        "tables": {
          "triple_vertical": {
            "table_name": "triple_vertical",
            "contents": "triple,vertical\n383.00,33.00\n781.00,71.10\n561.62,62.25\n624.52,61.33\n446.24,40.19\n515.30,38.96\n449.22,39.69\n560.91,46.51\n519.12,37.68\n595.38,53.48\n686.42,65.85\n601.67,57.60\n553.23,37.66\n529.22,41.70\n561.16,48.98\n465.88,34.14\n497.30,56.12\n592.71,53.91\n679.95,67.60\n531.92,51.29\n562.83,53.82\n447.53,42.05\n683.56,48.55\n630.60,66.76\n644.69,59.38\n479.34,43.68\n745.95,66.14\n667.12,61.50\n411.63,37.65\n483.32,37.59\n638.67,60.10\n477.62,42.57\n467.60,49.97\n400.31,48.42\n586.62,52.41\n513.26,42.27\n464.71,35.76\n403.22,34.96\n475.63,41.84\n568.04,47.53\n",
            "md5": "c7cc20224b239b2bb69a9501f2c31440"
          }
        }
      },
      "versions": []
    },
    {
      "file_name": "jumps.json",
      "dfg": {
        "description": "",
        "nodes": [
          {
            "id": "Step-1",
            "pill": "Clean-Jumps",
            "label": "Clean Jumps data",
            "geometry": {
              "x": 90.0,
              "y": 70.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 350.0,
              "y": 70.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_clean_jumps",
            "function_result_var": "clean_jumps_result",
            "predecessors": [],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                      "clean_jumps_result contains no missing (NA) values in any column.",
                      "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
                    ],
                    "algorithm": [
                      "Obtain the raw data by calling the global function `triple_vertical_table()`, which returns a DataFrame containing columns 'triple' and 'vertical'.",
                      "Assign the DataFrame obtained from `triple_vertical_table()` to a variable, say `jumps_data`.",
                      "Identify any missing (NA) values in `jumps_data`.",
                      "Remove any rows that contain missing (NA) values in `jumps_data`. This can be done by using available pandas functions to drop missing values.",
                      "Assign the cleaned DataFrame to `clean_jumps_result`.",
                      "Return `clean_jumps_result` as the final output, ensuring it contains no missing values."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "def compute_clean_jumps() -> pd.DataFrame:",
                      "    # Obtain the raw data from the global function",
                      "    jumps_data = triple_vertical_table()",
                      "    ",
                      "    # Remove any rows with missing values",
                      "    cleaned_data = jumps_data.dropna()",
                      "    ",
                      "    return cleaned_data"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [],
            "preconditions": {
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
              "clean_jumps_result contains no missing (NA) values in any column.",
              "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
            ],
            "description": "The 'Clean Jumps' step involves processing the data obtained from `triple_vertical_table()` to ensure it is suitable for further analysis. This function removes any missing values and ensures the data integrity and completeness are maintained, resulting in a cleaned DataFrame. The cleaning process ensures that subsequent computations are working with the most relevant and accurate data possible.",
            "function_return_type": {
              "type": "pd.DataFrame['triple': float, 'vertical': float]"
            },
            "function_computed_value": "A cleaned DataFrame of jump data with no missing values, containing 'triple' and 'vertical' columns.",
            "algorithm": [
              "Obtain the raw data by calling the global function `triple_vertical_table()`, which returns a DataFrame containing columns 'triple' and 'vertical'.",
              "Assign the DataFrame obtained from `triple_vertical_table()` to a variable, say `jumps_data`.",
              "Identify any missing (NA) values in `jumps_data`.",
              "Remove any rows that contain missing (NA) values in `jumps_data`. This can be done by using available pandas functions to drop missing values.",
              "Assign the cleaned DataFrame to `clean_jumps_result`.",
              "Return `clean_jumps_result` as the final output, ensuring it contains no missing values."
            ],
            "code": [
              "import pandas as pd",
              "def compute_clean_jumps() -> pd.DataFrame:",
              "    # Obtain the raw data from the global function",
              "    jumps_data = triple_vertical_table()",
              "    ",
              "    # Remove any rows with missing values",
              "    cleaned_data = jumps_data.dropna()",
              "    ",
              "    return cleaned_data"
            ],
            "result": {
              "result": {
                "pickle": "gASVFwUAAAAAAACMEXBhbmRhcy5jb3JlLmZyYW1llIwJRGF0YUZyYW1llJOUKYGUfZQojARfbWdylIwecGFuZGFzLmNvcmUuaW50ZXJuYWxzLm1hbmFnZXJzlIwMQmxvY2tNYW5hZ2VylJOUjBZwYW5kYXMuX2xpYnMuaW50ZXJuYWxzlIwPX3VucGlja2xlX2Jsb2NrlJOUjBZudW1weS5fY29yZS5tdWx0aWFycmF5lIwMX3JlY29uc3RydWN0lJOUjAVudW1weZSMB25kYXJyYXmUk5RLAIWUQwFilIeUUpQoSwFLAksohpRoD4wFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGKJQoACAAAAAAAAAPB3QAAAAAAAaIhAKVyPwvWMgUBcj8L1KISDQKRwPQrX43tAZmZmZmYagEDsUbgehRN8QOF6FK5Hh4FAKVyPwvU4gEDXo3A9CpuCQI/C9Shcc4VAj8L1KFzNgkCkcD0K10mBQPYoXI/CiYBA4XoUrkeJgUCuR+F6FB59QM3MzMzMFH9ASOF6FK6FgkCamZmZmT+FQI/C9Shcn4BAcT0K16OWgUAUrkfhevh7QBSuR+F6XIVAzczMzMy0g0DsUbgehSWEQD0K16Nw9X1AmpmZmZlPh0ApXI/C9diEQK5H4XoUunlAhetRuB41fkCPwvUoXPWDQFK4HoXr2X1AmpmZmZk5fUApXI/C9QR5QClcj8L1VIJArkfhehQKgECPwvUoXAt9QOxRuB6FM3lArkfhehS6fUC4HoXrUcCBQAAAAAAAgEBAZmZmZmbGUUAAAAAAACBPQArXo3A9qk5AuB6F61EYREB7FK5H4XpDQLgehetR2ENA4XoUrkdBR0DXo3A9CtdCQD0K16NwvUpAZmZmZmZ2UEDNzMzMzMxMQBSuR+F61EJAmpmZmZnZREA9CtejcH1IQFK4HoXrEUFAj8L1KFwPTEAUrkfhevRKQGZmZmZm5lBAhetRuB6lSUApXI/C9ehKQGZmZmZmBkVAZmZmZmZGSEBxPQrXo7BQQHE9CtejsE1A16NwPQrXRUApXI/C9YhQQAAAAAAAwE5AMzMzMzPTQkDsUbgehctCQM3MzMzMDE5AKVyPwvVIRUBcj8L1KPxIQPYoXI/CNUhAFK5H4Xo0SkDD9ShcjyJFQOF6FK5H4UFAexSuR+F6QUDsUbgehetEQKRwPQrXw0dAlHSUYowIYnVpbHRpbnOUjAVzbGljZZSTlEsASwJLAYeUUpRLAoeUUpSFlF2UKIwYcGFuZGFzLmNvcmUuaW5kZXhlcy5iYXNllIwKX25ld19JbmRleJSTlGgpjAVJbmRleJSTlH2UKIwEZGF0YZRoDmgRSwCFlGgTh5RSlChLAUsChZRoGIwCTziUiYiHlFKUKEsDjAF8lE5OTkr/////Sv////9LP3SUYoldlCiMBnRyaXBsZZSMCHZlcnRpY2FslGV0lGKMBG5hbWWUTnWGlFKUaCuMGXBhbmRhcy5jb3JlLmluZGV4ZXMucmFuZ2WUjApSYW5nZUluZGV4lJOUfZQoaD1OjAVzdGFydJRLAIwEc3RvcJRLKIwEc3RlcJRLAXWGlFKUZYaUUpSMBF90eXCUjAlkYXRhZnJhbWWUjAlfbWV0YWRhdGGUXZSMBWF0dHJzlH2UjAZfZmxhZ3OUfZSMF2FsbG93c19kdXBsaWNhdGVfbGFiZWxzlIhzdWIu\n",
                "text": "    triple  vertical\n0   383.00     33.00\n1   781.00     71.10\n2   561.62     62.25\n3   624.52     61.33\n4   446.24     40.19\n5   515.30     38.96\n6   449.22     39.69\n7   560.91     46.51\n8   519.12     37.68\n9   595.38     53.48\n10  686.42     65.85\n11  601.67     57.60\n12  553.23     37.66\n13  529.22     41.70\n14  561.16     48.98\n15  465.88     34.14\n16  497.30     56.12\n17  592.71     53.91\n18  679.95     67.60\n19  531.92     51.29\n20  562.83     53.82\n21  447.53     42.05\n22  683.56     48.55\n23  630.60     66.76\n24  644.69     59.38\n25  479.34     43.68\n26  745.95     66.14\n27  667.12     61.50\n28  411.63     37.65\n29  483.32     37.59\n30  638.67     60.10\n31  477.62     42.57\n32  467.60     49.97\n33  400.31     48.42\n34  586.62     52.41\n35  513.26     42.27\n36  464.71     35.76\n37  403.22     34.96\n38  475.63     41.84\n39  568.04     47.53\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-2",
            "pill": "Computer-Pearson",
            "label": "Computer Pearson Correlation",
            "geometry": {
              "x": 350.0,
              "y": 70.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 540.0,
              "y": 60.0,
              "width": 140.0,
              "height": 80.0
            },
            "function_name": "compute_computer_pearson",
            "function_result_var": "computer_pearson_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "pearson_correlation is a float.",
                      "pearson_correlation represents the Pearson correlation coefficient between 'triple' and 'vertical' columns of clean_jumps_result."
                    ],
                    "algorithm": [
                      "Define a function `compute_pearson_correlation(clean_jumps_result)`.",
                      "Within the function, start by verifying that the input `clean_jumps_result` is a pandas DataFrame with the columns `triple` and `vertical`.",
                      "Ensure that there are no missing (NA) values within `clean_jumps_result`. If there are any, raise an error or warning, as the input precondition is not met.",
                      "Use the pandas DataFrame method `corr()` on `clean_jumps_result` to compute the Pearson correlation matrix.",
                      "Extract the correlation value between the `triple` and `vertical` columns from the matrix. This can often be accessed via `corr().loc['triple', 'vertical']`.",
                      "Assign this correlation value to the variable `pearson_correlation`.",
                      "Return the `pearson_correlation`."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "def compute_computer_pearson(clean_jumps_result: pd.DataFrame) -> float:",
                      "    # Verify the input is a valid DataFrame with correct columns",
                      "    if not isinstance(clean_jumps_result, pd.DataFrame) or 'triple' not in clean_jumps_result.columns or 'vertical' not in clean_jumps_result.columns:",
                      "        raise ValueError(\"Input must be a DataFrame with 'triple' and 'vertical' columns.\")",
                      "    ",
                      "    # Calculate the Pearson correlation",
                      "    correlation_matrix = clean_jumps_result.corr(method='pearson')",
                      "    pearson_correlation = correlation_matrix.loc['triple', 'vertical']",
                      "    ",
                      "    return pearson_correlation"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "pearson_correlation is a float.",
              "pearson_correlation represents the Pearson correlation coefficient between 'triple' and 'vertical' columns of clean_jumps_result."
            ],
            "description": "This computation calculates the Pearson correlation coefficient between the 'triple' and 'vertical' columns of the 'clean_jumps_result' DataFrame. Pearson correlation measures the linear correlation between two sets of data, providing a value between -1 and 1. This step helps in understanding the strength and direction of the linear relationship between the two types of jumps.",
            "function_return_type": {
              "type": "float"
            },
            "function_computed_value": "The computed value is the Pearson correlation coefficient as a float.",
            "algorithm": [
              "Define a function `compute_pearson_correlation(clean_jumps_result)`.",
              "Within the function, start by verifying that the input `clean_jumps_result` is a pandas DataFrame with the columns `triple` and `vertical`.",
              "Ensure that there are no missing (NA) values within `clean_jumps_result`. If there are any, raise an error or warning, as the input precondition is not met.",
              "Use the pandas DataFrame method `corr()` on `clean_jumps_result` to compute the Pearson correlation matrix.",
              "Extract the correlation value between the `triple` and `vertical` columns from the matrix. This can often be accessed via `corr().loc['triple', 'vertical']`.",
              "Assign this correlation value to the variable `pearson_correlation`.",
              "Return the `pearson_correlation`."
            ],
            "code": [
              "import pandas as pd",
              "def compute_computer_pearson(clean_jumps_result: pd.DataFrame) -> float:",
              "    # Verify the input is a valid DataFrame with correct columns",
              "    if not isinstance(clean_jumps_result, pd.DataFrame) or 'triple' not in clean_jumps_result.columns or 'vertical' not in clean_jumps_result.columns:",
              "        raise ValueError(\"Input must be a DataFrame with 'triple' and 'vertical' columns.\")",
              "    ",
              "    # Calculate the Pearson correlation",
              "    correlation_matrix = clean_jumps_result.corr(method='pearson')",
              "    pearson_correlation = correlation_matrix.loc['triple', 'vertical']",
              "    ",
              "    return pearson_correlation"
            ],
            "result": {
              "result": {
                "pickle": "gASVagAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCGVQVA6msuo/lIaUUpQu\n",
                "text": "0.8343076972837592\n"
              },
              "output": {
                "output_type": "text",
                "data": "0.8343076972837592\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-3",
            "pill": "Compute-Slope",
            "label": "Compute slope and intercept of regression line",
            "geometry": {
              "x": 340.0,
              "y": 200.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 600.0,
              "y": 200.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_compute_slope",
            "function_result_var": "compute_slope_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                      "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                      "The slope and intercept are both floats."
                    ],
                    "algorithm": [
                      "Initialize a function to compute the slope and intercept of a regression line using a DataFrame input, clean_jumps_result, with 'triple' as the independent variable and 'vertical' as the dependent variable.",
                      "Access the 'triple' column from clean_jumps_result and set it as the independent variable X.",
                      "Access the 'vertical' column from clean_jumps_result and set it as the dependent variable Y.",
                      "Import the LinearRegression class from the sklearn.linear_model module.",
                      "Create an instance of the LinearRegression class.",
                      "Reshape X into a 2D array compatible with sklearn's requirements.",
                      "Fit the linear regression model to the data by passing X and Y into the fit method of the LinearRegression instance.",
                      "Retrieve the coefficient property of the fitted linear regression model, which represents the slope of the regression line.",
                      "Retrieve the intercept property of the fitted linear regression model, which represents the intercept of the regression line.",
                      "Return a tuple containing the computed slope and intercept as floats."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "from typing import Tuple",
                      "import pandas as pd",
                      "from sklearn.linear_model import LinearRegression",
                      "def compute_compute_slope(clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
                      "    X = clean_jumps_result[['triple']].values  # Reshape to 2D array",
                      "    Y = clean_jumps_result['vertical'].values",
                      "    model = LinearRegression()",
                      "    model.fit(X, Y)",
                      "    slope = float(model.coef_[0])  # Get the slope (coefficient) and convert to float",
                      "    intercept = float(model.intercept_)  # Get the intercept and convert to float",
                      "    return (slope, intercept)"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
              "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
              "The slope and intercept are both floats."
            ],
            "description": "This computation step calculates the slope and intercept of a linear regression line that models the relationship between the 'triple' and 'vertical' columns in the clean_jumps_result DataFrame. It uses simple linear regression methods to determine how changes in 'triple' values predict changes in 'vertical' values. The slope represents the rate of change in 'vertical' for a unit change in 'triple', and the intercept represents the expected value of 'vertical' when 'triple' is zero.",
            "function_return_type": {
              "type": "Tuple[float, float]"
            },
            "function_computed_value": "A tuple containing the float values for the slope and intercept of the regression line.",
            "algorithm": [
              "Initialize a function to compute the slope and intercept of a regression line using a DataFrame input, clean_jumps_result, with 'triple' as the independent variable and 'vertical' as the dependent variable.",
              "Access the 'triple' column from clean_jumps_result and set it as the independent variable X.",
              "Access the 'vertical' column from clean_jumps_result and set it as the dependent variable Y.",
              "Import the LinearRegression class from the sklearn.linear_model module.",
              "Create an instance of the LinearRegression class.",
              "Reshape X into a 2D array compatible with sklearn's requirements.",
              "Fit the linear regression model to the data by passing X and Y into the fit method of the LinearRegression instance.",
              "Retrieve the coefficient property of the fitted linear regression model, which represents the slope of the regression line.",
              "Retrieve the intercept property of the fitted linear regression model, which represents the intercept of the regression line.",
              "Return a tuple containing the computed slope and intercept as floats."
            ],
            "code": [
              "from typing import Tuple",
              "import pandas as pd",
              "from sklearn.linear_model import LinearRegression",
              "def compute_compute_slope(clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
              "    X = clean_jumps_result[['triple']].values  # Reshape to 2D array",
              "    Y = clean_jumps_result['vertical'].values",
              "    model = LinearRegression()",
              "    model.fit(X, Y)",
              "    slope = float(model.coef_[0])  # Get the slope (coefficient) and convert to float",
              "    intercept = float(model.intercept_)  # Get the intercept and convert to float",
              "    return (slope, intercept)"
            ],
            "result": {
              "result": {
                "pickle": "gASVFQAAAAAAAABHP7fMDGRrR45Hv/kQeEu2BMCGlC4=\n",
                "text": "(0.09295728160512182, -1.5665209729634597)\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-4",
            "pill": "Plot-That",
            "label": "Plot that line and the data on a scatter plot",
            "geometry": {
              "x": 640.0,
              "y": 150.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 980.0,
              "y": 110.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_plot_that",
            "function_result_var": "plot_that_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "Generate a scatter plot of the 'triple' column on the x-axis and 'vertical' column on the y-axis from clean_jumps_result.",
                      "Overlay the regression line using the computed slope and intercept from compute_slope_result.",
                      "Ensure that the plot includes appropriate labels and a legend for clarity."
                    ],
                    "algorithm": [
                      "Load the 'triple' and 'vertical' columns from the 'clean_jumps_result' DataFrame for plotting.",
                      "Create a scatter plot with the 'triple' column on the x-axis and the 'vertical' column on the y-axis using matplotlib.",
                      "Retrieve the slope and intercept from the 'compute_slope_result' tuple.",
                      "Compute the y-values for the regression line using the formula: \\[ \\text{y} = (\\text{slope} \\times \\text{triple}) + \\text{intercept} \\]",
                      "Overlay the regression line on the scatter plot.",
                      "Add labels for the x-axis as 'Triple' and y-axis as 'Vertical'.",
                      "Include a title for the plot, such as 'Scatter Plot with Regression Line'.",
                      "Add a legend to distinguish between data points and the regression line.",
                      "Display the plot."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import matplotlib.pyplot as plt",
                      "import seaborn as sns",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_plot_that(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
                      "    # Extract the slope and intercept from the compute_slope_result",
                      "    slope, intercept = compute_slope_result",
                      "    # Create the scatter plot",
                      "    plt.figure(figsize=(10, 6))",
                      "    sns.scatterplot(x='triple', y='vertical', data=clean_jumps_result, label='Data Points')",
                      "    # Compute the regression line values",
                      "    x_values = clean_jumps_result['triple']",
                      "    y_values = slope * x_values + intercept",
                      "    # Plot the regression line",
                      "    plt.plot(x_values, y_values, color='red', label='Regression Line')",
                      "    # Add labels and title",
                      "    plt.xlabel('Triple')",
                      "    plt.ylabel('Vertical')",
                      "    plt.title('Scatter Plot with Regression Line')",
                      "    plt.legend()",
                      "    # Draw the plot",
                      "    plt.draw()"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "Generate a scatter plot of the 'triple' column on the x-axis and 'vertical' column on the y-axis from clean_jumps_result.",
              "Overlay the regression line using the computed slope and intercept from compute_slope_result.",
              "Ensure that the plot includes appropriate labels and a legend for clarity."
            ],
            "description": "This step generates a visual representation of the linear relationship between the 'triple' and 'vertical' columns in the clean_jumps_result dataset. A scatter plot is created to display the data points, and the computed regression line is overlaid to illustrate the fit. This plot helps to visually assess the correlation and the accuracy of the linear model.",
            "function_return_type": {
              "type": "None"
            },
            "function_computed_value": "None",
            "algorithm": [
              "Load the 'triple' and 'vertical' columns from the 'clean_jumps_result' DataFrame for plotting.",
              "Create a scatter plot with the 'triple' column on the x-axis and the 'vertical' column on the y-axis using matplotlib.",
              "Retrieve the slope and intercept from the 'compute_slope_result' tuple.",
              "Compute the y-values for the regression line using the formula: \\[ \\text{y} = (\\text{slope} \\times \\text{triple}) + \\text{intercept} \\]",
              "Overlay the regression line on the scatter plot.",
              "Add labels for the x-axis as 'Triple' and y-axis as 'Vertical'.",
              "Include a title for the plot, such as 'Scatter Plot with Regression Line'.",
              "Add a legend to distinguish between data points and the regression line.",
              "Display the plot."
            ],
            "code": [
              "import matplotlib.pyplot as plt",
              "import seaborn as sns",
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_plot_that(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
              "    # Extract the slope and intercept from the compute_slope_result",
              "    slope, intercept = compute_slope_result",
              "    # Create the scatter plot",
              "    plt.figure(figsize=(10, 6))",
              "    sns.scatterplot(x='triple', y='vertical', data=clean_jumps_result, label='Data Points')",
              "    # Compute the regression line values",
              "    x_values = clean_jumps_result['triple']",
              "    y_values = slope * x_values + intercept",
              "    # Plot the regression line",
              "    plt.plot(x_values, y_values, color='red', label='Regression Line')",
              "    # Add labels and title",
              "    plt.xlabel('Triple')",
              "    plt.ylabel('Vertical')",
              "    plt.title('Scatter Plot with Regression Line')",
              "    plt.legend()",
              "    # Draw the plot",
              "    plt.draw()"
            ],
            "result": {
              "result": {
                "pickle": "gAROLg==\n",
                "text": "None\n"
              },
              "output": {
                "output_type": "image",
                "data": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA1UAAAIjCAIAAABkkab5AABtIElEQVR4nO3de1xT9f8H8PfhMm5jAxkIKCAiijfU1LyCJl5T0yQttLybF7xrIt28VWBe019mmqmVZnlJLTPzDioqXtGvikgoJipMZTAHDOH8/jg5xzaQy86ur+ejP9hnZ9t7hzVffD6f8/kwLMsSAAAAAFgNG2MXAAAAAAAGhfwHAAAAYF2Q/wAAAACsC/IfAAAAgHVB/gMAAACwLsh/AAAAANYF+Q8AAADAuiD/AQAAAFgX5D8AAAAA64L8BwBGc/v2bYZhNm3aZPiXZhhm/vz5FR8wefJkQ5VjEo4dO8YwzLFjxwz8uvPnz2cYxsAvCmDlkP8ATNqVK1feeuutgIAAR0fHOnXq9OjRY/Xq1TV/2q1bt65cuVK9JSsra/78+ZcuXar5k6vjIgXH3t6+fv36w4cP/+eff6rxVKdOnZo/f35ubq5+K9TLM3NBlmNjY1OrVq0+ffokJSXpr0az17Vr12bNmhm7CgD4D/IfgOk6depUmzZtLl++PG7cuP/7v/8bO3asjY3NV199VfNn1pn/FixYoPf8x5k6deqPP/64bt26vn37/vLLL23bts3Kyqrqk5w6dWrBggX6yn8FBQUff/yxfp85Kirqxx9/3Lhx48SJE0+fPv3aa69duXKlpoUaUHh4eEFBQXh4uIFf9+OPPy4oKDDwiwJYOTtjFwAA5fr888/FYnFycrKbm5uqMTs723gVVeTp06cuLi467woLC3vrrbeIaNSoUQ0bNpw6dermzZtjY2MNW2AZjo6Oen/OV1555d133+V+DgsL69OnzzfffLNmzRq9v1AFp7ombGxs+DgtL2VnZ2dnh3+MAAwK/X8Apis9Pb1p06bq4Y+IvLy81G/+9NNPr776qrOzs7u7e3h4+N9//82179mzp2/fvr6+vg4ODkFBQYsWLSopKeHu6tq16759++7cucONV9arV+/YsWNt27YlolGjRnGNqjl5Z86c6d27t1gsdnZ27tKly8mTJ1UvzU3bunbt2tChQ93d3Tt37lyZN9WtWzciysjI0HnvkSNHwsLCXFxc3NzcBgwYcP36ddVrffDBB0QUGBjIVXj79m2Nx65atcrW1lbVjbds2TKGYWbOnMndLCkpcXV1jYmJ4W6q5v9V/My7d+9u1qyZg4ND06ZN//rrr8q8QU5YWBgRpaenq1pyc3OnT5/u5+fn4ODQoEGDxYsXl5aWqu599OjRe++9JxKJ3NzcRowYcfnyZfXfwsiRI4VCYXp6+uuvv+7q6jps2DAiKi0tXblyZdOmTR0dHWvXrj1+/PgnT56onvDcuXO9evWSSCROTk6BgYGjR49W3bVt27bWrVu7urqKRKLmzZurepS15/9t3769devWTk5OEonk3XffvXfvnuourqR79+4NHDhQKBR6enrOnj1b9RmrEo35f9zMywrO/L1790aPHl27dm3u3u+//74aLwpg5fAnF4DpCggISEpKunr1ankTpxYsWDB//vyOHTsuXLhQIBCcOXPmyJEjPXv2JKJNmzYJhcKZM2cKhcIjR458+umneXl5S5YsIaKPPvpIJpP9+++/K1asICKhUNi4ceOFCxd++umn77//PhdcOnbsSERHjhzp06dP69at582bZ2Njs3Hjxm7duiUmJr766quqGgYPHhwcHPzFF1+wLFuZN8VFIg8PD+27Dh061KdPn/r168+fP7+goGD16tWdOnW6cOFCvXr1Bg0adPPmzZ9//nnFihUSiYSIPD09NR4eFhZWWlp64sSJfv36EVFiYqKNjU1iYiJ378WLF+VyufbgZgXPfOLEiV27dk2aNMnV1XXVqlWRkZGZmZk6K9fGhUh3d3fupkKh6NKly71798aPH+/v73/q1KnY2Nj79+9zo/ClpaX9+/c/e/bsxIkTQ0JC9uzZM2LECI0nfPbsWa9evTp37rx06VJnZ2ciGj9+/KZNm0aNGjV16tSMjIz/+7//u3jx4smTJ+3t7bOzs3v27Onp6Tl37lw3N7fbt2/v2rWLe56DBw9GRUVFREQsXryYiK5fv37y5Mlp06ZpvwXuydu2bRsXF/fw4cOvvvrq5MmTFy9eVP1BUlJS0qtXr3bt2i1duvTQoUPLli0LCgqaOHFiZc5PxSo48w8fPmzfvj2XET09Pffv3z9mzJi8vLzp06fX/HUBrAgLAKbq77//trW1tbW17dChw5w5cw4cOKBUKlX3pqWl2djYvPnmmyUlJarG0tJS7geFQqH+VOPHj3d2di4sLORu9u3bNyAgQP2A5ORkItq4caP6UwUHB/fq1Uv9OQMDA3v06MHdnDdvHhFFRUVV8BaOHj1KRN9//31OTk5WVta+ffvq1avHMExycjLL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"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-5",
            "pill": "Compute-R2",
            "label": "Compute R^2 score",
            "geometry": {
              "x": 510.0,
              "y": 360.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 720.0,
              "y": 500.0,
              "width": 400.0,
              "height": 60.0
            },
            "function_name": "compute_compute_r2",
            "function_result_var": "compute_r2_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "r_squared is a float.",
                      "r_squared represents the coefficient of determination for the linear regression model calculated using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                      "The regression model is defined by the slope and intercept in compute_slope_result."
                    ],
                    "algorithm": [
                      "Extract the slope and intercept from compute_slope_result.",
                      "Define a function to compute the predicted vertical values given a triple value using the equation: predicted_vertical = (slope * triple) + intercept.",
                      "Apply the function across the 'triple' column of clean_jumps_result to calculate predicted values for each row, resulting in a new column called 'predicted_vertical'.",
                      "Compute the total sum of squares (SST) as the sum of squared differences between each actual 'vertical' value in clean_jumps_result and the mean of the 'vertical' column.",
                      "Compute the sum of squares of residuals (SSR) as the sum of squared differences between each predicted 'predicted_vertical' value and the actual 'vertical' values in clean_jumps_result.",
                      "Calculate the R^2 score using the formula: r_squared = 1 - (SSR/SST).",
                      "Return r_squared."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_compute_r2(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> float:",
                      "    # Extract slope and intercept",
                      "    slope, intercept = compute_slope_result",
                      "",
                      "    # Calculate predicted vertical values",
                      "    clean_jumps_result['predicted_vertical'] = clean_jumps_result['triple'].apply(lambda x: slope * x + intercept)",
                      "",
                      "    # Compute total sum of squares (SST)",
                      "    vertical_mean = clean_jumps_result['vertical'].mean()",
                      "    sst = ((clean_jumps_result['vertical'] - vertical_mean) ** 2).sum()",
                      "",
                      "    # Compute sum of squares of residuals (SSR)",
                      "    ssr = ((clean_jumps_result['vertical'] - clean_jumps_result['predicted_vertical']) ** 2).sum()",
                      "",
                      "    # Calculate R^2 score",
                      "    r_squared = 1 - (ssr / sst)",
                      "",
                      "    return r_squared"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "r_squared is a float.",
              "r_squared represents the coefficient of determination for the linear regression model calculated using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
              "The regression model is defined by the slope and intercept in compute_slope_result."
            ],
            "description": "This computation step calculates the R^2 score (coefficient of determination) for the linear regression model determined by the given slope and intercept. The score provides a measure of how well the independent variable 'triple' predicts the dependent variable 'vertical'. The R^2 score is a value between 0 and 1, where a higher value indicates a better fit of the regression model to the data.",
            "function_return_type": {
              "type": "float"
            },
            "function_computed_value": "The R^2 score of the regression model.",
            "algorithm": [
              "Extract the slope and intercept from compute_slope_result.",
              "Define a function to compute the predicted vertical values given a triple value using the equation: predicted_vertical = (slope * triple) + intercept.",
              "Apply the function across the 'triple' column of clean_jumps_result to calculate predicted values for each row, resulting in a new column called 'predicted_vertical'.",
              "Compute the total sum of squares (SST) as the sum of squared differences between each actual 'vertical' value in clean_jumps_result and the mean of the 'vertical' column.",
              "Compute the sum of squares of residuals (SSR) as the sum of squared differences between each predicted 'predicted_vertical' value and the actual 'vertical' values in clean_jumps_result.",
              "Calculate the R^2 score using the formula: r_squared = 1 - (SSR/SST).",
              "Return r_squared."
            ],
            "code": [
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_compute_r2(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> float:",
              "    # Extract slope and intercept",
              "    slope, intercept = compute_slope_result",
              "",
              "    # Calculate predicted vertical values",
              "    clean_jumps_result['predicted_vertical'] = clean_jumps_result['triple'].apply(lambda x: slope * x + intercept)",
              "",
              "    # Compute total sum of squares (SST)",
              "    vertical_mean = clean_jumps_result['vertical'].mean()",
              "    sst = ((clean_jumps_result['vertical'] - vertical_mean) ** 2).sum()",
              "",
              "    # Compute sum of squares of residuals (SSR)",
              "    ssr = ((clean_jumps_result['vertical'] - clean_jumps_result['predicted_vertical']) ** 2).sum()",
              "",
              "    # Calculate R^2 score",
              "    r_squared = 1 - (ssr / sst)",
              "",
              "    return r_squared"
            ],
            "result": {
              "result": {
                "pickle": "gASVagAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCFohBjIzRuY/lIaUUpQu\n",
                "text": "0.6960693337469295\n"
              },
              "output": {
                "output_type": "text",
                "data": "0.6960693337469295\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-6",
            "pill": "Plot-Residuals",
            "label": "Plot Residuals",
            "geometry": {
              "x": 440.0,
              "y": 500.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 550.0,
              "y": 670.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_plot_residuals",
            "function_result_var": "plot_residuals_result",
            "predecessors": [
              "Step-1",
              "Step-3"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "Residuals are computed as the difference between the actual values in the 'vertical' column and the predicted values based on the regression line from compute_slope_result.",
                      "A scatter plot of the residuals versus the 'triple' values from clean_jumps_result is generated.",
                      "The plot includes labels for the axes with 'Triple' on the x-axis and 'Residuals' on the y-axis."
                    ],
                    "algorithm": [
                      "Extract the slope and intercept from compute_slope_result.",
                      "Compute predicted vertical values using the formula: predicted_vertical = slope * triple + intercept for each row in clean_jumps_result.",
                      "Compute residuals as the difference between actual vertical values and predicted vertical values for each row.",
                      "Initialize a scatter plot.",
                      "Plot triple values on the x-axis and calculated residuals on the y-axis.",
                      "Label the x-axis as 'Triple' and the y-axis as 'Residuals'.",
                      "Display the plot."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import matplotlib.pyplot as plt",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "def compute_plot_residuals(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
                      "    slope, intercept = compute_slope_result",
                      "    # Calculate predicted vertical values",
                      "    predicted_vertical = slope * clean_jumps_result['triple'] + intercept",
                      "    # Calculate residuals",
                      "    residuals = clean_jumps_result['vertical'] - predicted_vertical",
                      "    # Create the scatter plot",
                      "    plt.figure()",
                      "    plt.scatter(clean_jumps_result['triple'], residuals)",
                      "    plt.xlabel('Triple')",
                      "    plt.ylabel('Residuals')",
                      "    plt.draw()",
                      "    return None"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              },
              {
                "name": "compute_slope_result",
                "type": {
                  "type": "Tuple[float, float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "compute_slope_result": [
                "compute_slope_result is a tuple containing the slope and intercept of the regression line.",
                "The slope and intercept are computed using the 'triple' column as the independent variable and 'vertical' column as the dependent variable from clean_jumps_result.",
                "The slope and intercept are both floats."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "Residuals are computed as the difference between the actual values in the 'vertical' column and the predicted values based on the regression line from compute_slope_result.",
              "A scatter plot of the residuals versus the 'triple' values from clean_jumps_result is generated.",
              "The plot includes labels for the axes with 'Triple' on the x-axis and 'Residuals' on the y-axis."
            ],
            "description": "This step involves calculating the residuals based on the linear regression model obtained from the previous computation. The residuals are the differences between the actual 'vertical' values and the predicted values obtained using the slope and intercept from compute_slope_result. These residuals are then plotted in a scatter plot with 'triple' values on the x-axis, helping visualize any patterns or randomness in the residuals.",
            "function_return_type": {
              "type": "None"
            },
            "function_computed_value": "None",
            "algorithm": [
              "Extract the slope and intercept from compute_slope_result.",
              "Compute predicted vertical values using the formula: predicted_vertical = slope * triple + intercept for each row in clean_jumps_result.",
              "Compute residuals as the difference between actual vertical values and predicted vertical values for each row.",
              "Initialize a scatter plot.",
              "Plot triple values on the x-axis and calculated residuals on the y-axis.",
              "Label the x-axis as 'Triple' and the y-axis as 'Residuals'.",
              "Display the plot."
            ],
            "code": [
              "import matplotlib.pyplot as plt",
              "import pandas as pd",
              "from typing import Tuple",
              "def compute_plot_residuals(clean_jumps_result: pd.DataFrame, compute_slope_result: Tuple[float, float]) -> None:",
              "    slope, intercept = compute_slope_result",
              "    # Calculate predicted vertical values",
              "    predicted_vertical = slope * clean_jumps_result['triple'] + intercept",
              "    # Calculate residuals",
              "    residuals = clean_jumps_result['vertical'] - predicted_vertical",
              "    # Create the scatter plot",
              "    plt.figure()",
              "    plt.scatter(clean_jumps_result['triple'], residuals)",
              "    plt.xlabel('Triple')",
              "    plt.ylabel('Residuals')",
              "    plt.draw()",
              "    return None"
            ],
            "result": {
              "result": {
                "pickle": "gAROLg==\n",
                "text": "None\n"
              },
              "output": {
                "output_type": "image",
                "data": "data:image/png;base64,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"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-7",
            "pill": "Bootstrap-Regression",
            "label": "Bootstrap regression line for resamples of data",
            "geometry": {
              "x": 90.0,
              "y": 290.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 350.0,
              "y": 290.0,
              "width": 400.0,
              "height": 300.0
            },
            "function_name": "compute_bootstrap_regression",
            "function_result_var": "bootstrap_regression_result",
            "predecessors": [
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
                      "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
                      "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
                      "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
                    ],
                    "algorithm": [
                      "Define a function `bootstrap_regression` that takes `clean_jumps_result` as input.",
                      "Initialize an empty list `bootstrap_results` to store slope and intercept of each bootstrap sample.",
                      "Set the number of bootstrap samples, `n_bootstrap_samples`, to at least 1000 to ensure reliable estimates.",
                      "For each in the range from 0 to `n_bootstrap_samples`:",
                      ".1. Create a bootstrap sample by drawing with replacement from `clean_jumps_result`. This creates two arrays—`x_sample` from 'triple' and `y_sample` from 'vertical'.",
                      ".2. Perform linear regression on the bootstrap sample `x_sample`, `y_sample`. Use a suitable linear regression method (e.g., using numpy's `polyfit`) to compute the slope and intercept of the regression.",
                      ".3. Store the computed slope and intercept as a tuple in the `bootstrap_results` list.",
                      "After completing all bootstrap samples, convert the `bootstrap_results` list into a pandas DataFrame with column names 'slope' and 'intercept'.",
                      "Return the DataFrame containing the slopes and intercepts for all bootstrap samples."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import numpy as np",
                      "import pandas as pd",
                      "",
                      "def compute_bootstrap_regression(clean_jumps_result: pd.DataFrame) -> pd.DataFrame:",
                      "    bootstrap_results = []",
                      "    n_bootstrap_samples = 1000 # Number of resamples for bootstrap analysis",
                      "    ",
                      "    for _ in range(n_bootstrap_samples):",
                      "        # Create a bootstrap sample by sampling with replacement",
                      "        bootstrap_sample = clean_jumps_result.sample(n=len(clean_jumps_result), replace=True)",
                      "        x_sample = bootstrap_sample['triple']",
                      "        y_sample = bootstrap_sample['vertical']",
                      "        ",
                      "        # Calculate the slope and intercept using numpy polyfit for linear regression",
                      "        slope, intercept = np.polyfit(x_sample, y_sample, 1)",
                      "        ",
                      "        # Store results",
                      "        bootstrap_results.append((slope, intercept))",
                      "    ",
                      "    # Convert the bootstrap results to a DataFrame",
                      "    bootstrap_regression_result = pd.DataFrame(bootstrap_results, columns=['slope', 'intercept'])",
                      "    ",
                      "    return bootstrap_regression_result"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
              "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
              "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
              "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
            ],
            "description": "This computation step performs a bootstrap analysis of the regression line based on the 'clean_jumps_result' DataFrame. By taking many resamples (with replacement), the slope and intercept of a linear regression are calculated for each resample. This approach allows for estimation of the variability in the regression line's parameters.",
            "function_return_type": {
              "type": "pd.DataFrame['slope': float, 'intercept': float]"
            },
            "function_computed_value": "A DataFrame containing calculated slope and intercept values for each bootstrap resample of the data.",
            "algorithm": [
              "Define a function `bootstrap_regression` that takes `clean_jumps_result` as input.",
              "Initialize an empty list `bootstrap_results` to store slope and intercept of each bootstrap sample.",
              "Set the number of bootstrap samples, `n_bootstrap_samples`, to at least 1000 to ensure reliable estimates.",
              "For each in the range from 0 to `n_bootstrap_samples`:",
              ".1. Create a bootstrap sample by drawing with replacement from `clean_jumps_result`. This creates two arrays—`x_sample` from 'triple' and `y_sample` from 'vertical'.",
              ".2. Perform linear regression on the bootstrap sample `x_sample`, `y_sample`. Use a suitable linear regression method (e.g., using numpy's `polyfit`) to compute the slope and intercept of the regression.",
              ".3. Store the computed slope and intercept as a tuple in the `bootstrap_results` list.",
              "After completing all bootstrap samples, convert the `bootstrap_results` list into a pandas DataFrame with column names 'slope' and 'intercept'.",
              "Return the DataFrame containing the slopes and intercepts for all bootstrap samples."
            ],
            "code": [
              "import numpy as np",
              "import pandas as pd",
              "",
              "def compute_bootstrap_regression(clean_jumps_result: pd.DataFrame) -> pd.DataFrame:",
              "    bootstrap_results = []",
              "    n_bootstrap_samples = 1000 # Number of resamples for bootstrap analysis",
              "    ",
              "    for _ in range(n_bootstrap_samples):",
              "        # Create a bootstrap sample by sampling with replacement",
              "        bootstrap_sample = clean_jumps_result.sample(n=len(clean_jumps_result), replace=True)",
              "        x_sample = bootstrap_sample['triple']",
              "        y_sample = bootstrap_sample['vertical']",
              "        ",
              "        # Calculate the slope and intercept using numpy polyfit for linear regression",
              "        slope, intercept = np.polyfit(x_sample, y_sample, 1)",
              "        ",
              "        # Store results",
              "        bootstrap_results.append((slope, intercept))",
              "    ",
              "    # Convert the bootstrap results to a DataFrame",
              "    bootstrap_regression_result = pd.DataFrame(bootstrap_results, columns=['slope', 'intercept'])",
              "    ",
              "    return bootstrap_regression_result"
            ],
            "result": {
              "result": {
                "pickle": "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\n",
                "text": "        slope  intercept\n0    0.079948   4.990699\n1    0.089357   0.376534\n2    0.099633  -3.897056\n3    0.095368  -1.784043\n4    0.101629  -6.612154\n..        ...        ...\n995  0.096266  -3.894805\n996  0.101951  -7.306179\n997  0.086624   2.236808\n998  0.106705  -8.635379\n999  0.090075  -0.627934\n\n[1000 rows x 2 columns]\n"
              },
              "output": null
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          },
          {
            "id": "Step-8",
            "pill": "Show-Confidence",
            "label": "Show confidence interval for prediction based on the mean jump in the data set",
            "geometry": {
              "x": 90.0,
              "y": 480.0,
              "width": 160.0,
              "height": 80.0
            },
            "output_geometry": {
              "x": 90.0,
              "y": 630.0,
              "width": 400.0,
              "height": 50.0
            },
            "function_name": "compute_show_confidence",
            "function_result_var": "show_confidence_result",
            "predecessors": [
              "Step-7",
              "Step-1"
            ],
            "phase": 5,
            "cache": {
              "caches": {
                "3": {
                  "in_values": {
                    "requirements": [
                      "confidence_interval is a Tuple[float, float].",
                      "confidence_interval represents the 95% confidence interval for the predicted 'vertical' value of the mean 'triple' jump in the clean_jumps_result dataset."
                    ],
                    "algorithm": [
                      "Calculate the mean value of 'triple' from the clean_jumps_result dataset. This will be the mean_triple.",
                      "Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
                      "Iterate over each row in the bootstrap_regression_result DataFrame:",
                      "  a) For each row, extract the 'slope' and 'intercept' values.",
                      "  b) Use these to calculate the predicted 'vertical' value using the formula:\n     predicted_vertical = (slope * mean_triple) + intercept.",
                      "  c) Append this predicted_vertical to the list of predicted verticals.",
                      "After completing the loop, convert the list of predicted verticals to a NumPy array for easier manipulation.",
                      "Calculate the 95% confidence interval from these predicted verticals using NumPy:\n  a) Use numpy.percentile() to find the 2.5th percentile and 97.5th percentile.\n  b) The result is the lower and upper bounds of the 95% confidence interval.",
                      "Create a tuple called confidence_interval containing the lower and upper bounds.",
                      "Return confidence_interval."
                    ]
                  },
                  "out_values": {
                    "code": [
                      "import numpy as np",
                      "import pandas as pd",
                      "from typing import Tuple",
                      "",
                      "def compute_show_confidence(bootstrap_regression_result: pd.DataFrame, clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
                      "    # Step 1: Calculate the mean value of 'triple' from the clean_jumps_result dataset.",
                      "    mean_triple = clean_jumps_result['triple'].mean()",
                      "",
                      "    # Step 2: Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
                      "    predicted_verticals = []",
                      "",
                      "    # Step 3: Iterate over each row in the bootstrap_regression_result DataFrame.",
                      "    for _, row in bootstrap_regression_result.iterrows():",
                      "        slope, intercept = row['slope'], row['intercept']",
                      "        # Step 3b: Calculate the predicted 'vertical' using the formula.",
                      "        predicted_vertical = (slope * mean_triple) + intercept",
                      "        # Step 3c: Append this to the list.",
                      "        predicted_verticals.append(predicted_vertical)",
                      "",
                      "    # Step 4: Convert the list to a NumPy array for further manipulation.",
                      "    predicted_verticals = np.array(predicted_verticals)",
                      "",
                      "    # Step 5: Calculate the 95% confidence interval from the predicted verticals.",
                      "    lower_bound = np.percentile(predicted_verticals, 2.5)",
                      "    upper_bound = np.percentile(predicted_verticals, 97.5)",
                      "    # Step 6: Create a tuple of the confidence interval.",
                      "    confidence_interval = (lower_bound, upper_bound)",
                      "",
                      "    # Step 7: Return confidence_interval.",
                      "    return confidence_interval"
                    ]
                  },
                  "valid": true
                }
              }
            },
            "function_parameters": [
              {
                "name": "bootstrap_regression_result",
                "type": {
                  "type": "pd.DataFrame['slope': float, 'intercept': float]"
                }
              },
              {
                "name": "clean_jumps_result",
                "type": {
                  "type": "pd.DataFrame['triple': float, 'vertical': float]"
                }
              }
            ],
            "preconditions": {
              "bootstrap_regression_result": [
                "bootstrap_regression_result is a pd.DataFrame with two columns: 'slope' and 'intercept'.",
                "Each row in bootstrap_regression_result corresponds to a bootstrap resample.",
                "The 'slope' and 'intercept' columns contain the slope and intercept values calculated from a linear regression performed on each bootstrap sample.",
                "The number of bootstrap samples is sufficient to ensure a reliable estimate, typically at least 1000 samples."
              ],
              "clean_jumps_result": [
                "clean_jumps_result is a pd.DataFrame with columns 'triple' and 'vertical'.",
                "clean_jumps_result contains no missing (NA) values in any column.",
                "All values in 'triple' and 'vertical' columns of clean_jumps_result are retained from the `triple_vertical_table` output."
              ],
              "triple_vertical": [
                "The global function `triple_vertical_table()` is available and returns a dataframe with the type\n```\ntype=\"pd.DataFrame['triple': float, 'vertical': float]\"\n```\nHere are the first few rows:\n```\n   triple  vertical\n0  383.00     33.00\n1  781.00     71.10\n2  561.62     62.25\n3  624.52     61.33\n4  446.24     40.19\n```\n"
              ]
            },
            "requirements": [
              "confidence_interval is a Tuple[float, float].",
              "confidence_interval represents the 95% confidence interval for the predicted 'vertical' value of the mean 'triple' jump in the clean_jumps_result dataset."
            ],
            "description": "This computation calculates the 95% confidence interval for the predicted 'vertical' value based on the mean of the 'triple' jumps in the clean_jumps_result data. It uses the bootstrap regression results to estimate variability in slope and intercept values. The mean 'triple' value is used to predict 'vertical', and the confidence interval reflects the uncertainty in this prediction.",
            "function_return_type": {
              "type": "Tuple[float, float]"
            },
            "function_computed_value": "The confidence interval for the predicted 'vertical' at the mean 'triple' value.",
            "algorithm": [
              "Calculate the mean value of 'triple' from the clean_jumps_result dataset. This will be the mean_triple.",
              "Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
              "Iterate over each row in the bootstrap_regression_result DataFrame:",
              "  a) For each row, extract the 'slope' and 'intercept' values.",
              "  b) Use these to calculate the predicted 'vertical' value using the formula:\n     predicted_vertical = (slope * mean_triple) + intercept.",
              "  c) Append this predicted_vertical to the list of predicted verticals.",
              "After completing the loop, convert the list of predicted verticals to a NumPy array for easier manipulation.",
              "Calculate the 95% confidence interval from these predicted verticals using NumPy:\n  a) Use numpy.percentile() to find the 2.5th percentile and 97.5th percentile.\n  b) The result is the lower and upper bounds of the 95% confidence interval.",
              "Create a tuple called confidence_interval containing the lower and upper bounds.",
              "Return confidence_interval."
            ],
            "code": [
              "import numpy as np",
              "import pandas as pd",
              "from typing import Tuple",
              "",
              "def compute_show_confidence(bootstrap_regression_result: pd.DataFrame, clean_jumps_result: pd.DataFrame) -> Tuple[float, float]:",
              "    # Step 1: Calculate the mean value of 'triple' from the clean_jumps_result dataset.",
              "    mean_triple = clean_jumps_result['triple'].mean()",
              "",
              "    # Step 2: Define an empty list to store each predicted 'vertical' value based on bootstrap samples.",
              "    predicted_verticals = []",
              "",
              "    # Step 3: Iterate over each row in the bootstrap_regression_result DataFrame.",
              "    for _, row in bootstrap_regression_result.iterrows():",
              "        slope, intercept = row['slope'], row['intercept']",
              "        # Step 3b: Calculate the predicted 'vertical' using the formula.",
              "        predicted_vertical = (slope * mean_triple) + intercept",
              "        # Step 3c: Append this to the list.",
              "        predicted_verticals.append(predicted_vertical)",
              "",
              "    # Step 4: Convert the list to a NumPy array for further manipulation.",
              "    predicted_verticals = np.array(predicted_verticals)",
              "",
              "    # Step 5: Calculate the 95% confidence interval from the predicted verticals.",
              "    lower_bound = np.percentile(predicted_verticals, 2.5)",
              "    upper_bound = np.percentile(predicted_verticals, 97.5)",
              "    # Step 6: Create a tuple of the confidence interval.",
              "    confidence_interval = (lower_bound, upper_bound)",
              "",
              "    # Step 7: Return confidence_interval.",
              "    return confidence_interval"
            ],
            "result": {
              "result": {
                "pickle": "gASVfwAAAAAAAACMFm51bXB5Ll9jb3JlLm11bHRpYXJyYXmUjAZzY2FsYXKUk5SMBW51bXB5lIwFZHR5cGWUk5SMAmY4lImIh5RSlChLA4wBPJROTk5K/////0r/////SwB0lGJDCGva6QI6uEdAlIaUUpRoAmgIQwi83o9oOZtJQJSGlFKUhpQu\n",
                "text": "(np.float64(47.43927036684621), np.float64(51.212689466713954))\n"
              },
              "output": {
                "output_type": "text",
                "data": "(np.float64(47.43927036684621), np.float64(51.212689466713954))\n"
              }
            },
            "sanity_checks": null,
            "unit_tests": null,
            "sanity_check_results": {},
            "unit_test_results": {},
            "messages": [],
            "questions": null,
            "build_status": null
          }
        ],
        "edges": [
          {
            "id": "2",
            "src": "Step-1",
            "dst": "Step-2"
          },
          {
            "id": "3",
            "src": "Step-1",
            "dst": "Step-3"
          },
          {
            "id": "4",
            "src": "Step-3",
            "dst": "Step-4"
          },
          {
            "id": "5",
            "src": "Step-3",
            "dst": "Step-5"
          },
          {
            "id": "6",
            "src": "Step-3",
            "dst": "Step-6"
          },
          {
            "id": "7",
            "src": "Step-1",
            "dst": "Step-7"
          },
          {
            "id": "8",
            "src": "Step-7",
            "dst": "Step-8"
          }
        ],
        "image": null
      },
      "tables": {
        "tables": {
          "triple_vertical": {
            "table_name": "triple_vertical",
            "contents": "triple,vertical\n383.00,33.00\n781.00,71.10\n561.62,62.25\n624.52,61.33\n446.24,40.19\n515.30,38.96\n449.22,39.69\n560.91,46.51\n519.12,37.68\n595.38,53.48\n686.42,65.85\n601.67,57.60\n553.23,37.66\n529.22,41.70\n561.16,48.98\n465.88,34.14\n497.30,56.12\n592.71,53.91\n679.95,67.60\n531.92,51.29\n562.83,53.82\n447.53,42.05\n683.56,48.55\n630.60,66.76\n644.69,59.38\n479.34,43.68\n745.95,66.14\n667.12,61.50\n411.63,37.65\n483.32,37.59\n638.67,60.10\n477.62,42.57\n467.60,49.97\n400.31,48.42\n586.62,52.41\n513.26,42.27\n464.71,35.76\n403.22,34.96\n475.63,41.84\n568.04,47.53\n",
            "md5": "c7cc20224b239b2bb69a9501f2c31440"
          }
        }
      },
      "versions": []
    }
  ]
}