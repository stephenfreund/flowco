{
  "file_name": "bootstrap.json",
  "api": {
    "imported_pages": [],
    "inputs": [
      {
        "description": "An array of numbers representing the sample we will bootstrap. The default is 50 numbers from a normal distribution centered at 10.",
        "name": "bootstrap_sample",
        "extended_type": {
          "type": "np.ndarray"
        },
        "default_value_expression": "np.random.normal(loc=10, scale=1, size=50)",
        "default_value": "np.array([9.405775146816097, 10.100000244311717, 9.425321755831268, 10.509719125868122, 9.208782851836608, 9.134608793058407, 10.026996329362206, 9.779983955565363, 11.642953760793686, 9.401366498277033, 9.345883889188533, 9.181864221852097, 10.131737592233183, 9.505344073481583, 10.019126111460407, 9.983997007848682, 9.68936209579594, 10.167080087415554, 9.884464687369373, 10.163234032235907, 11.217550943493954, 9.885259381240465, 9.939882332022295, 10.219666984292173, 9.345619288779407, 9.10714003606775, 9.58378358864659, 10.614690957732865, 10.137704463662702, 10.562629642211139, 8.518069286745561, 8.66601762979114, 9.726727100691036, 8.626411842864549, 11.143258133226652, 10.149952627640896, 9.895016326762988, 8.730336916347015, 9.133335095582494, 8.481392237538554, 11.66274861049311, 10.827779612110602, 9.65393009996578, 7.333010713207935, 9.556106578437117, 10.775199039324708, 9.52048549377468, 13.21357135309248, 8.610274949242443, 10.666954641163281], dtype='float64')"
      },
      {
        "description": "The confidence interval size is a percent between 0 and 100 for the width of the confidence interval. Default is 95%",
        "name": "confidence_interval_size",
        "extended_type": {
          "type": "float"
        },
        "default_value_expression": "95.0",
        "default_value": "95.0"
      },
      {
        "description": "The statistic function is what we apply to the resamples. The default is a function to compute the mean of a resample.",
        "name": "statistic_function",
        "extended_type": {
          "type": "Callable"
        },
        "default_value_expression": "lambda x: np.mean(x)",
        "default_value": "lambda x: np.mean(x)"
      }
    ],
    "output_node_id": "Step-1"
  },
  "dfg": {
    "description": "",
    "nodes": [
      {
        "id": "55882fa6-5628-4735-ab25-ff949f37e177",
        "pill": "Bootstrap-Resample",
        "label": "Create bootstrap resamples from sample",
        "function_name": "compute_bootstrap_resample",
        "function_result_var": "bootstrap_resample_result",
        "predecessors": [],
        "phase": 0,
        "build_cache": {
          "requirements": null,
          "algorithm": null,
          "compile": null,
          "sanity_checks": null,
          "unit_tests": null
        },
        "description": "This stage creates multiple bootstrap resamples from the original sample. Each resample is generated by sampling with replacement from the original bootstrap_sample. The number of resamples and the size of each resample are the same as the size of the original bootstrap_sample.",
        "requirements": [
          "bootstrap_resample_result must be a 2D numpy array where each row represents a resample.",
          "Each resample must be created by sampling with replacement from the original bootstrap_sample.",
          "The number of resamples and the size of each resample must match the size of the original bootstrap_sample."
        ],
        "algorithm": "1. Initialize an empty list to store the resamples.\n2. Determine the number of resamples to create. This can be set to a default value or passed as a parameter.\n3. For each resample:\n    a. Sample with replacement from the original bootstrap_sample to create a new resample of the same size as the original sample.\n    b. Append the new resample to the list of resamples.\n4. Convert the list of resamples to a 2D numpy array where each row represents a resample.\n5. Return the 2D numpy array as the result.",
        "function_parameters": [],
        "function_return_type": {
          "type": "np.ndarray[np.ndarray[float]]"
        },
        "function_computed_value": "The function returns a 2D numpy array where each row is a resample of the original bootstrap_sample, created by sampling with replacement, with the number of resamples equal to the size of the original bootstrap_sample.",
        "code": [
          "import numpy as np",
          "from typing import Callable",
          "def compute_bootstrap_resample() -> np.ndarray:",
          "    # Number of resamples to create",
          "    num_resamples = 1000",
          "    # Size of each resample",
          "    sample_size = len(bootstrap_sample)",
          "    # Initialize an empty list to store the resamples",
          "    resamples = []",
          "    # Create resamples",
          "    for _ in range(num_resamples):",
          "        resample = np.random.choice(bootstrap_sample, size=sample_size, replace=True)",
          "        resamples.append(resample)",
          "    # Convert the list of resamples to a 2D numpy array",
          "    bootstrap_resample_result = np.array(resamples)",
          "    return bootstrap_resample_result"
        ],
        "sanity_checks": null,
        "unit_tests": null,
        "sanity_check_results": {},
        "unit_test_results": {},
        "warnings": null
      },
      {
        "id": "Step-1",
        "pill": "Compute-CI",
        "label": "Compute CI",
        "function_name": "compute_compute_ci",
        "function_result_var": "compute_ci_result",
        "predecessors": [
          "55882fa6-5628-4735-ab25-ff949f37e177",
          "edf75238-0b7c-4624-899b-83c73407d663"
        ],
        "phase": 0,
        "build_cache": {
          "requirements": null,
          "algorithm": null,
          "compile": null,
          "sanity_checks": null,
          "unit_tests": null
        },
        "description": "This stage computes the confidence interval (CI) for the given statistic resample results. It takes the results of the bootstrap resampling and the computed statistics for each resample, and calculates the lower and upper bounds of the confidence interval based on the specified confidence interval size.",
        "requirements": [
          "The output must be a tuple (ci_lower, ci_upper) where both ci_lower and ci_upper are floats.",
          "ci_lower and ci_upper must represent the lower and upper bounds of the confidence interval, respectively.",
          "The confidence interval must be computed using the values in statistic_resample_result and the specified confidence_interval_size."
        ],
        "algorithm": "1. Sort the array `statistic_resample_result` in ascending order.\n2. Calculate the lower percentile index using the formula: `lower_index = (100 - confidence_interval_size) / 2 * len(statistic_resample_result) / 100`.\n3. Calculate the upper percentile index using the formula: `upper_index = (100 + confidence_interval_size) / 2 * len(statistic_resample_result) / 100`.\n4. Find the values at the lower and upper percentile indices in the sorted `statistic_resample_result` array. These values are `ci_lower` and `ci_upper`, respectively.\n5. Return the tuple `(ci_lower, ci_upper)`.",
        "function_parameters": [
          {
            "name": "bootstrap_resample_result",
            "type": {
              "type": "np.ndarray[np.ndarray[float]]"
            }
          },
          {
            "name": "statistic_resample_result",
            "type": {
              "type": "np.ndarray[float]"
            }
          }
        ],
        "function_return_type": {
          "type": "Tuple[float, float]"
        },
        "function_computed_value": "The function returns a tuple containing the lower and upper bounds of the confidence interval for the specified statistic, computed from the resampled data.",
        "code": [
          "# put all imports here",
          "from typing import Tuple",
          "import numpy as np",
          "",
          "def compute_compute_ci(bootstrap_resample_result: np.ndarray, statistic_resample_result: np.ndarray) -> Tuple[float, float]:",
          "    # Sort the array `statistic_resample_result` in ascending order",
          "    sorted_statistics = np.sort(statistic_resample_result)",
          "",
          "    # Calculate the lower and upper percentile indices",
          "    lower_index = int((100 - confidence_interval_size) / 2 * len(sorted_statistics) / 100)",
          "    upper_index = int((100 + confidence_interval_size) / 2 * len(sorted_statistics) / 100)",
          "",
          "    # Find the values at the lower and upper percentile indices",
          "    ci_lower = sorted_statistics[lower_index]",
          "    ci_upper = sorted_statistics[upper_index]",
          "",
          "    # Return the tuple (ci_lower, ci_upper)",
          "    return ci_lower, ci_upper"
        ],
        "sanity_checks": null,
        "unit_tests": null,
        "sanity_check_results": {},
        "unit_test_results": {},
        "warnings": null
      },
      {
        "id": "edf75238-0b7c-4624-899b-83c73407d663",
        "pill": "Statistic-Resample",
        "label": "Compute statistic for each resample",
        "function_name": "compute_statistic_resample",
        "function_result_var": "statistic_resample_result",
        "predecessors": [
          "55882fa6-5628-4735-ab25-ff949f37e177"
        ],
        "phase": 0,
        "build_cache": {
          "requirements": null,
          "algorithm": null,
          "compile": null,
          "sanity_checks": null,
          "unit_tests": null
        },
        "description": "This stage computes a statistic for each resample in the bootstrap resample result. It applies the provided statistic_function to each row of the bootstrap_resample_result, resulting in a 1D numpy array where each element is the computed statistic for the corresponding resample.",
        "requirements": [
          "statistic_resample_result must be a 1D numpy array.",
          "The length of statistic_resample_result must be equal to the number of rows in bootstrap_resample_result.",
          "Each element in statistic_resample_result must be the result of applying statistic_function to the corresponding row in bootstrap_resample_result."
        ],
        "algorithm": "1. Initialize an empty list to store the computed statistics, named `statistic_resample_result`.\n2. Iterate over each row in `bootstrap_resample_result`.\n   a. For each row, apply `statistic_function` to compute the statistic.\n   b. Append the computed statistic to `statistic_resample_result`.\n3. Convert `statistic_resample_result` to a 1D numpy array.\n4. Return `statistic_resample_result`.",
        "function_parameters": [
          {
            "name": "bootstrap_resample_result",
            "type": {
              "type": "np.ndarray[np.ndarray[float]]"
            }
          }
        ],
        "function_return_type": {
          "type": "np.ndarray[float]"
        },
        "function_computed_value": "The function returns a 1D numpy array where each element is the result of applying the specified statistic_function to each resampled dataset (row) in the bootstrap_resample_result.",
        "code": [
          "import numpy as np",
          "from typing import Callable",
          "def compute_statistic_resample(bootstrap_resample_result: np.ndarray) -> np.ndarray:",
          "    # Initialize an empty list to store the computed statistics",
          "    statistic_resample_result = []",
          "    # Iterate over each row in bootstrap_resample_result",
          "    for resample in bootstrap_resample_result:",
          "        # Apply statistic_function to compute the statistic",
          "        statistic = statistic_function(resample)",
          "        # Append the computed statistic to statistic_resample_result",
          "        statistic_resample_result.append(statistic)",
          "    # Convert statistic_resample_result to a 1D numpy array",
          "    statistic_resample_result = np.array(statistic_resample_result)",
          "    return statistic_resample_result"
        ],
        "sanity_checks": null,
        "unit_tests": null,
        "sanity_check_results": {},
        "unit_test_results": {},
        "warnings": null
      }
    ],
    "edges": [
      {
        "id": "2",
        "src": "55882fa6-5628-4735-ab25-ff949f37e177",
        "dst": "edf75238-0b7c-4624-899b-83c73407d663"
      },
      {
        "id": "3",
        "src": "edf75238-0b7c-4624-899b-83c73407d663",
        "dst": "Step-1"
      }
    ]
  },
  "outputs": {
    "outputs": {}
  },
  "spec": {},
  "diagram": {
    "nodes": {
      "55882fa6-5628-4735-ab25-ff949f37e177": {
        "id": "55882fa6-5628-4735-ab25-ff949f37e177",
        "pill": "Bootstrap-Resample",
        "label": "Create bootstrap resamples from sample",
        "geometry": {
          "x": 240.0,
          "y": 190.0,
          "width": 160.0,
          "height": 80.0
        },
        "output_geometry": null
      },
      "Step-1": {
        "id": "Step-1",
        "pill": "Compute-CI",
        "label": "Compute CI",
        "geometry": {
          "x": 290.0,
          "y": 570.0,
          "width": 160.0,
          "height": 80.0
        },
        "output_geometry": null
      },
      "edf75238-0b7c-4624-899b-83c73407d663": {
        "id": "edf75238-0b7c-4624-899b-83c73407d663",
        "pill": "Statistic-Resample",
        "label": "Compute statistic for each resample",
        "geometry": {
          "x": 280.0,
          "y": 380.0,
          "width": 160.0,
          "height": 80.0
        },
        "output_geometry": null
      }
    },
    "edges": {
      "2": {
        "pill": "bootstrap_resample_result",
        "id": "2",
        "src": "55882fa6-5628-4735-ab25-ff949f37e177",
        "dst": "edf75238-0b7c-4624-899b-83c73407d663"
      },
      "3": {
        "pill": "statistic_resample_result",
        "id": "3",
        "src": "edf75238-0b7c-4624-899b-83c73407d663",
        "dst": "Step-1"
      }
    },
    "image": null
  },
  "diagram_file": null,
  "versions": []
}