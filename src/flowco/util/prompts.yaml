system-prompt: |
    You are an assistant to take a data science computation dataflow diagram 
    and generate code. 

    These imports will already be available in any code you write:
    ```
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    import seaborn as sns
    import statsmodels
    import statsmodels.api as sm
    import scipy.stats as stats
    import sklearn
    ``` 


semantic-diff: |
    Here are the old and new values for parts of a computation step:
    
    The old components:
    ```
    {old}
    ```
    
    The new components:
    ```
    {new}
    ```

    Describe any semantic changes between the old and new values.  Each element
    in the response lists should describe on difference between the old and new.  Be as concise and 
    specific as possible.

semantic-diff-string: |
    Here are the old and new values for the {key} for a computation step:
    
    The old:
    ```
    {old}
    ```
    
    The new:
    ```
    {new}
    ```

    Describe any semantic changes between the old and new.  Each element
    in the response lists should describe on difference between the old and new.  Be as concise and 
    specific as possible.


change_command: |
    Here is the current label, requirements, algorithm, and code for a computation step:
    ```
    {current}
    ```
    You will modify it to do the following:
    ```
    {command}
    ```
      
    Proceed as follows. Ask questions to clarify any ambiguities or inconsistencies.

    1. Describe the differences in the label, requirements, algorithm, and code between the current
       and the changed node.
    2. Take the current label and make any necessary changes to the label to reflect the changes from step 1.
    3. Take the current requirements and function_return_type 
       and make any necessary changes to those fields to reflect the changes from step 1.
    4. Take the current algorithm and make any necessary changes to the algorithm to reflect the changes from step 1.
    5. Take the current code and make any necessary changes to the code to reflect the changes from step 1.

lift_up_changes_from_code: |
    You will be given the old and new descriptions of a computation step.  

    Proceed as follows. Ask questions to clarify any ambiguities or inconsistencies.

    1. Describe any semantic changes between the old and new code, or say "no changes".
        Here are the old:
        ```
        {old_code}
        ```
        Here are the new:
        ```
        {new_code}
        ```
    2. Take the new algorithm:
       ```
       {new_algorithm}
       ```
       and make any necessary changes to reflect the changes from step 1.
    3. Describe any semantic changes between the old algorithm and that from step 2, or say "no changes".
        Here are is old algorithm:
        ```
        {old_algorithm}
        ```
    4. Take the new requirements:
       ```
       {new_requirements}
       ```
       and make any necessary changes to reflect the changes from step 3.
    5. Describe any semantic changes between the old requirements and those from step 4, or say "no changes".
        Here are the old:
        ```
        {old_requirements}
        ```
    6. Take the new label:
       ```
       {new_label}
       ```
       and make any necessary changes to reflect the changes from step 3.


lift_up_changes_from_editing: |
    You will be given the old and new descriptions of a computation step.  

    Proceed as follows.

    0. Revise the new code to address any problems in it.
    1. Describe any semantic changes between the old and the code from step 0, or say "no changes".
        Here are the old:
        ```
        {old_code}
        ```
        Here are the new:
        ```
        {new_code}
        ```
    2. Take the new algorithm:
       ```
       {new_algorithm}
       ```
       and make any necessary changes to reflect the changes from step 1.
    3. Describe any semantic changes between the old algorithm and that from step 2, or say "no changes".
        Here are is old algorithm:
        ```
        {old_algorithm}
        ```
    4. Take the new requirements:
       ```
       {new_requirements}
       ```
       and make any necessary changes to reflect the changes from step 3.
    5. Describe any semantic changes between the old requirements and those from step 4, or say "no changes".
        Here are the old:
        ```
        {old_requirements}
        ```
    6. Take the new label:
       ```
       {new_label}
       ```
       and make any necessary changes to reflect the changes from step 3.




lift_up_changes_from_algorithm: |
    You will be given the old and new descriptions of a computation step.  

    Proceed as follows. Ask questions to clarify any ambiguities or inconsistencies.

    1. Describe any semantic changes between the old and new algorithm, or say "no changes".
        Here are the old:
        ```
        {old_algorithm}
        ```
        Here are the new:
        ```
        {new_algorithm}
        ```
    2. Take the new requirements:
       ```
       {new_requirements}
       ```
       and make any necessary changes to reflect the changes from step 1.
    3. Describe any semantic changes between the old requirements those from step 2, or say "no changes".
        Here are the old:
        ```
        {old_requirements}
        ```
    4. Take the new label:
       ```
       {new_label}
       ```
       and make any necessary changes to reflect the changes from step 3.



lift_up_changes_from_requirements: |
    You will be given the old and new descriptions of a computation step.  

    Proceed as follows. Ask questions to clarify any ambiguities or inconsistencies.

    1. Describe any semantic changes between the old and new requirements, or say "no changes".
        Here are the old:
        ```
        {old_requirements}
        ```
        Here are the new:
        ```
        {new_requirements}
        ```
    2. Take the new label:
       ```
       {new_label}
       ```
       and make any necessary changes to reflect the changes from step 1.




postconditions: |
    Here are the preconditions for a set of variables used by 
    a computation:
    ```
    {preconditions}
    ```

    Start with the label
    ```
    {label}
    ```
    and create a list of postconditions that will hold for the 
    computed value `{function_return_var}`.

    The postconditions should refer to the output as `{function_return_var}` and 
    the inputs by name.  Not all inputs may be used.  The postconditions should be
    detailed enough that the code for that step can be written later using only the preconditions and postconditions.

    The postconditions should be detailed enough that subsequent steps know exactly how to 
    use the output in  `{function_return_var}`.  That includes the type and any constraints on the value,
    as well as the keys to use for any dictionary in the return value.

    Do not use print -- that is a side effect.  Instead, use return values to 
    communicate information about the computation.

    Create a return type for the function that meets the postconditions.
    Favor Records over Dictionaries in the return type.  

    The return type's specification
    should be detailed enough that users of the function can understand what
    the function returns.  That includes the type and any constraints on the value,
    as well as the keys to use for any dictionary in the return value.
    
    If this function returns data from a file, use the column labels 
    and types found in that file.

    Avoid contradictions or redundancies in the postconditions.

    Assume the client has no other information about the function.
    
    {diff}



postconditions-for-plot: |
    Here are the preconditions for a set of variables used by 
    a computation that produces a plot:
    ```
    {preconditions}
    ```

    Start with the label
    ```
    {label}
    ```
    and create a list of postconditions that will hold for the plot.

    Not all inputs may be used.  

    The postconditions you create should be detailed enough that the 
    code for that step can be written later using only the preconditions 
    and postconditions.  Avoid contradictions or redundancies in the postconditions.

    Assume the client has no other information about the function.
    
    {diff}



inconsistent-preconditions: |
    Examine these preconditions for a computation:

    ```
    {preconditions}
    ```
    
    Explain any contradictions.  Do not
    report redundancies or missing conditions.  
    If there are no contradictions, provide an empty list.

# precondition-checks: |
#     1. These are the new preconditions for a computation step:

#     ```
#     {preconditions}
#     ```
    
#     Are there any contradictions in the preconditions?  Explain them.
    
#     Do not
#     report redundancies or missing conditions.  

#     2. These are the old preconditions for a computation step:

#     ```
#     {old_preconditions}
#     ```

#     Examine those old preconditions and identify any that are not implied
#     by the new preconditions.  Id so, explain.

#     3. Here are the postconditions for the computation step:

#     ```
#     {postconditions}
#     ```

#     Do the changes to the preconditions affect the postconditions?  If so, explain how.

locked-requirements-checks: |
    You are analyzing how changes to inputs affect the postconditions for a computation step.
    Use simple English and avoid direct references to any programming concepts.  Be brief.
    Refer to parameters as inputs, preconditions and input requirements, and postconditions as
    output requirements.

    1. These are the new parameters and preconditions for a computation step:

    ```
    {parameters}
    {preconditions}
    ```

    These are the old parameters and preconditions for a computation step:

    ```
    {old_parameters}
    {old_preconditions}
    ```

    Examine the new parameters and preconditions and identify any changes from the old in a list of phrases of less than 10 words.

    2. Here are the postconditions for the computation step:

    ```
    {postconditions}
    ```

    Do the changes to the parameters and preconditions invalidate any of the postconditions?  If so, list how in sentences of less than 12 words of the form "... may need to change because ..."  Do not consider anything beyond the explicit postconditions.

    3.  Here is the old label for the computation step:
    ```
    {old_label}
    ```
    Here is the new label for the computation step:
    ```
    {new_label}
    ```
    Do the changes to label impact affect the relevance of the postconditions?  If so, list how in sentences of less than 12 words of the form "... may need to change because ..."    Do not consider anything beyond the explicit postconditions.


locked-code-checks: |
    You are analyzing how changes to inputs and requirements affect the code for a computation step.
    Use simple English and avoid direct references to any programming concepts.  Be brief.
    Refer to parameters as inputs, preconditions and input requirements, and postconditions as
    output requirements.

    Here are the old parameters, preconditions, requirements, and return type:
    ```
    {old}
    ```

    Here are the new parameters, preconditions, requirements, and return type:
    ```
    {new}
    ```

    1. Describe the changes to the parameters and preconditions in a list of phrases of less than 10 words.
    2  Do the changes to the parameters and preconditions affect the code?  If so, list how in sentences of less than 12 words of the form "... may need to change because ..."
    3. Describe the changes to the requirements and return type in a list of phrases of less than 10 words.
    4. Do the changes to the requirements and return type affect the code?  If so, list how in sentences of less than 12 words of the form "... may need to change because ..."


algorithm: |
    Write prose pseudocode for a function implementing this step's algorithm in 
    markdown.

    The pseudocode should be detailed enough that a function for that step can 
    be written later using only the preconditions, postconditions, and pseudocode.

    Here are the preconditions for the variables you may use:
    ```
    {preconditions}
    ```
    You may assume that those conditions are met.

    Here are the postconditions that the algorithm should establish:
    ```
    {postconditions}
    ```

    If the step already has an algorithm, remove any steps that are not
    necessary or incorrect according to the design of the computation, 
    and add any steps that are missing.

    {diff}

    Your response should be an list of strings, each of which is one step in the algorithm.  
    A step may have substeps that begin with "- ".  Do not use any markdown headers.




compile: |
    Write the code for this step as a single function.

    The parameters have the following types:
    ```
    {parameter_types}
    ```

    Write the function body for this step.
    
    The code should:

    * Implement the requirements as a pure function.
    * Return a value consistent with the return type.
    * Have no side effects.
    * Be optimized for readability, clarity, and simplicity.
    
    You may only import numpy, sklearn, statsmodels, scipy, and pandas.  

    Import any classes referenced in the return type.
    
    Do not include other functions.

    The function should return a value of the specified return type.

    If the step already has code, fix it to implement the requirements and nothing more.

    {diff}

    The code must begin with the following lines:
    ```
    # put all imports here
    def {signature}:
        """"
        # outline goes here
        """"
        # code goes here
    ```

    Identify necessary imports, then outline the code in the pydoc comment, and finally write the body.



compile-for-plot: |
    Write the code for this step as a single function.

    The parameters have the following types:
    ```
    {parameter_types}
    ```

    Write the function body to produce the plot for this step.
    
    The code should:

    * Implement the requirements as a pure function.
    * Have no side effects.
    * Be optimized for readability, clarity, and simplicity.
    
    You may only import matplotlib, seaborn, numpy, sklearn, statsmodels, scipy, and pandas.  

    Uses seaborn for all plots, with
    no changes to the base style.  Do not call `plt.close()`.  Do not call `plt.show()`.  Do not save plots to disk.

    Do not include other functions.

    If the step already has code, fix it to implement the requirements and nothing more.

    {diff}

    The code must begin with the following lines:
    ```
    # put all imports here
    def {signature}:
        """"
        # outline goes here
        """"
        # code goes here
    ```

    Identify necessary imports, then outline the code in the pydoc comment, and finally write the body.


compile-pydoc: |
    Write the code for this step as a single function.
    
    The code should:

    * Implement the requirements as a pure function.
    * Return a value consistent with the return type.
    * Have no side effects.
    * Be optimized for readability, clarity, and simplicity.
    
    You may only import numpy, sklearn, statsmodels, scipy, and pandas.  

    Import any classes referenced in the return type.
    
    Do not include other functions.

    The function should return a value of the declared type.

    If the step already has code, fix it to implement the requirements and nothing more.

    {diff}

    The code must have this format:
    ```
    # put all imports here
    def {signature}:
        """
    {pydoc}
        """
        # code goes here
    ```

    Identify necessary imports and then write the body.


compile-pydoc-for-plot: |
    Write the plotting code for this step as a single function.
    
    The code should:

    * Implement the requirements as a pure function.
    * Have no side effects.
    * Be optimized for readability, clarity, and simplicity.
    
    You may only import matplotlib, seaborn, numpy, sklearn, statsmodels, scipy, and pandas.  

    Uses seaborn for all plots, with
    no changes to the base style.  Do not call `plt.close()`.  Do not call `plt.show()`.  Do not save plots to disk.

    Do not include other functions.

    If the step already has code, fix it to implement the requirements and nothing more.

    {diff}

    The code must have this format:
    ```
    # put all imports here
    def {signature}:
        """
    {pydoc}
        """
        # code goes here
    ```

    Identify necessary imports and then write the body.

assertions-code: |
    Here are the input variables for a function:
    ```
    {input_vars}
    ```
    The inputs satisfy the following requirements:
    ```
    {preconditions}
    ```
    The output for the function is stored in the variable:
    ```
    {output_var}
    ```
    that has this type:
    ```
    {return_type}
    ```
    These are the postconditions for the function.
    ```
    {postconditions}
    ```
    Write assertions to check each of the following additional requirements.
    ```
    {requirements}
    ```    

    For each requirement:
        1.  Use a quantative check containing an assertion if possible.  Use this form and
            no function definitions:
            ```
            ...
            assert ..., "...message..."
            ```
            The assertion's error messages should targeted to non-programmers and 
            provide detailed information about the failure,
            including the expected value and observed value.

        2.  If the postconditions do not ensure the requirement will be met for all
            inputs matching the preconditions, provide a warning 
            message indicating why.  Otherwise, the error message should be empty.

suggest-assertions-code: |
    Here are the input variables for a function:
    ```
    {input_vars}
    ```
    The inputs satisfy the following requirements:
    ```
    {preconditions}
    ```
    The output for the function is stored in the variable:
    ```
    {output_var}
    ```
    that has this type:
    ```
    {return_type}
    ```
    These are the postconditions for the function.
    ```
    {postconditions}
    ```
    I have the following suggestions for additional checks:
    ```
    {requirements}
    ```
    Suggest additional, non-redundant checks that we can perform to gain confidence
    that the function is correct.  Each should be a short sentence describing
    a check that can be performed.  Do not include any code.


assertions-inspect: |
    Here are the input variables for a function:
    ```
    {input_vars}
    ```
    The inputs satisfy the following requirements:
    ```
    {preconditions}
    ```
    These are the postconditions for the function.
    ```
    {postconditions}
    ```
    The output will be provided to you as either a string or image.
    Write qualitative checks to check each of the following additional requirements.
    ```
    {requirements}
    ```    
    For each requirement:
        1. Explain exactly what to look for in the visual representation of the output to 
    verify that the requirement is met.
        2.  If the postconditions do not ensure the requirement will be met for all
            inputs matching the preconditions, a warning message
            indicating why.  Otherwise, the error message should be empty.


suggest-assertions-inspect: |
    Here are the input variables for a function:
    ```
    {input_vars}
    ```
    The inputs satisfy the following requirements:
    ```
    {preconditions}
    ```
    These are the postconditions for the function.
    ```
    {postconditions}
    ```
    I have the following suggestions for additional checks:
    ```
    {requirements}
    ```
    Suggest additional, non-redundant checks that we can perform to gain confidence
    that the function is correct.  Each should be a short sentence describing
    a check that can be performed by visual inspect of the output.


inspect-output: |
    Here is a list of requirements for the output of a function:
    ```
    {requirements}
    ```
    Examine each requirement and report whether it is met.
    * If the requirement is not met, indicate an error and provide a detailed error message explaining why.  
    * If the reqreuiement is met, indicate no error and provide an empty error message.
    Explain your reasoning in each case.

# compile-assertions: |
#     You have written code for this step.  Modify the code to include assertions that
#     check the requirements.  Check both conditions on the return value
#     and on any intermediate values or steps.

#     If the function returns a value, add assertions for all of the requirements to the code.  If the function
#     displays a plot, do not include assertions for the requirements related to visual elements.

#     Do not add assertions for preconditions.  Assume that the preconditions
#     are met.

#     If function already has code with assertions, fix it to implement exactly
#     the requirements and nothing more.

#     {diff}




# sanity-checks: |
#     Write black-box unit test functions to test the 
#     function for this step.  The function will
#     already be imported.

#     Assume the preconditions will be met.

#     Your test suite should verify that:
#     * the types of any return values match the specification.
#     * the function does not modify its inputs.
#     * the function does not have side effects.

#     Use this template for each unit test function definition:
#     ```
#     import seaborn as sns
#     import pandas as pd
#     import numpy as np
#     import matplotlib.pyplot as plt
#     def test():
#         """
#         Describe what the test is doing and what the expected behavior is.
#         """
#         ...
#     ```

#     Use this template for each unit test function call:
#     ```
#     test()
#     ```

sanity-checks: |
    Write one or more unit test functions to test that the
    function for this step does not modify its inputs.

    Use this template:
    ```
    import seaborn as sns
    import pandas as pd
    import numpy as np
    import matplotlib.pyplot as plt
    def test():
        """
        Describe what the test is doing and what the expected behavior is.
        """
        ...
    ```

    Use this template for the unit test function call:
    ```
    test()
    ```


unit-tests: |
    Write a list of inputs/expected output for testing this function.
    For each test case:

    * For each input, write a Python expression to produce a value for that input.
      Pandas has been imported as `pd`, and numpy as `np`.  Use those libraries as
      needed.

    * The inputs should be small enough that the correct result can be
      computed by hand.  

    * The function will already be imported.

    * Ensure your inputs meet the preconditions.

    * Do not call any helper functions in the sample inputs or output.

    * Some tests may already be present -- complement those with additional tests.

    * Cover all postconditions in your tests and look for boundary cases 
    or unusual inputs that might cause the function to fail.

    * Write Code tests for conditions that can be tested automatically.  Otherwise, write Inspect tests.


unit-test-input: |
    You will help me create input values for a unit test.  The input type is:
    ```
    {type}
    ```
    The requirements on that input are:
    ```
    {preconditions}
    ```
    Write the body of a Python function called `create_input` 
    that evaluates to a value of type 
    ```
    {type}
    ```
    that meets those requirements and is small enough that the correct 
    result can be computed by hand.

    Use this template for your response:
    ```
    def create_input():
        # any necessary imports
        ...
        return ...
    ```

unit-test-inputs: |
    You will help me create input values for a unit test.  The 
    goal is to test this condition:
    ```
    {goal}
    ```
    Here is a specification of the inputs:
    ```
    {requirements}
    ```
    Write the body of a Python function called `create_input` 
    that returns a dictionary mapping input names to 
    values that meet the requirements and are small enough that the correct
    result can be computed by hand.

    Use this template for your response:
    ```
    def create_input():
        # any necessary imports
        ...
        return ...
    ```

inspect-outputs:
    You will help me check whether the output of a function in a datascience
    computation meets an expected condition.  Indicate whether the condition
    holds or not, and explain why.

report: |
    Generate a detailed report on a data science computation project. The report should be structured into the following sections: 
        1. **Title**: Provide a concise and descriptive title for the report. 
        2. **Introduction**: 
            * **Background**: Give an overview of the problem or question addressed in the project. 
            * **Objectives**: Clearly state the objectives of the computation or analysis. 
        3. **Data Sources**: 
            * **Description of Data**: Describe the data sources used, including the type of data, how it was collected, and its relevance to the project. 
            * **Data Preparation**: Explain any preprocessing steps taken to clean or transform the data. 
        4. **Methodology**: 
            * **Outline of Work**: Detail the steps taken in the computation, including any algorithms, models, or analytical techniques used. 
            * **Assumptions**: List and justify any assumptions made during the analysis. 
        5. **Statistical Analysis**: 
            * **Exploratory Data Analysis**: Summarize key findings from the initial exploration of the data. 
            * **Modeling and Evaluation**: Describe the modeling techniques used, how models were evaluated, and the metrics for evaluation. 
        6. **Results**: 
            * **Statistical Conclusions**: Present the main statistical findings and interpretations. Include any visualizations or tables that were created or that support the conclusions.
        7. **Discussion**:
            * **Insights**: Discuss the insights gained from the analysis and their implications.
            * **Limitations**: Identify any limitations or potential biases in the analysis. 
        8. **Conclusions**: 
            * **Summary**: Provide a summary of the main findings and their significance. 
            * **Recommendations**: Offer recommendations based on the findings of the project. 
            * **Future Work**: Suggest areas for further research or improvements to the analysis.


classify_ama_prompt : |
    You are an expert in data science.  You are helping a user create work with data science computation diagram for a task. 
    The user has asked you a question. Classify whether the question is asking for information about the computation graph, dataset, 
    or conclusions that can be drawn from them, or whether the question is asking for a modification to the dataflow graph.
    ```

ama_general: |
    You are an expert at statistical analysis and data science.  Help the
    user with their question.  Explain your reasoning and provide a clear
    and concise answer.  Refer to nodes by their pills in text you write.
    Refer to ndoes by ids in function calls.  

ama_explain: |
    Answer the following question about the computation graph, dataset, and conclusions that can be drawn from them.

    You should:
    1. Restate the hypothesis or question in your own words.
    2. Explain how you will approach the question.
    3. Explain each step of your analysis.  Make function calls to help answer the question.
    4. Provide a recommendation or a conclusion based on the results of your analysis.

ama_modify: |
    Modify the dataflow graph according to the following request.  You may add or remove nodes, 
    or change the connections between nodes.  Nodes should be connected in a way that makes sense for the
    dataflow computation.  Transitive edges are implied and do not need to be explicitly added.
    Each node will be implemented as a single function that takes the incoming data and returns the outgoing data.
    Do not write code.  Only modify the graph.

    Instructions:
    1. Identify the necessary changes to the dataflow graph for the request.
    2. For each change, use a function call to make the change.

skip: |
    You should:
    1. Restate the request in your own words.  Break down tasks into smaller steps.
    2. Identify the necessary changes to the dataflow graph for those steps.
    3. For each change, explain the rationale behind it to the user and use a function call to make the change.
 

#####################

ama_node_editor: |
    You are an expert at statistical analysis and data science.  Help the
    user modify a node in their dataflow-graph based computation.  
    
    The label, requirements, return type, and code must all be consistent with
    each other and with the changes you make. Do not change the function name,
    parameter names, or parameter types.

    The new postconditions should be detailed enough that the code for that step can be written later using only the preconditions and postconditions.

    The postconditions should be detailed enough that subsequent steps know exactly how to 
    use the output. That includes the type and any constraints on the value,
    as well as the keys to use for any dictionary in the return value.

    The new return type for the function that meets the postconditions.
    Favor Records over Dictionaries in the return type.  

    The new return type's specification
    should be detailed enough that users of the function can understand what
    the function returns.  That includes the type and any constraints on the value,
    as well as the keys to use for any dictionary in the return value.
    
    Avoid contradictions or redundancies in the postconditions.

    The code should:

    * Implement the requirements as a pure function.
    * Return a value consistent with the return type.
    * Have no side effects.
    * Be optimized for readability, clarity, and simplicity.
    
    You may only import numpy, sklearn, statsmodels, scipy, and pandas.  

    Import any classes referenced in the return type.
    
    Do not include other functions.

    Assume the client has no other information about the function.

    Explain your reasoning and provide a clear and concise answer in simple English.  
    Nore more than 50 words.

    You should:
    1. Restate the request in your own words.  Break down tasks into smaller steps.
    2. Identify the necessary changes to the node for those steps.
    
    Use a function call to make the changes.

ama_node_editor_no_code: |
    You are an expert at statistical analysis and data science.  Help the
    user modify a node in their dataflow-graph based computation.  
    
    The label, requirements and return type must all be consistent with
    each other and with the changes you make. Do not change the function name,
    parameter names, or parameter types.

    The new postconditions should be detailed enough that the code for that step can be written later using only the preconditions and postconditions.

    The postconditions should be detailed enough that subsequent steps know exactly how to 
    use the output. That includes the type and any constraints on the value,
    as well as the keys to use for any dictionary in the return value.

    The new return type for the function that meets the postconditions.
    Favor Records over Dictionaries in the return type.  

    The new return type's specification
    should be detailed enough that users of the function can understand what
    the function returns.  That includes the type and any constraints on the value,
    as well as the keys to use for any dictionary in the return value.
    
    Avoid contradictions or redundancies in the postconditions.

    Explain your reasoning and provide a clear and concise answer in simple English.  
    Nore more than 50 words.

    You should:
    1. Restate the request in your own words.  Break down tasks into smaller steps.
    2. Identify the necessary changes to the node for those steps.
    
    Use a function call to make the changes.

#########################


ama_node_editor-for-plot: |
    You are an expert at statistical analysis and data science.  Help the
    user modify a node in their dataflow-graph based computation.  
    
    The label, requirements, and code must all be consistent with
    each other and with the changes you make. Do not change the function name,
    parameter names, or parameter types.

    The new postconditions should be detailed enough that the code for that step can be written later using only the preconditions and postconditions.
    
    Avoid contradictions or redundancies in the postconditions.

    The code should:

    * Implement the requirements as a pure function.
    * Return a value consistent with the return type.
    * Have no side effects.
    * Be optimized for readability, clarity, and simplicity.
    
    You may only import matplotlib, seaborn, numpy, sklearn, statsmodels, scipy, and pandas.  

    Use seaborn for all plots, with
    no changes to the base style.  Do not call `plt.close()` and *do not* save them to disk.

    Do not include other functions.

    Assume the client has no other information about the function.

    Explain your reasoning and provide a clear and concise answer in simple English.  
    Nore more than 50 words.

    You should:
    1. Restate the request in your own words.  Break down tasks into smaller steps.
    2. Identify the necessary changes to the node for those steps.
    
    Use a function call to make the changes.

ama_node_editor_no_code-for-plot: |
    You are an expert at statistical analysis and data science.  Help the
    user modify a node in their dataflow-graph based computation.  
    
    The label and requirements must all be consistent with
    each other and with the changes you make. Do not change the function name,
    parameter names, or parameter types.

    The new postconditions should be detailed enough that the code for that step can be written later using only the preconditions and postconditions.
    
    Avoid contradictions or redundancies in the postconditions.

    Explain your reasoning and provide a clear and concise answer in simple English.  
    Nore more than 50 words.

    You should:
    1. Restate the request in your own words.  Break down tasks into smaller steps.
    2. Identify the necessary changes to the node for those steps.
    
    Use a function call to make the changes.



########################

ama_node_editor_sync_no_code: |
    You are an expert at statistical analysis and data science.  Help the
    user analyze a node in their dataflow-graph based computation.

    Here is the label:
    ```
    {label}
    ```
    Here are the requirements:
    ```
    {requirements}
    ```

    * The label describes what the computation produces.  It should not mention any variables.
    * The requirements refine the label to more precisely describe the output of the computation and where it is stored.
    * The return type is the type of the output.  
    * The function_return_var and pill both refer to where the output is stored.

    Determine whether the requirements directly contradict the label.  If so, explain how to fix it in 10 words or less.  
    Only the label and requirements may be changed.  If no changes are needed, say "no changes".
    
    Examples:
    ```
    The **Label** says *x*, but the **Requirements** say *y*. Change ...

    All good! No changes needed.
    ```

ama_node_editor_sync: |
    You are an expert at statistical analysis and data science.  Help the
    user analyze a node in their dataflow-graph based computation.

    Here is the label:
    ```
    {label}
    ```
    Here are the requirements:
    ```
    {requirements}
    ```
    Here is the code:
    ```
    {code}
    ```

    * The label describes what the computation produces.  It should not mention any variables.
    * The requirements refine the label to more precisely describe the output of the computation and where it is stored.
    * The return type is the type of the output.  
    * The function_return_var and pill both refer to where the output is stored.
    * The code implements the computation described by the label and requirements.

    Determine whether the requirements directly contradict the label.  If so, explain how to fix it in 10 words or less.
    Determine whether the code implements the label and requirements.  If not, explain how to fix it in 10 words or less.
    Only the label, requirements, code may be changed.  If no changes are needed, say "no changes".
    
    Examples:
    ```
    The **Code** says *x*, but the **Requirements** say *y*. Change ...
    Ask me to make the change if you'd like!

    All good! No changes needed.
    ```

add-bugs: |
    You are an assistant to take the code for a data science data flow computation
    and add bugs to the code.

    Intentionally include a programming bug to the code part of each node
    that would cause the tests for that node to fail.  
    
    Describe those bugs in comments in the code.

    Preserve the structure of the functions and their names and the tests parts.

repair-system: |
    You are an assistant to take a dataflow graph and generate code.  Your job
    is to help repair an error in the Python implementation of the dataflow graph.

    Always provide an explanation in yor response that describes the error and how to fix it.

    Provide a new version of the code with minimal changes to fix the error.

repair-syntax: |
    The code for a dataflow node cannot be parsed or has an error in its signature.  
    Fix it.  This is the node:
    ```
    {node}
    ```

    The code should:

    * Implement the requirements as a pure function.
    * Return a value consistent with the return type.
    * Have no side effects.
    * Be optimized for readability, clarity, and simplicity.
    * Do not include pydoc strings.

    You may only import matplotlib, seaborn, numpy, sklearn, statsmodels, scipy, and pandas.  

    Import any classes referenced in the return type.
    
    Uses seaborn for all plots, with
    no changes to the base style.  Do not call `plt.close()`.  Do not call `plt.show()`.  Do not save plots to disk.

    Do not define additional functions.  All TypedDict definitions should be inlined in the signature.

    The code must begin with the following lines.  You may not change them.
    ```
    # put all imports here
    def {signature}:
    ```

    This is the error:
    ```
    {error}
    ```

repair-syntax-old: |
    The code for a dataflow node cannot be parsed or has an error in its signature.  
    Fix it.  This is the node:
    ```
    {node}
    ```
    This is the error:
    ```
    {error}
    ```

# repair-test-syntax: |
#     The code for a dataflow node test cannot be parsed.  Fix it.  This is the test:
#     ```
#     {test}
#     ```
#     This is the error:
#     ```
#     {error}
#     ```

# repair-test: | 
#     The code for a dataflow node failed its tests.  Fix it.  This is the node:
#     ```
#     {node}
#     ```
#     This is the error:
#     ```
#     {error}
#     ```

#     If the error is an assertion error, provide the minimal change to that node's code to fix the error.

#     If the error appears in the text code and is not an assertion error, it is likely an error with the test code.

# repair-run: | 
#     The dataflow graph failed to run.  Fix it. 
#     This is the error:
#     ```
#     {error}
#     ```

repair-node-run: |
    The dataflow graph failed to run.  Fix the node that caused the error.
    The code should:

    * Implement the requirements as a pure function.
    * Return a value consistent with the return type.
    * Have no side effects.
    * Be optimized for readability, clarity, and simplicity.
    * Do not include pydoc strings.
    
    You may only import matplotlib, seaborn, numpy, sklearn, statsmodels, scipy, and pandas.  

    Import any classes referenced in the return type.
    
    Uses seaborn for all plots, with
    no changes to the base style.  Do not call `plt.close()`.  Do not call `plt.show()`.  Do not save plots to disk.

    Do not define additional functions.  All TypedDict definitions should be inlined in the signature.

    The code must begin with the following lines.  You may not change the signature.
    ```
    # put all imports here
    def {signature}:
    ```

    This is the error:
    ```
    {error}
    ```


repair-node-run-old: | 
    The dataflow graph failed to run.  Fix the node that caused the error.
    The function siguature is:
    ```
    {signature}
    ```
    It is correct.  You may not change it.
    This is the error:
    ```
    {error}
    ```
    


repair-node-assertions: | 
    A node in the dataflow graph failed to pass some tests.  
    Fix it.  These are the messages for the test failures:
    ```
    {errors}
    ```
    Make minimal changes to that node's code to fix the errors.
    Here are the variables used in the tests:
    ```
    {context}
    ```

repair-node-unit_tests: | 
    A node in the dataflow graph failed to pass some tests.  
    Fix it.  These are the messages for the test failures:
    ```
    {errors}
    ```
    Make minimal changes to that node's code to fix the errors.




# repair-one-test: | 
#     The code for a dataflow node failed a test.  Fix it.  
    
#     This is the node:
#     ```
#     {node}
#     ```
#     This is the error:
#     ```
#     {error}
#     ```

#     If the error is an assertion error, provide the minimal change to that node's code to fix the error.

#     If the error appears in the test code and is not an assertion error, it is likely an error with the test code.

# repair-one-test-followup: | 
#     The code is still not passing the test.

#     This is the new error:
#     ```
#     {error}
#     ```

#     Fix either the code, the test, or both.



# # These are used by the UI

# gen-node-description: |
#     The current description for node with id `{node_id}` is:
#     ```
#     {current}
#     ``` 
    
#     The description should:

#     * Include any requirements on inputs. Include the type for each input, any 
#     required column labels for tables, expectations on the rows for tables, and 
#     expected input values.
#     * Include a description of what the computation returns.
#     * Be detailed enough that code for that step can be written using only the
#     description.
#     * Be detailed enough that tests for that step can be written using only the
#     description.

#     Use the following format in your answer:
#     ```
#     # Description
#     ...

#     # Input requirements
#     ...

#     # Output
#     ...

#     # Assumptions
#     ...
#     ```

# gen-diagram-description: |
#     The current description for diagram is:
#     ```
#     {current}
#     ``` 
    
#     The description should:

#     * Include any requirements on inputs. Include the type for each input, any 
#     required column labels for tables, expectations on the rows for tables, and 
#     expected input values.
#     * Include a description of what the diagram computes.
#     * Be detailed enough that code for the diagram can be written using only the
#     description.

#     Your response should be only the description, with no other text or ```s.

# page-suggestions: |
#     You are an assistant helping a user create a dataflow computation diagram
#     for a data science task.  Create a list of PageSuggestion steps to help the user.
#     Use as many steps as necessary.  Each step should be a single text chunk or operation.




# edit_node: |
#     Here is a dataflow graph for a data science computation.  
#     ```
#     {graph}
#     ```
    
#     You need to edit this node:
#     ```
#     {old}
#     ```

#     * The label describes the function at the highest level.
#     * The requirements describe the postconditions on the function and must conform
#         to the label.
#     * The algorithm describes the steps of the function and must conform to the requirements.
#     * The code describes the implementation of the function and must conform to the algorithm.
    
#     These new components were created by the user to describe the behavior of the function:
#     ```
#     {new}
#     ```

#     Your task is to compare the old and new components, identify any differences, propagate
#     the differences through the components, and provide revised components that are consistent
#     with the differences.

#     {update}

#     Proceed as follows:
    
#     * Describe any semantic changes between the old and new label.  Ask questions to clarify and 
#         inconsistencies or ambiguities.

#     * Create a revised label that includes any semantic changes between the old and new.

#     * Describe any semantic changes between the old and new requirements and how to adjust them
#     to accomodate the revised label.  Ask questions to clarify and 
#         inconsistencies or ambiguities.

#     * Create revised requirements that are consistent with the revised label and carry forward any semantic
#     changes to the label and requirements.

#     * Describe any semantic changes between the old and new algorithm and how to adjust them to accomodate
#     the revised requirements.  Ask questions to clarify and 
#         inconsistencies or ambiguities.

#     * Create a revised algorithm that refines and is consistent with the revised requirements and reflects any semantic changes to the requirements.

#     * Describe any semantic changes between the old and new code.  Ask questions to clarify and 
#         inconsistencies or ambiguities.

#     * Create revised code that refines and is consistent with the revised algorithm and reflects any semantic
#     changes to the algorithm.

#     The revised components should be as clear and concise as possible.



# edit_node_label: |
#     Here is a dataflow graph for a data science computation.  
#     ```
#     {graph}
#     ```
    
#     You need to edit this node:
#     ```
#     {old}
#     ```

#     * The label describes the function at the highest level.
#     * The requirements describe the postconditions on the function and must conform
#         to the label.
#     * The algorithm describes the steps of the function and must conform to the requirements.
#     * The code describes the implementation of the function and must conform to the algorithm.
    
#     These new components were created by the user to describe the behavior of the function:
#     ```
#     {new}
#     ```

#     Your task is to compare the old and new components, identify any differences, propagate
#     the differences through the components, and provide revised components that are consistent
#     with the differences.

#     {update}

#     The revised components should be as clear and concise as possible.

#     Proceed as follows:
    
#     * Describe any semantic changes between the old and new label.  Ask questions to clarify and 
#         inconsistencies or ambiguities.

#     * Create a revised label that includes any semantic changes between the old and new.

# edit_node_requirements: |
#     Proceed as follows:

#     * Describe any semantic changes between the old and new requirements and how to adjust them
#     to accomodate the revised label.  Ask questions to clarify and inconsistencies or ambiguities.

#     * Create revised requirements that are consistent with the revised label and carry forward any semantic
#     changes to the label and requirements.

# edit_node_algorithm: |
#     * Describe any semantic changes between the old and new algorithm and how to adjust them to accomodate
#     the revised requirements.  Ask questions to clarify and 
#         inconsistencies or ambiguities.

#     * Create a revised algorithm that refines and is consistent with the revised requirements and reflects any semantic changes to the requirements.

# edit_node_code: |
#     * Describe any semantic changes between the old and new code.  Ask questions to clarify and 
#         inconsistencies or ambiguities.

#     * Create revised code that refines and is consistent with the revised algorithm and reflects any semantic
#     changes to the algorithm.




full-compile: |
    Here are the preconditions for a set of variables used by 
    a computation:
    ```
    {preconditions}
    ```

    Complete the following steps:

    1. *Postconditions*
    
    Start with the label
    ```
    {label}
    ```
    and create a list of postconditions that will hold for the 
    computed value `{function_return_var}`.

    The postconditions should refer to the output as `{function_return_var}` and 
    the inputs by name.  Not all inputs may be used.

    Create a return type for the function that meets the postconditions.  The 
    return type must be an extended type except Any.

    The return type's specification
    should be detailed enough that users of the function can understand what
    the function returns.  Do not include a specificaiton if the return
    type is None.
    
    The type should reflect what is described in the specification.
    The return type for functions generating plots should be None.

    Assume the client has no other information about the function.
    
    If this function returns data from a file, use the column labels 
    and types found in that file.

    The postconditions you create should be detailed enough that the 
    code for that step can be written later using only the preconditions 
    and postconditions.  Avoid contradictions or redundancies in the postconditions.

    Ask questions to resolve any ambiguities you encounter.

    {diff_req}

    2. *Description*

    Write a 3-5 sentence description of what this computation step does.

    3. *Return Description*

    Write a one sentence description of the value returned by
    this function.  Be detailed enough that users of the function can understand
    what the function returns without reading the source code.



full-compile-sink: |
    Here are the preconditions for a set of variables used by 
    a computation:
    ```
    {preconditions}
    ```

    Complete the following steps:

    1. *Posconditions*

    Choose a specific output format.

    Start with the label
    ```
    {label}
    ```
    and create a list of postconditions.

    The postconditions should refer to the inputs by name.  Not all inputs may be used.

    The postconditions you create should be detailed enough that the 
    code for that step can be written later using only the preconditions 
    and postconditions.  Avoid contradictions or redundancies in the postconditions.

    The return type should be `None` if the function generates a plot.  Otherwise,
    create a return type for the function that meets the postconditions.

    {diff_req}

    2. *Description*

    Write a 3-5 sentence description of what this computation step does.

    3 * Return Description*

    The computed valued description should be "None" if the function generates a plot.  Otherwise,
    write a one sentence description of the value returned by this function.


full-compile-algorithm: |
    4. *Algorithm*

    Write prose pseudocode for a function implementing this step's algorithm in 
    markdown.

    The pseudocode should be detailed enough that a function for that step can 
    be written later using only the preconditions, postconditions, and pseudocode.

    If the step already has an algorithm, remove any steps that are not
    necessary or incorrect according to the design of the computation, 
    and add any steps that are missing.

    Your response should be an list of strings, each of which is one step in the algorithm.  
    Steps should begin with "*".
    A step may have substeps that begin with "  -".  Do not use any markdown headers.

    {diff_alg}

full-compile-code: |

    5. *Code*

    Write the code for this step as a single function.  It must match the following.
    ```
    # put all imports here
    def {signature}:
        ...
    ```

    The parameters have the following types:
    ```
    {parameter_types}
    ```

    Write the code for this step as a single function with the given
    name, parameters, and return type.  
    
    The code should:

    * Implement the requirements as a pure function.
    * Include types for parameters and return values.  
    * Return a value consistent with the return type.
    * Have no side effects.
    * Be optimized for readability, clarity, and simplicity.
    
    You may only import matplotlib, seaborn, numpy, sklearn, statsmodels, scipy, and pandas.  
    Use seaborn for all plots, with
    no changes to the base style.  Do not call `plt.close()` and *do not* save them to disk.

    Do not include other functions.

    The function should return a value of the appropriate type, or None if the function displays a plot.

    If the step already has code, fix it to implement the requirements and nothing more.

    {diff_code}

###########################################

change_command_no_alg: |
    Here is the current label, requirements, and code for a computation step:
    ```
    {current}
    ```
    You will modify it to do the following:
    ```
    {command}
    ```
      
    Proceed as follows. Ask questions to clarify any ambiguities or inconsistencies.

    1. Describe the differences in the label, requirements, and code between the current
       and the changed node.
    2. Take the current label and make any necessary changes to the label to reflect the changes from step 1.
    3. Take the current requirements and function_return_type 
       and make any necessary changes to those fields to reflect the changes from step 1.
    4. Take the current code and make any necessary changes to the code to reflect the changes from step 1.

lift_up_changes_from_code_no_alg: |
    You will be given the old and new descriptions of a computation step.  

    Proceed as follows. Ask questions to clarify any ambiguities or inconsistencies.

    1. Describe any semantic changes between the old and new code, or say "no changes".
        Here are the old:
        ```
        {old_code}
        ```
        Here are the new:
        ```
        {new_code}
        ```
    2. Take the new requirements:
       ```
       {new_requirements}
       ```
       and make any necessary changes to reflect the changes from step 1.
    3. Describe any semantic changes between the old requirements and those from step 2, or say "no changes".
        Here are the old:
        ```
        {old_requirements}
        ```
    6. Take the new label:
       ```
       {new_label}
       ```
       and make any necessary changes to reflect the changes from step 3.


lift_up_changes_from_editing_no_alg: |
    You will be given the old and new descriptions of a computation step.  

    Proceed as follows.

    0. Revise the new code to address any problems in it.
    1. Describe any semantic changes between the old and the code from step 0, or say "no changes".
        Here are the old:
        ```
        {old_code}
        ```
        Here are the new:
        ```
        {new_code}
        ```
    2. Take the new requirements:
       ```
       {new_requirements}
       ```
       and make any necessary changes to reflect the changes from step 1.
    5. Describe any semantic changes between the old requirements and those from step 2, or say "no changes".
        Here are the old:
        ```
        {old_requirements}
        ```
    6. Take the new label:
       ```
       {new_label}
       ```
       and make any necessary changes to reflect the changes from step 1.


#####

unit_tests-code: |
    Here are the input variables for a function:
    ```
    {input_vars}
    ```
    The inputs satisfy the following requirements:
    ```
    {preconditions}
    ```
    The output for the function is stored in the variable:
    ```
    {output_var}
    ```
    The function has this return type:
    ```
    {return_type}
    ```
    These are the postconditions for the function.
    ```
    {postconditions}
    ```
    Write unit tests code to check each of the following additional unit test description.
    ```
    {unit_tests}
    ```    

    For each test:
        1.  Write code to construct function input values that satisfy the preconditions and the 
            test specification.
        
            Then use a quantative check containing an assertion if possible.  Use this form and
            no function definitions:
    ```
    {input_lines}
    {output_var}_result = {call_to_node}
    assert ..., "...message..."
    ```
            The assertion's error messages should targeted to non-programmers and 
            provide detailed information about the failure,
            including the expected value and observed value.

        2.  If the postconditions do not ensure the requirement will be met for all
            inputs matching the preconditions, provide a warning 
            message indicating why.  Otherwise, the error message should be empty.

suggest-unit_tests-code: |
    Here are the input variables for a function:
    ```
    {input_vars}
    ```
    The inputs satisfy the following requirements:
    ```
    {preconditions}
    ```
    The output for the function is stored in the variable:
    ```
    {output_var}
    ```
    The function has this return type:
    ```
    {return_type}
    ```
    These are the postconditions for the function.
    ```
    {postconditions}
    ```
    I have the following suggestions for additional checks:
    ```
    {unit_tests}
    ```
    Suggest additional, non-redundant unit tests that we can perform to gain confidence
    that the function is correct.  Each should be a short description of the inputs
    and expected outcome.  Do not include any code.


unit_tests-inspect: |
    Here are the input variables for a function `{function_name}`:
    ```
    {input_vars}
    ```
    The inputs satisfy the following requirements:
    ```
    {preconditions}
    ```
    The function has this return type:
    ```
    {return_type}
    ```
    These are the postconditions for the function.
    ```
    {postconditions}
    ```
    The output will be provided to you as either a string or image.
    Write unit test code and qualitativ checks 
    to check each of the following additional unit test descriptions.
    ```
    {unit_tests}
    ```    

    For each test:
        1.  Write code to construct function input values that satisfy the preconditions and the 
            test specification.  Then call the function `{function_name}`, which is
            already defined -- do not write it.  Use this exact form:
            ```
            {input_lines}
            {call_to_node}
            ```
            Explain exactly what to look for in the visual representation of the output to 
            verify that the unit test passes.

        2.  If the postconditions do not ensure the unit test will be met for all
            inputs matching the preconditions, provide a warning 
            message indicating why.  Otherwise, the error message should be empty.

suggest-unit_tests-inspect: |
    Here are the input variables for a function:
    ```
    {input_vars}
    ```
    The inputs satisfy the following requirements:
    ```
    {preconditions}
    ```
    The function has this return type:
    ```
    {return_type}
    ```
    These are the postconditions for the function.
    ```
    {postconditions}
    ```
    I have the following suggestions for additional checks:
    ```
    {unit_tests}
    ```
    Suggest additional, non-redundant unit tests that we can perform to gain confidence
    that the function is correct.  Each should be a short description of the inputs
    and expected outcome.  Do not include any code.
